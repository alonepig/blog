{"meta":{"title":"Shjlone's Blog","subtitle":"Hello World","description":"Hello World","author":"shjlone","url":"http://shjlone.github.io"},"pages":[{"title":"","date":"2021-05-29T06:50:55.094Z","updated":"2021-05-29T06:50:55.094Z","comments":false,"path":"/404.html","permalink":"http://shjlone.github.io/404.html","excerpt":"","text":"Error 404 Not Found - 页面君不见了哟~ 404 退散！ 您所访问的地址无法找到或者已经被删除了， 如果您是从搜索结果点击进来看到的 404，可以先尝试使用页面 右上方的搜索文章。 访问本站出现 404，一般是因为以下原因： 本站启用固定链接之后，搜索引擎未全面更新收录。所以有时候搜索结果里的文章链接是错误的。 来都来了，就先逛逛嘛~~ 您可以访问 本站主页 ，或者联系我，吐槽下问题的详细情况， 也可以通过页面上方的 分类 或 标签 来查看本站已有的一些 tags。","raw":null,"content":null},{"title":"About","date":"2016-10-24T02:24:00.000Z","updated":"2021-06-07T07:51:58.774Z","comments":true,"path":"about/index.html","permalink":"http://shjlone.github.io/about/index.html","excerpt":"","text":"介绍一个一直以来比较菜的程序员!什么都懂一点，但貌似没一样精通的！o(╯□╰)o 关注IT技术，分享学到的知识，分享生活的乐趣。 此博客内容因博主见识、表达措辞、查阅资料有限、资料时效性变化等因素，内容不能保证完全正确或适合读者使用！！！ 此博客乃学习笔记，主要目的是方便自己检阅、巩固学习时的知识整理，其中错漏残缺不可避免，如果读者有任何新发现烦请留言，互勉学习而进步。 关于程序员的自我修养要想成为一名还行的程序员，需要学的东西真的不少。技术更新迭代的速度非常之快，怎么才能不在信息浪潮中落伍，我觉得还是要注重基础，下盘劳了，学什么都不费劲。而基础有哪些呢？ 计算机组成原理 操作系统原理 数据结构 算法 设计模式 网络原理 底层原理性的东西的变化速度是远远慢于应用层的技术迭代的，而应用层的技术很多都是依赖于这些底层技术的。所以，大家还是把这些东西都牢记于心吧！ 关于此博客的搭建我对自己写博客的需求： 使用方便，查阅方便； 容易构建、发布、分享； 博客展示能支持树状结构，方便知识体系的归类； 文章支持显示目录； 支持评论、统计等功能 最终选择使用hexo构建，主题来源于https://github.com/zthxxx/hexo-theme-Wikitten。这套主题基本满足了我的需求，在此感谢作者。 一些小东西 ActionScript3版本的Flappy Bird Alfred股票小助手 ： 用于快速查询实时股价 精选的Alfred的workflow 你可以在这里找到我： 豆瓣 Github 知乎 stackoverflow 力扣","raw":null,"content":null},{"title":"Categories","date":"2021-05-29T06:50:55.135Z","updated":"2021-05-29T06:50:55.135Z","comments":true,"path":"categories/index.html","permalink":"http://shjlone.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"Tags","date":"2021-05-29T06:50:55.136Z","updated":"2021-05-29T06:50:55.136Z","comments":true,"path":"tags/index.html","permalink":"http://shjlone.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"动画造成的OOM的处理方式","slug":"Android/性能优化/OOM专题/动画造成的OOM的处理方式","date":"2021-06-10T12:37:02.537Z","updated":"2021-06-10T12:37:29.485Z","comments":true,"path":"wiki/Android/性能优化/OOM专题/动画造成的OOM的处理方式/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E5%8A%A8%E7%94%BB%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/","excerpt":"","text":"参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Bitmap造成的OOM的处理方式","slug":"Android/性能优化/OOM专题/Bitmap造成的OOM的处理方式","date":"2021-06-10T09:23:17.551Z","updated":"2021-06-10T09:23:31.943Z","comments":true,"path":"wiki/Android/性能优化/OOM专题/Bitmap造成的OOM的处理方式/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/Bitmap%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"非静态内部类造成的OOM的处理方式","slug":"Android/性能优化/OOM专题/非静态内部类造成的OOM的处理方式","date":"2021-06-10T09:07:24.489Z","updated":"2021-06-10T10:03:07.249Z","comments":true,"path":"wiki/Android/性能优化/OOM专题/非静态内部类造成的OOM的处理方式/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/","excerpt":"","text":"问题分析我们日常写代码中，很容易写一些以下样子的代码： 123456789101112131415161718192021222324252627282930public class OOMInnerClassActivity extends Activity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_oom_inner_class); EditText editText = findViewById(R.id.oom_edittext); TextView textView = findViewById(R.id.oom_textview); editText.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; textView.setText(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125;&#125; 上面的代码中，TextWatcher的匿名内部类是会持有Activity的引用的。如果它没有跟着Activity的生命周期一起销毁，则会引发内存泄漏。 为什么匿名内部类会持有外部引用而静态内部类不会呢？静态内部类它是静态的呀，只能访问外部的静态变量，无需持有外部对象的引用。 解决方式其实这种现象跟Handler的处理方式是类似的，监听器持有弱引用，且生命周期结束时同步销毁。可参考以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class OOMInnerClassRightActivity extends Activity &#123; public TextView textView; EditText editText; WeakTextWatcher weakTextWatcher; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_oom_inner_class); editText = findViewById(R.id.oom_edittext); textView = findViewById(R.id.oom_edittext); weakTextWatcher = new WeakTextWatcher(this); editText.addTextChangedListener(weakTextWatcher); &#125; //使用静态内部类 private static class WeakTextWatcher implements TextWatcher &#123; //使用弱引用 private WeakReference&lt;OOMInnerClassRightActivity&gt; activityWeakReference; WeakTextWatcher(OOMInnerClassRightActivity activity) &#123; activityWeakReference = new WeakReference&lt;OOMInnerClassRightActivity&gt;(activity); &#125; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; OOMInnerClassRightActivity activity = activityWeakReference.get(); if(activity != null) &#123; activity.textView.setText(s.toString()); &#125; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //释放监听 editText.removeTextChangedListener(weakTextWatcher); weakTextWatcher = null; &#125;&#125; 也可以参考Handler基本用法 参考 Android - 匿名内部类导致内存泄露的处理办法 匿名内部类导致内存泄露的面试题","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"LeakCanary","slug":"Android/开源库/LeakCanary","date":"2021-06-10T08:50:27.638Z","updated":"2021-06-10T08:50:41.506Z","comments":true,"path":"wiki/Android/开源库/LeakCanary/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/LeakCanary/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Glide","slug":"Android/开源库/Glide","date":"2021-06-10T07:22:52.311Z","updated":"2021-06-10T07:23:02.720Z","comments":true,"path":"wiki/Android/开源库/Glide/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Glide/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"RxJava","slug":"Java/开源库/RxJava","date":"2021-06-07T10:16:51.809Z","updated":"2021-06-07T10:17:02.873Z","comments":true,"path":"wiki/Java/开源库/RxJava/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%BC%80%E6%BA%90%E5%BA%93/RxJava/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"开源库","slug":"Java/开源库","permalink":"http://shjlone.github.io/categories/Java/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Handler基本用法","slug":"Android/基础/Handler基本用法","date":"2021-06-07T06:13:25.099Z","updated":"2021-06-08T02:45:08.475Z","comments":true,"path":"wiki/Android/基础/Handler基本用法/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Handler%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","excerpt":"","text":"Hanlder系列目录： Handler基本用法 Handler原理 概要A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instanceis associated with a single thread and that thread’s message queue. When you create a new Handler it is bound to a Looper.It will deliver messages and runnables to that Looper’s message queue and execute them on that Looper’s thread. There are two main uses for a Handler: (1) to schedule messages and runnables to be executed at some point in the future;and (2) to enqueue an action to be performed on a different thread than your own. Scheduling messages is accomplished with the post(Runnable), postAtTime(java.lang.Runnable, long),postDelayed(Runnable, Object, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long), andsendMessageDelayed(Message, long) methods. The post versions allow you to enqueue Runnable objects to be called by themessage queue when they are received; the sendMessage versions allow you to enqueue a Message object containing a bundleof data that will be processed by the Handler’s handleMessage(Message) method (requiring that you implement a subclass of Handler). When posting or sending to a Handler, you can either allow the item to be processed as soon as the message queue is readyto do so, or specify a delay before it gets processed or absolute time for it to be processed. The latter two allow youto implement timeouts, ticks, and other timing-based behavior. When a process is created for your application, its main thread is dedicated to running a message queue that takes careof managing the top-level application objects (activities, broadcast receivers, etc) and any windows they create. Youcan create your own threads, and communicate back with the main application thread through a Handler. This is done bycalling the same post or sendMessage methods as before, but from your new thread. The given Runnable or Message will thenbe scheduled in the Handler’s message queue and processed when appropriate. Handler用于Android中的线程通信。主要的用于在异步线程中发送Message或者直接运行一个Runnable，即可回到主线程执行UI操作。Handler在哪个线程初始化，则它依附在哪个线程。Activity中有一个runOnUiThread方法，封装了Handler可以直接在异步线程中使用。Handler也可以延迟执行。 代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.lqd.androidpractice.handler;import android.app.Activity;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.util.Log;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import com.lqd.androidpractice.R;import org.jetbrains.annotations.NotNull;import java.lang.ref.WeakReference;/** * handler 使用实例 * * 在异步线程发送消息到主线程刷新UI * * @author: a564 * @Date 2021/6/7 */public class HandlerActivity extends Activity &#123; private static String TAG = &quot;HandlerActivity&quot;; private TextView textView; private MyHandler myHandler; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_handler); textView = findViewById(R.id.ah_textview); findViewById(R.id.ah_btn1).setOnClickListener(v -&gt; &#123; new Thread() &#123; @Override public void run() &#123; super.run(); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.d(TAG, Thread.currentThread().getStackTrace()[2].getMethodName()); Message msg = Message.obtain(); msg.what = 1; // 消息标识 msg.obj = &quot;A&quot;; // 消息内存存放 myHandler.sendMessage(msg); // 异步线程发送消息 //使用post myHandler.post(new Runnable() &#123; @Override public void run() &#123; //回到UI线程 &#125; &#125;); &#125; &#125;.start(); &#125;); myHandler = new MyHandler(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); myHandler.removeCallbacksAndMessages(null);//跟随Activity销毁 myHandler = null; &#125; //静态内部类 private static class MyHandler extends Handler &#123; //弱引用 WeakReference&lt;HandlerActivity&gt; activityWeakReference; public MyHandler(HandlerActivity activity) &#123; activityWeakReference = new WeakReference&lt;HandlerActivity&gt;(activity); &#125; @Override public void handleMessage(@NonNull @NotNull Message msg) &#123; super.handleMessage(msg); Log.d(TAG, Thread.currentThread().getStackTrace()[2].getMethodName()); Log.d(TAG, msg.toString()); HandlerActivity activity = activityWeakReference.get(); if (activity == null) return; switch (msg.what) &#123; case 1: activity.textView.setText(&quot;执行了线程1的UI操作&quot;); break; case 2: activity.textView.setText(&quot;执行了线程2的UI操作&quot;); break; &#125; &#125; &#125;;&#125; HandlerThread顾名思义，HandlerThread使得Thread拥有的Handler的特性，可以在此线程中进行消息的分发和处理。使用场景也是创建异步线程并有数据交互。我们也可以将其封装成一个工具类，这样不需要每次都new一个线程出来，方便使用且节省性能。 123456789101112131415161718192021222324252627282930313233343536373839class BackgroundHandlerThread &#123; private static class Holder&#123; private static BackgroundHandlerThread _instance = new BackgroundHandlerThread(); static&#123; _instance.init(); &#125; &#125; public static BackgroundHandlerThread getInstance()&#123; return Holder._instance; &#125; private HandlerThread mHandlerThread; private Handler mHandler; private void init()&#123; //HandlerThread的第二个参数为线程优先级 mHandlerThread = new HandlerThread(BackgroundHandlerThread.class.getSimpleName()); mHandlerThread.start(); mHandler = new Handler(mHandlerThread.getLooper())&#123; @Override public void handleMessage(Message msg) &#123; &#125; &#125;; &#125; public Looper getLooper()&#123; return mHandlerThread.getLooper(); &#125; public Handler getHandler()&#123; return this.mHandler; &#125;&#125;// 当需要异步执行的地方可以直接使用下面的代码BackgroundHandlerThread.getInstance().getHandler().post(Runnable) API介绍sendMessage(Message message) 发送消息到消息队列 post(Runnable runable) 把一个Runnable对象添加到消息队列中，这个方法会在对应Looper的线程中运行。 dispatchMessage(Message msg) 将消息分发给对应的Handler handleMessage 根据某个消息类型进行处理 参考 https://developer.android.com/reference/android/os/Handler 详解 Android 中的 HandlerThread","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"ThreadPoolExecutor","slug":"Java/并发编程/ThreadPoolExecutor","date":"2021-06-07T03:47:22.391Z","updated":"2021-06-07T03:47:38.454Z","comments":true,"path":"wiki/Java/并发编程/ThreadPoolExecutor/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"查找算法","slug":"算法/查找","date":"2021-06-07T01:45:07.568Z","updated":"2021-06-07T01:45:07.568Z","comments":true,"path":"wiki/算法/查找/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/","excerpt":"","text":"顺序查找顺序查找（Sequential Search）又称线性查找。从表中第一个(或最后一个)记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，如果查找到表中最后一个元素，还没有找到，则查找不成功。 二分查找二分查找（Binary Search）又称折半查找。它的前提是线性表中的记录必须是关键码有序，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。 插值查找(Interpolation Search)基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。即根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式mid=low+(key-a[low])/(a[high]-a[low])(high-low)，替换了二分查找的计算公式mid=low+1/2(high-low)。 这样的好处在于，对表长较长，且关键字分布比较均匀，插值查找算法的平均性能要比折半查找要好的多。但是如果表中关键字分布极端不均匀，那么插值查找还不如折半查找呢。 斐波那契查找(Fibonacci Search)也是一种改进的二分查找，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。 斐波那契查找的整个过程可以分为： 构建斐波那契数列； 计算数组长度对应的斐波那契数列元素个数； 对数组进行填充； 循环进行区间分割，查找中间值； 判断中间值和目标值的关系，确定更新策略； 二叉树查找对二叉查找树进行中序遍历，即可得到有序的数列。 平衡树2-3查找树红黑树B树(B_树)、B+树B树也称B-树,它是一颗多路平衡查找树 分块查找分块查找又称索引顺序查找，它是顺序查找的一种改进方法。 算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，…… 算法流程： step1 先选取各块中的最大关键字构成一个索引表； step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。 哈希查找我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。 总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。 什么是哈希函数？ 哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。 算法思想：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。 算法流程： 1）用给定的哈希函数构造哈希表； 2）根据选择的冲突处理方法解决地址冲突； 常见的解决冲突的方法：拉链法和线性探测法。详细的介绍可以参见：浅谈算法和数据结构: 十一 哈希表。 3）在哈希表的基础上执行哈希查找。 哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。 复杂度分析： 单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。 使用Hash，我们付出了什么？ 我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV pair，经常使用Python的博友可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？ Hash是一种典型以空间换时间的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。 参考 算法可视化演示","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"排序算法","slug":"算法/排序","date":"2021-06-07T01:45:07.567Z","updated":"2021-06-07T01:45:07.567Z","comments":true,"path":"wiki/算法/排序/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"插入排序直接插入排序具体算法： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2-5。 希尔排序希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。 希尔排序实质上是一种分组直接插入方法。 基本思想： 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，即所有记录放在同一组中进行直接插入排序为止, 整个数列就是有序的。 选择排序直接选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 堆选择排序什么是堆？堆结构有很多种，如二叉堆、B堆、斐波那契堆、三元堆，树堆、弱堆等。二叉堆是堆实现中最流行的一种。二叉堆是一个完全二叉树，树的所有内部节点都被完全填充，最后一层可以完全填充的或部分填充。通俗的说，堆（二叉堆）可以视为一棵完全的二叉树。完全二叉树的一个优秀的性质就是，除了最底层之外，每一层都是满的。堆又分为最大堆（堆顶Root是最大值）和最小堆（堆顶Root是最小值）。 总结一下，只要你是一个完全二叉树，父节点又大于子节点，你就是堆。 完全二叉树 + 父节点大于(或小于)子节点 = 堆 https://chihokyo.com/post/18/ 交换排序冒泡排序从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。 快速排序 https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html 归并排序归并排序算法完全遵循分治模式。直观上其操作如下： 分解：分解等排序的n个元素的序列成各具n/2个元素的两个子序列；解决：使用归并排序递归地排序两个子序列；合并：合并两个已排序的子序列以产生已排序的答案。 https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F#Python3 各种内排序方法的比较","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PHP中opcodes的原理","slug":"程序语言/PHP/PHP中opcodes的原理","date":"2021-06-07T01:45:07.567Z","updated":"2021-06-07T01:45:07.567Z","comments":true,"path":"wiki/程序语言/PHP/PHP中opcodes的原理/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/PHP%E4%B8%ADopcodes%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"PHP代码的生命周期不启用OPcache的流程 启用OPcache的流程 Scanning：将PHP代码转换为语言片段（Tokens） Parsingg：将Tokens转换成简单而有意义的表达式 Compilation：将表达式编译成opcodes Execution:执行opcodes，每次一条，从而实现PHP脚本的功能 opcodes当一个 PHP 文件被解释执行的时候，首先是被编译成名为 opcode （CPU专用的机器语言指令）的中间代码，然后才被底层的虚拟机执行。 如果PHP文件没有被修改过，opcode 始终是一样的。这就意味着编译步骤白白浪费了 CPU 的资源。此时 opcode 缓存就派上用场了。通过将 opcode 缓存在内存中，它能防止冗余的编译步骤，并且在下次调用执行时得到重用。一般执行过程是先检查文件的签名（signature）或者修改时间，以防文件有改动。 PHP 5.5 以后的所有版本都内置了一个 opcode 缓存工具，叫做 Zend OPcache。 根据你所使用的 PHP 安装包/发行版的不同，一般情况下是默认开启的，请查看 OPcache.enable phpinfo() 和 phpinfo() 输出的信息确认是否已经开启。 Operate Code：当解释器完成对脚本代码的分析后，便将它们生成可以直接运行的中间代码，也称为操作码。 OPcacheopcode cache的目地是避免重复编译，减少CPU和内存开销。 PHP配置PHP5.5以上默认有OPcache，如果需要安装，则使用以下脚本： 123456wget http://pecl.php.net/get/zendOPcache-7.0.3.tgztar zxvf zendOPcache-7.0.3.tgz &amp;&amp; cd zendOPcache-7.0.3/usr/local/php/bin/phpize./configure --with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make install php.ini配置说明 123456789101112131415161718192021222324252627282930[Zend Opcache]zend_extension = OPcache.so#比较常用的配置OPcache.enable=1 #是否启用操作码缓存OPcache.enable_cli=1 #仅针对CLI环境启用操作码缓存OPcache.revalidate_freq=60 #检查文件的修改的时间周期, 定位为秒，即缓存后60秒去检查代码文件是否被修改过OPcache.fast_shutdown=1 #打开快速关闭, 一次释放全部请求变量的内存，打开这个在PHP Request Shutdown的时候回收内存的速度会提高;OPcache.error_log=&quot;&quot; #OPcache模块的错误日志文件;OPcache.log_verbosity_level=1 #将错误信息写入到服务器的日志级别。致命（0）错误（1) 警告（2）信息（3）调试（4）#其它不常用的配置OPcache.memory_consumption=128 #共享内存大小，单位MBOPcache.interned_strings_buffer=8 #存储临时字符串的内存大小，单位MBOPcache.max_accelerated_files=4000 #哈希表中可存储的脚本文件数量上限;OPcache.max_wasted_percentage=5 #浪费内存的上限，以百分比计;OPcache.use_cwd=1 #附加改脚本的工作目录,避免同名脚本冲突OPcache.validate_timestamps=1 #每隔revalidate_freq 设定的秒数 检查脚本是否更新;OPcache.revalidate_path=0 #如果禁用此选项，在同一个 include_path 已存在的缓存文件会被重用;OPcache.save_comments=1 #禁用后将也不会加载注释内容OPcache.enable_file_override=0 #如果启用，则在调用函数file_exists()， is_file() 以及 is_readable() 的时候， 都会检查操作码缓存;OPcache.optimization_level=0xffffffff #控制优化级别的二进制位掩码。;OPcache.inherited_hack=1 #PHP 5.3之前做的优化;OPcache.dups_fix=0 #仅作为针对 “不可重定义类”错误的一种解决方案。;OPcache.blacklist_filename=&quot;&quot; #黑名单文件为文本文件，包含了不进行预编译优化的文件名;OPcache.max_file_size=0 #以字节为单位的缓存的文件大小上限;OPcache.consistency_checks=0 #如果是非 0 值，OPcache 将会每隔 N 次请求检查缓存校验和OPcache.force_restart_timeout=180 #如果缓存处于非激活状态，等待多少秒之后计划重启。;OPcache.preferred_memory_model=&quot;&quot; #OPcache 首选的内存模块。可选值包括： mmap，shm, posix 以及 win32。;OPcache.protect_memory=0 #保护共享内存，以避免执行脚本时发生非预期的写入。 仅用于内部调试。;OPcache.mmap_base=null #在Windows 平台上共享内存段的基地址 监测OPcache 可视化显示：https://github.com/PeeHaa/OpCacheGUI **简易的显示缓存信息(PHP7+)**：https://github.com/rlerdorf/opcache-status 相关PHP的API使用12345opcache_is_script_cached(string $filename):bool 是否缓存opcache_get_configuration(): array 获取缓存的配置信息opcache_invalidate(string $script , boolean $force = false):boolean 废除脚本缓存opcache_reset():boolean 重置字节码缓存的内容 参考 Understanding OPCode OPcache运行时配置 PHP Opcache工作原理 PHP内核探索：操作码OpCode OPcache安装配置及链接生效配置 OPcache 函数 Opcode是啥以及如何使用好Opcache","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://shjlone.github.io/tags/PHP/"}]},{"title":"Symfony使用记录","slug":"程序语言/PHP/symfony使用记录","date":"2021-06-07T01:45:07.567Z","updated":"2021-06-07T01:45:07.567Z","comments":true,"path":"wiki/程序语言/PHP/symfony使用记录/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/symfony%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Symfony中请求的流程如何在新接口部署的时候平稳的切换缓存使用php console cache:warmup命令，进行缓存预热，当缓存文件全部生成好后，即可平稳当切换。而不是手动删除缓存文件，待请求来之后再生成缓存。 参考 https://blog.whiteoctober.co.uk/index.html%3Fp=1751.html","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://shjlone.github.io/tags/PHP/"}]},{"title":"cef笔记","slug":"程序语言/C++/cef","date":"2021-06-07T01:45:07.566Z","updated":"2021-06-07T01:45:07.566Z","comments":true,"path":"wiki/程序语言/C++/cef/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/cef/","excerpt":"","text":"官网：https://github.com/chromiumembedded/cef下载地址：http://opensource.spotify.com/cefbuilds/index.html Python版： https://github.com/cztomczak/cefpython","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://shjlone.github.io/tags/C/"}]},{"title":"socket编程笔记","slug":"程序语言/C++/socket编程笔记","date":"2021-06-07T01:45:07.566Z","updated":"2021-06-07T01:45:07.566Z","comments":true,"path":"wiki/程序语言/C++/socket编程笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/socket%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"API介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int socket(int af, int type, int protocol);af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。type 为数据传输方式，常用的有 SOCK_STREAM 和 SOCK_DGRAMprotocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDPint bind(int sock, struct sockaddr *addr, socklen_t addrlen); //Linuxint bind(SOCKET sock, const struct sockaddr *addr, int addrlen); //Windowssock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。struct sockaddr_in&#123; sa_family_t sin_family; //地址族（Address Family），也就是地址类型 uint16_t sin_port; //16位的端口号 struct in_addr sin_addr; //32位IP地址 char sin_zero[8]; //不使用，一般用0填充&#125;;int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen); //Linuxint connect(SOCKET sock, const struct sockaddr *serv_addr, int addrlen); //Windows让套接字进入被动监听状态，所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。 int listen(int sock, int backlog); //Linuxint listen(SOCKET sock, int backlog); //Windowssock 为需要进入监听状态的套接字backlog 为请求队列的最大长度请求队列当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。缓冲区的长度（能存放多少个客户端请求）可以通过 listen() 函数的 backlog 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是10或者20。如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误，对于 Windows，客户端会收到 WSAECONNREFUSED 错误。int accept(int sock, struct sockaddr *addr, socklen_t *addrlen); //LinuxSOCKET accept(SOCKET sock, struct sockaddr *addr, int *addrlen); //Windows返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字Linux下的数据接收和发送会将缓冲区 buf 中的 nbytes 个字节写入文件 fd，成功则返回写入的字节数，失败则返回 -1。ssize_t write(int fd, const void *buf, size_t nbytes);fd 为要写入的文件的描述符，buf 为要写入的数据的缓冲区地址，nbytes 为要写入的数据的字节数。 会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1。ssize_t read(int fd, void *buf, size_t nbytes);Windows下的数据接收和发送int send(SOCKET sock, const char *buf, int len, int flags);int recv(SOCKET sock, char *buf, int len, int flags); 基本概念socket缓冲区每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。 write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。 TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 这些I/O缓冲区特性可整理如下： I/O缓冲区在每个TCP套接字中单独存在； I/O缓冲区在创建套接字时自动生成； 即使关闭套接字也会继续传送输出缓冲区中遗留的数据； 关闭套接字将丢失输入缓冲区中的数据。 输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取： 12345unsigned optVal;int optLen = sizeof(int);getsockopt(servSock, SOL_SOCKET, SO_SNDBUF, (char*)&amp;optVal, &amp;optLen);printf(&quot;Buffer length: %d\\n&quot;, optVal); 阻塞模式对于TCP套接字（默认情况下），当使用 write()/send() 发送数据时： 首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么 write()/send() 会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()/send() 函数继续写入数据。 如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()/send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()/send() 才会被唤醒。 如果要写入的数据大于缓冲区的最大长度，那么将分批写入。 直到所有数据被写入缓冲区 write()/send() 才能返回。 当使用 read()/recv() 读取数据时： 首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()/recv() 函数再次读取。 直到读取到数据后 read()/recv() 函数才会返回，否则就一直被阻塞。 这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。 TCP数据报结构以及三次握手TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。 客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。 TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话： [Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。” [Shake 2] 套接字B：“好的，我这边已准备就绪。” [Shake 3] 套接字A：“谢谢你受理我的请求。” TCP数据报结构 带阴影的几个字段需要重点说明一下： 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：建立一个新连接。 FIN：断开一个连接。 Seq 是 Sequence 的缩写，表示序列；Ack(ACK) 是 Acknowledge 的缩写，表示确认；SYN 是 Synchronous 的缩写，愿意是“同步的”，这里表示建立同步连接；FIN 是 Finish 的缩写，表示完成。 连接的建立（三次握手） 客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。 这个时候，客户端开始发起请求： 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。 服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。服务器将数据包发出，进入SYN-RECV状态。 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了。 数据的传输过程 上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1个数据包发送100个字节的数据，数据包的 Seq 号设置为 1200。主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。 为了保证数据准确到达，目标机器在收到数据包（包括SYN包、FIN包、普通数据包等）包后必须立即回传ACK包，这样发送方才能确认数据传输成功。 此时 Ack 号为 1301 而不是 1201，原因在于 Ack 号的增量为传输的数据字节数。假设每次 Ack 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全部正确传递还是丢失了一部分，比如只传递了80字节。因此按如下的公式确认 Ack 号： Ack号 = Seq号 + 传递的字节数 + 1，与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。 下面分析传输过程中数据包丢失的情况，如下图所示： 上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。 为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。 重传超时时间（RTO, Retransmission Time Out） 这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。 往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 ACK 确认包（接收端收到数据后便立即确认），总共经历的时延。 重传时间 TCP数据包重传次数根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传3次，如果重传3次后还未收到该数据包的 ACK 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。 TCP四次握手断开连接建立连接需要三次握手，断开连接需要四次握手，可以形象的比喻为下面的对话： [Shake 1] 套接字A：“任务处理完毕，我希望断开连接。” [Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。” 等待片刻后…… [Shake 3] 套接字B：“我准备好了，可以断开连接了。” [Shake 4] 套接字A：“好的，谢谢合作。” 建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求： 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。 服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。 注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。 客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。 服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。 关于 TIME_WAIT 状态的说明 客户端最后一次发送 ACK包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，这是为什么呢？ TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，不能丢失或出错，而网络是不稳定的，随时可能会毁坏数据，所以机器A每次向机器B发送数据包后，都要求机器B”确认“，回传ACK包，告诉机器A我收到了，这样机器A才能知道数据传送成功了。如果机器B没有回传ACK包，机器A会重新发送，直到机器B回传ACK包。 客户端最后一次向服务器回传ACK包时，有可能会因为网络问题导致服务器收不到，服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到ACK包了，所以客户端需要等待片刻、确认对方收到ACK包后才能进入CLOSED状态。那么，要等待多久呢？ 数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为报文最大生存时间（MSL，Maximum Segment Lifetime）。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包。 窗口协议ARQ协议ARQ协议主要包含：停等ARQ协议、连续ARQ协议，其中连续ARQ协议是为了解决停等ARQ协议信道利用率低的问题，目前传统的连续ARQ协议有回退N帧ARQ协议、选择性重传ARQ协议。 连续ARQ协议（Continuous ARQ） 回退N帧ARQ协议（Go-Back-N） 接收端丢弃从第一个没有收到的数据包开始的所有数据包 发送端收到NACK后，从NACK中指明的数据包开始重新发送 选择性重传ARQ协议（Selective Repeat） 发送端连续发送数据包但对每个数据包都设有个一个计时器 当在一定时间内没有收到某个数据包的ACK时，发送端只重新发送那个没有ACK的数据包","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://shjlone.github.io/tags/C/"}]},{"title":"C语言学习笔记","slug":"程序语言/C++/C语言学习笔记","date":"2021-06-07T01:45:07.566Z","updated":"2021-06-07T01:45:07.566Z","comments":true,"path":"wiki/程序语言/C++/C语言学习笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Hello World1234567891011121314//文件名hello.c//预处理指令#include &lt;stdio.h&gt;//入口函数int main() &#123; printf(&quot;hello world&quot;); return 0;&#125;gcc hello.c./a.out //输出hello world C语言数据类型 字符型（char）：描述单个字符（一个字节），用半角的单引号包含起来，如’a’、’A’、’1’、’$’等，键盘能输入的英文和半角的符号都是字符。中文的汉字和标点符号是两个字节（GBK编码），不能算一个字符。 整型（int）：描述整数。 浮点型（float）：描述实数。 字符串：描述多个字符，用半角的双引号包含起来，可以是英文、数字、中文、标点符号，半角全角的都可以。 结构体（struct）：由基本类型通过一定的构造方法构造出来的类型，包括数组和结构体。 指针类型：指针可以存放内存变量和常量地址。 其他类型：如复数类型（_Complex）、虚数类型（_Imaginary）、布尔型（_bool）等。 变量变量的命名变量名属于标识符，需要符合标识符的命名规范，具体如下： 变量名的第一个字符必须是字母或下划线，不能是数字和其它字符。 变量名中的字母是区分大小写的。比如a和A是不同的变量名，num和Num也是不同的变量名。 变量名绝对不可以是C语言的关键字。 变量的定义和初始化变量在定义后，操作系统为它分配了一块内存，但并不会把这块内存打扫干静，也就是说内存中可能有垃圾数据，建议在使用之间对其初始化（打扫干静）。 1234567891011121314151617181920212223242526int ii; // 定义整数型变量，用于存放整数。char cc; // 定义字符型变量，用于存放字符。double money; // 定义浮点型变量，用于存放浮点数。char name[21]; // 定义一个可以存放20字符的字符串。//对整数型、字符型、浮点型变量来说，初始化就是给它们赋0值。int ii=0; // 定义整数型变量并初始化char cc=0; // 定义字符型变量并初始化double money=0; // 定义浮点型变量并初始化 //也可以先定义，然后再初始化。int ii; // 定义整数型变量char cc; // 定义字符型变量double money; // 定义浮点型变量ii=0; // 初始化ii为0cc=0; // 初始化cc为0money=0; // 初始化money为0//对字符串变量来说，初始化就是把内容清空，本质上也是赋0值。char name[21]; // 定义一个可以存放20字符的字符串memset(name,0,sizeof(name)); // 清空字符串name中的内容//声明常量const double pi = 3.1415926; C语言中的关键字1234567891011121314151617181920212223242526272829303132auto：声明自动变量break：跳出当前循环case：开关语句分支char：声明字符型变量或函数返回值类型const：声明只读变量continue：结束当前循环，开始下一轮循环default：开关语句中的“默认”分支do：循环语句的循环体double：声明双精度浮点型变量或函数返回值类型else：条件语句否定分支（与if连用）enum：声明枚举类型extern：声明变量或函数是在其它文件或本文件的其他位置定义float：声明浮点型变量或函数返回值类型for：一种循环语句goto：无条件跳转语句if：条件语句int：声明整型变量或函数long：声明长整型变量或函数返回值类型register：声明寄存器变量return：子程序返回语句（可以带参数，也可不带参数）short：声明短整型变量或函数signed：声明有符号类型变量或函数sizeof：计算数据类型或变量长度（即所占字节数）static：声明静态变量struct：声明结构体类型switch：用于开关语句typedef：用以给数据类型取别名unsigned：声明无符号类型变量或函数union：声明共用体类型void：声明函数无返回值或无参数，声明无类型指针volatile：说明变量在程序执行中可被隐含地改变while：循环语句的循环条件 输入和输出12345678910111213141516171819202122232425262728293031getchar：输入单个字符，保存到字符变量中。gets：输入一行数据，保存到字符串变量中。scanf：格式化输入函数，一次可以输入多个数据，保存到多个变量中。putchar：输出单个字符。puts：输出字符串。printf：格式化输出函数，可输出常量、变量等。int age=18;char xb=&#x27;x&#x27;;double weight=62.5;char name[21];memset(name,0,sizeof(name));strcpy(name, &quot;西施&quot;);printf(&quot;我的姓名是：%s，姓别：%c，年龄：%d岁，体重%lf公斤。\\n&quot;,name,xb,age,weight);int age=0;char xb=0;double weight=0;char name[21];memset(name,0,sizeof(name));printf(&quot;请输入您的姓名、姓别（x-男；y-女），年龄和体重，中间用空格分隔：&quot;);scanf(&quot;%s %c %d %lf&quot;,name,&amp;xb,&amp;age,&amp;weight); printf(&quot;您的姓名是：%s，姓别：%c，年龄：%d岁，体重%lf公斤。\\n&quot;,name,xb,age,weight); 运算符 算术运算符； 赋值运算符； sizeof运算符； 关系运算符； 逻辑运算符； 位运算符。 算术运算符 运算符 描述 实例 + 两个数相加 A+B 将得到 23 - 一个数减另一个数 A-B 将得到 13 * 两个数相乘 A*B 将得到 90 / 分子除以分母 A/B 将得到 3.6 % 余数运算符，整除后的余数 B%A 将得到 3 ++ 自增运算符，整数值增加 1 A++ 将得到 19 – 自减运算符，整数值减少 1 A– 将得到 17 赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求余数且赋值运算符，求两个操作数的模赋值给左边操作数，浮点数不适用取余数。 C %= A 相当于 C = C % A sizeof运算符用来计算变量（或数据类型）在当前系统中占用内存的字节数。sizeof不是函数，产生这样的疑问是因为sizeof的书写确实有点像函数，sizeof有两种写法： 1234567891011121314//用于数据类型，数据类型必须用括号括住。sizeof(数据类型);printf(&quot;字符型变量占用的内存是=%d\\n&quot;,sizeof(char)); // 输出：字符型变量占用的内存是=1printf(&quot;整型变量占用的内存是=%d\\n&quot;,sizeof(int)); // 输出：整型变量占用的内存是=4//用于变量sizeof(变量名);sizeof 变量名;int ii;printf(&quot;ii占用的内存是=%d\\n&quot;,sizeof(ii)); // 输出：ii占用的内存是=4printf(&quot;ii占用的内存是=%d\\n&quot;,sizeof ii); // 输出：ii占用的内存是=4 关系运算符 关系 数学中的表示 C语言的表示 小于 &lt; &lt; 小于等于 ≤ &lt;= 大于 &gt; &gt; 大于等于 ≥ &gt;= 等于 = == 不等于 ≠ != 逻辑运算符 运算符 描述 实例 &amp;&amp; 逻辑与 true &amp;&amp; false 等于false || 逻辑或 true &amp;&amp; false 等于true ! 逻辑非 true的逻辑非为真 三目运算符 表达式1?表达式2:表达式3; 先执行表达式1，如果表达式1的结果如果为真，那么执行表达式2，并且这个整体的运算式的结果是表达式2的结果；如果表达式1的结果如果为假，执行表达式3，运算式的结果是表达式3的结果。 12int year;year=(year%100==0)?(year%400==0?1:0):(year%4==0?1:0); if、switch语句1234567891011121314151617if(表达式)&#123;&#125; else &#123;&#125;switch (表达式)&#123;case 整型数值1: 语句1;case 整型数值2: 语句2;......case 整型数值n: 语句n;default: 语句n+1;&#125;//注意//1. case后面必须是整数和字符，或者是结果为整数和字符的表达式，但不能包含任何变量//2. default不是必须的。当没有 default时，如果所有case都匹配失败，那么就什么都不执行。 程序结构while循环123456789101112131415161718192021222324252627282930while (表达式)&#123; if(表达式)语句块; if(表达式)break;//跳出当前循环 if(表达式)continue; //跳转到循环的首部&#125;do&#123; 语句块&#125; while (表达式)int times=0; // 记录用户输入数据的次数int value=0; // 用户每次从键盘输入的数据int sum=0; // 记录用户输入数据的和while (sum&lt;5000) // 如果sum的值小于5000，进入循环&#123;printf(&quot;请输入数字：&quot;); // 提示用户输入scanf(&quot;%d&quot;,&amp;value); // 接受用户从键盘输入的数据times++; // 用户输入数据的次数自增1sum=sum+value; // 记录用户输入数据的和&#125;printf(&quot;您一共输入了%d个数据，和为%d。\\n&quot;,times,sum); for循环12345for (语句1;表达式;语句2) &#123; 语句块 &#125; for循环开始时，会先执行语句1，而且在整个循环过程中只执行一次语句1。 接着判断表达式的条件，如果条件成立，就执行一次循环体中的语句块。 语句块执行完后，接下来会执行语句2。 重复第2）步和第3），直到表达式的条件不成立才结束for循环。 注意： 在for循环中，语句1、表达式和语句2都可以为空，for (;;)等同于while (1)。 continue和break两个关键字也可以用在for循环体中。 123456789int ii=1; // 用于for循环的计数器 int sum=0; // 记录1到100的累积值 for (ii=1;ii&lt;=100;ii++) &#123; sum=sum+ii; &#125; printf(&quot;1到100的累积值为%d。\\n&quot;,sum); 数组数组（array）是一组数据类型相同的变量，可以存放一组数据，它定义的语法是： 数据类型 数组名[数组长度]; 定义数组的时候，数组的长度必须是整数，可以是常量，也可以是变量。数据的下标也必须是整数，可以是常量，也可以是变量。 1234567int ii[10]; // 定义一个整型数组变量printf(&quot;sizeof(ii)=%d\\n&quot;,sizeof(ii)); // 输出结果：sizeof(ii)=40//数组初始化int no[10];memset(no,0,sizeof(no)); //第一个参数是数组名，第二个参数填0，第三个参数是数组占用的内存总空间，用sizeof(变量名)获取。 二维数组 数据类型 数组名[第一维的长度][第二维的长度]; 1234567891011121314151617181920int ii=0; // 用于组别循环的计数器int jj=0; // 用于超女人数循环的计数器int class=3; // 小组总数，初始化为3int total=5; // 每个组超女的总人数，初始化为5double weight[class][total]; // 定义二维数组，存放超女的体重double sum[class]; // 定义一维数组存放超女体重的和memset(weight,0,sizeof(weight)); // 初始化数组为0memset(sum,0,sizeof(sum)); // 初始化数组为0// 采用两个循环，第一级循环为小组数，第二级循环为超女人数for (ii=0;ii&lt;class;ii++)&#123;for (jj=0;jj&lt;total;jj++)&#123; printf(&quot;请输入第%d组第%d名超女的体重：&quot;,ii+1,jj+1); scanf(&quot;%lf&quot;,&amp;weight[ii][jj]); // 接受从键盘输入的体重 sum[ii]=sum[ii]+weight[ii][jj]; // 计算小组超女体重的和&#125;&#125; 字符串字符串就是一个以空字符’\\0’结束的字符数组，是一个特别的字符数组，这是约定，是规则。空字符’\\0’也可以直接写成0。 1234567891011121314151617//初始化， 因为字符串需要用0结束，所以在定义字符串的时候，要预留多一个字节来存放0。char name[21]; // 定义一个最多存放20个字符或10个汉字的字符串//字符串是数组，当然可以用初始化数组的方法来初始化字符串。memset(strname,0,sizeof(strname));//字符串的赋值strcpy(strword,&quot;hello&quot;);// 或者用以下代码char strword[21];memset(strword,0,sizeof(strword));strword[0]=&#x27;h&#x27;;strword[1]=&#x27;e&#x27;;strword[2]=&#x27;l&#x27;;strword[3]=&#x27;l&#x27;;strword[4]=&#x27;o&#x27;;strword[5]=&#x27;\\0&#x27;; // 或者 name[5]=0; 函数函数声明 return_type function_name( parameter list ); 返回值的数据类型return_type：函数执行完任务后的返回值，可以是int、char、double或其它自定义的数据类型。如果函数只执行任务而不返回值，return_type用关键字 void表示，如下： 1void function_name( parameter list ); 函数名function_name：函数名是标识符，命名规则与变量相同。 参数列表parameter list：当函数被调用时，调用者需要向函数传递参数。参数列表包括参数的数据类型和书写顺序。参数列表是可选的，也就是说，函数可以没有参数，如下： 1return_type function_name(); 函数定义12345//函数定义的return_type、function_name和parameter list必须与函数声明一致。return_type function_name( parameter list ) // 注意，不要在函数定义的最后加分号。 &#123; // 实现函数功能的代码 &#125; 注意： #include &lt;&gt; 用于包含系统提供的头文件，编译的时候，gcc在系统的头文件目录中寻找头文件。 #include “” 用于包含程序员自定义的头文件，编译的时候，gcc先在当前目录中寻找头文件，如果找不到，再到系统的头文件目录中寻找。 库函数C语言标准库函数的声明的头文件存放在/usr/include目录中，如下： 123&lt;asset.h&gt; &lt;ctype.h&gt; &lt;errno.h&gt; &lt;float.h&gt; &lt;limits.h&gt;&lt;locale.h&gt; &lt;math.h&gt; &lt;setjmp.h&gt; &lt;signal.h&gt; &lt;stdarg.h&gt;&lt;stddef.h&gt; &lt;stdlib.h&gt; &lt;stdio.h&gt; &lt;string.h&gt; &lt;time.h&gt; 变量的作用域作用域是程序中定义的变量存在（或生效）的区域，超过该区域变量就不能被访问。C 语言中有四种地方可以定义变量。 在所有函数外部定义的是全局变量。 在头文件中定义的是全局变量。 在函数或语句块内部定义的是局部变量。它们只能在该函数或语句块内部的语句使用。 函数的参数是该函数的局部变量。 注意 局部变量和全局变量的名称可以相同，在某函数或语句块内部，如果局部变量名与全局变量名相同，就会屏蔽全局变量而使用局部变量。 指针变量 内存变量简称变量，在C语言中，每定义一个变量，系统就会给变量分配一块内存，而内存是有地址的。如果把计算机的内存区域比喻成一个大宾馆，每块内存的地址就像宾馆房间的编号。 12345678 int ii=10; char cc=&#x27;A&#x27;; double dd=100.56;//在printf函数中，输出内存地址的格式控制符是%p，地址采用十六进制的数字显示。 printf(&quot;变量ii的地址是：%p\\n&quot;,&amp;ii); printf(&quot;变量cc的地址是：%p\\n&quot;,&amp;cc); printf(&quot;变量dd的地址是：%p\\n&quot;,&amp;dd); 指针 指针是一种特别变量，全称是指针变量，专用于存放其它变量在内存中的地址编号，指针在使用之前要先声明，语法是： 123456789101112131415161718192021222324252627282930313233343536datatype *varname;datatype 是指针的基类型，它必须是一个有效的C数据类型（int、char、double或其它自定义的数据类型），varname 是指针的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。int *ip; // 一个整型的指针char *cp; // 一个字符型的指针double *dp; // 一个 double 型的指针int ii = 10;int *pii = 0; // 定义整数型指针并初始化pii = &amp;ii; // 数型指针指向变量ii// 通过指针操作内存变量，改变内存变量的值*pii = 20; // 同ii=20;printf(&quot;pii的值是：%p\\n&quot;, pii);printf(&quot;*pii的值是：%d\\n&quot;, *pii);printf(&quot;ii的值是：%d\\n&quot;, ii);//空指针int *pi=0; // 定义一个指针*pi=10; // 试图对空指针进行赋值操作，必将引起程序的崩溃//地址的运算char cc[4]; // 字符数组int ii[4]; // 整数数组double dd[4]; // 浮点数组// 用地址相加的方式显示数组全部元素的的址printf(&quot;%p %p %p %p\\n&quot;,cc,cc+1,cc+2,cc+3);printf(&quot;%p %p %p %p\\n&quot;,ii,ii+1,ii+2,ii+3);printf(&quot;%p %p %p %p\\n&quot;,dd,dd+1,dd+2,dd+3);//指针也是一种内存变量，是内存变量就要占用内存空间，在C语言中，任何类型的指针占用8字节的内存（32位操作系统4字节）。printf(&quot;sizeof(int *) is %d.\\n&quot;,sizeof(int *)); // 输出：sizeof(int *) is 8printf(&quot;sizeof(char *) is %d.\\n&quot;,sizeof(char *)); // 输出：sizeof(char *) is 8printf(&quot;sizeof(double *) is %d.\\n&quot;,sizeof(double *)); // 输出：sizeof(double *) is 8 整数在定义整型变量的时候，可以在int关键字之前加signed、unsigned、short和long四种修饰符。 signed：有符号的，可以表示正数和负数。 unsigned：无符号的，只能表示正数，例如数组的下标、人的身高等。 short：短的，现在主流的64位操作系统下，整数占用内存4个字节。 long：长的，更长的整数。 整数的取值范围整数的取值范围与计算机操作系统和C语言编译器有关，没有一个固定的数值，我们可以根据它占用的内存大小来推断它的取值范围。 12345678910111213一个字节有8个位，表示的数据的取值范围是28-1，即255。如果占用的内存是两个字节，无符号型取值范围是2**8ⅹ2**8-1。如果占用的内存是四个字节，无符号型取值范围是2**8ⅹ2**8ⅹ2**8ⅹ2**8-1。如果占用的内存是八个字节，无符号型取值范围是2**8ⅹ2**8ⅹ2**8ⅹ2**8ⅹ2**8ⅹ2**8ⅹ2**8ⅹ2**8-1。如果是有符号，取值范围减半，因为符号占一个位。short si; // 短整数int ii; // 整数long li; // 长整数printf(&quot;sizeof short is %d\\n&quot;,sizeof(short));printf(&quot;sizeof int is %d\\n&quot;,sizeof(int));printf(&quot;sizeof long is %d\\n&quot;,sizeof(long)); 类型简写 类型全称 长度 取值范围 short [signed] short [int] 2字节 -32768~32767 unsigned short unsigned short [int] 2字节 0~65535 int [signed] int 4字节 -2147483648~2147483647 unsigned int unsigned [int] 4字节 0~4294967295 long [signed] long [int] 8字节 -9223372036854775808~9223372036854775807 unsigned long unsigned long [int] 8字节 0~18446744073709551615 注意： 计算机用最高位1位来表达符号（0-正数，1-负数），unsigned修饰过的正整数不需要符号位，在表达正整数的时候比signed修饰的正整数取值大一倍。 在写程序的时候，上表中括号[]的单词可以省略不书写。 在写程序的时候，给整数变量赋值不能超出变量的取值范围，编译的时候会出现类似以下的错误，程序运行也可能产生不可预后的后果。 常用的库函数 1234int atoi(const char *nptr); // 把字符串nptr转换为int整数long atol(const char *nptr); // 把字符串nptr转换为long整数int abs(const int j); // 求int整数的绝对值long labs(const long int j); // 求long整数的绝对值 数据类型的别名 12typedef unsigned int size_t;size_t ii; 等同于 unsigned int ii; 类型转换自动类型转换整型类型级别从低到高依次为： signed char-&gt;unsigned char-&gt;short-&gt;unsigned short-&gt;int-&gt;unsigned int-&gt;long-&gt;unsigned long 浮点型级别从低到高依次为： float-&gt;double 操作数中没有浮点型数据时 当 char、unsigned char、short 或 unsigned short 出现在表达式中参与运算时，一般将其自动转换为 int 类型。int 与 unsigned int混合运算时，int自动转换为unsigned int型。int、unsigned int 与 long 混合运算时，均转换为 long 类型。 操作数中有浮点型数据时 当操作数中含有浮点型数据时，所有操作数都将转换为 double 型。 赋值运算符两侧的类型不一致时 当赋值运算符的右值（可能为常量、变量或表达式）类型与左值类型不一致时，将右值类型提升/降低为左值类型。 右值超出左值类型范围时 赋值运算符右值的范围超出了左值类型的表示范围，将把该右值截断后，赋给左值。所得结果可能毫无意义。 强制类型转换 (目标类型) 表达式; 结构体结构体（struct）来存放一组不同类型的数据。语法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct 结构体名&#123; 结构体成员变量一的声明; 结构体成员变量二的声明; 结构体成员变量三的声明; ...... 结构体成员变量四的声明;&#125;;struct st_girl&#123; char name[51]; // 姓名 int age; // 年龄 int height; // 身高，单位：cm int weight; // 体重，单位：kg char sc[31]; // 身材，火辣；普通；飞机场 char yz[31]; // 颜值，漂亮；一般；歪瓜裂枣&#125;;//结构体是一种程序员自定义的数据类型，是模板，可以用它来定义变量struct st_girl queen, princess, waiting, workers;struct st_girl queen;printf(&quot;sizeof(struct st_girl) %d\\n&quot;,sizeof(struct st_girl));printf(&quot;sizeof(queen) %d\\n&quot;,sizeof(queen)); //C语言提供了结构体成员内存对齐的方法，在定义结构体之前，增加以下代码可以使结构体成员变量之间的内存没有空隙。#pragma pack(1)//和数组不一样，结构体变量名不是结构体变量的地址，结构体变量名就是变量名，就象int ii一样，只是不能直接输出，直接输出没有意义。取地址要用&amp;struct st_girl stgirl;printf(&quot;%d\\n&quot;,stgirl); // 没有意义。printf(&quot;%p\\n&quot;,stgirl); // 没有意义，结构体变量名不是结构体变量的地址。printf(&quot;%p\\n&quot;,&amp;stgirl); // 这才是结构体的地址。//结构体的初始化memset(&amp;queen,0,sizeof(struct st_girl));//或memset(&amp;queen,0,sizeof(queen));//注意事项，如果把一个结构体的地址传给子函数，子函数用一个结构体指针（如struct st_girl *pst）来存放传入的结构体的地址，那么，在子函数中只能用以下方法来初始化结构体memset(pst,0,sizeof(struct st_girl));//结构体指针struct st_girl queen;struct st_girl *pst=&amp;queen; //结构体指针使用成员变量(*pointer).memberNamepointer-&gt;memberName//结构体复制struct st_girl girl1,girl2;strcpy(girl1.name,&quot;西施&quot;); // 对girl1的成员赋值girl1.age=18;memcpy(&amp;girl2,&amp;girl1,sizeof(struct st_girl));//结构体是多个变量集合，作为函数参数时就可以传递整个集合，也就是所有成员。如果结构体成员较多，函数参数的初始化和赋值的内存开销会很大，影响程序的运行效率。所以最好的办法就是传递结构体变量的地址。// 对结构体赋值的函数void setvalue(struct st_girl *pst);struct st_girl queen; // 定义结构体变量 // 初始化结构体变量memset(&amp;queen,0,sizeof(struct st_girl)); 格式化输出1234567int printf(const char *format, ...);int sprintf(char *str, const char *format, ...);int snprintf(char *str, size_t size, const char *format, ...);//printf是把结果输出到屏幕，sprintf把格式化输出的内容保存到字符串str中，snprintf的n类似于strncpy中的n，意思是只获取输出结果的前n-1个字符，不是n个字符。 格式说明符 %[flags][width][.prec]type 类型符type：表示输出数据的类型 %hd、%d、%ld 以十进制、有符号的形式输出 short、int、long 类型的整数。 %hu、%u、%lu 以十进制、无符号的形式输出 short、int、long 类型的整数 %c 输出字符。 %lf 以普通方式输出double（float弃用，long doube无用）。 %e 以科学计数法输出double。 %s 输出字符串。 %p 输出内存的地址。 宽度width：用于控制输出内容的宽度 123printf(&quot;=%12s=\\n&quot;,&quot;abc&quot;); // 输出= abc=printf(&quot;=%12d=\\n&quot;,123); // 输出= 123=printf(&quot;=%12lf=\\n&quot;,123.5); // 输出= 123.500000= 对其标志flags：用于控制输出内容的对齐方式 不填或+：输出的内容右对齐，这是缺省的方式 -：输出的内容左对齐。 12345678printf(&quot;=%-12s=\\n&quot;,&quot;abc&quot;); // 输出=abc =printf(&quot;=%-12d=\\n&quot;,123); // 输出=123 =printf(&quot;=%-12f=\\n&quot;,123.5); // 输出=123.500000 =printf(&quot;=%012s=\\n&quot;,&quot;abc&quot;); // 输出= abc=printf(&quot;=%012d=\\n&quot;,123); // 输出=000000000123=printf(&quot;=%012f=\\n&quot;,123.5); // 输出=00123.500000= 精度prec：如果输出的内容是浮点数，它用于控制输出内容的精度，也就是说小数点后面保留多少位，后面的数四舍五入。 1234printf(&quot;=%12.2lf=\\n&quot;,123.5); // 输出= 123.50=printf(&quot;=%.2lf=\\n&quot;,123.5); // 输出=123.50=printf(&quot;=%12.2e=\\n&quot;,123500000000.0); // 输出= 1.24e+11=printf(&quot;=%.2e=\\n&quot;,123500000000.0); // 输出=1.24e+11= main函数12345678910int main(int argc,char *argv[],char *envp[])//int argc，存放了命令行参数的个数。//char *argv[]，是个字符串的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。//char *envp[]，也是一个字符串的数组，这个数组的每一个元素是指向一个环境变量的字符指针。//envp存放了当前程序运行环境的参数。 动态内存管理1234567void *malloc(unsigned int size)；//malloc的作用是向系统申请一块大小为size的连续内存空间，如果申请失败，函数返回0，如果申请成功，返回成功分配内存块的起始地址。malloc(100)； // 申请 100 个字节的临时分配域，返回值为其第一个字节的地址void free(void *p);//free的作用是释放指针p指向的动态内存空间，p是调用malloc函数时返回的地址，free函数无返回值。 野指针 内存指针变量未初始化 内存释放后之后指针未置空 1234567int *pi=0;int i;int *pi=&amp;i;free(pi);pi=0; 文件操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//操作文件的时候，C语言为文件分配一个信息区，该信息区包含文件描述信息、缓冲区位置、缓冲区大小、文件读写到的位置等基本信息，这些信息用一个结构体来存放（struct _IO_FILE），这个结构体有一个别名FILE（typedef struct _IO_FILE FILE），FILE结构体和对文件操作的库函数在 stdio.h 头文件中声明的。//打开文件的时候，fopen函数中会动态分配一个FILE结构体大小的内存空间，并把FILE结构体内存的地址作为函数的返回值，程序中用FILE结构体指针存放这个地址。//关闭文件的时候，fclose函数除了关闭文件，还会释放FILE结构体占用的内存空间。//FILE结构体指针习惯称为文件指针。FILE *fopen( const char * filename, const char * mode );//参数filename 是字符串，表示需要打开的文件名，可以包含目录名，如果不包含路径就表示程序运行的当前目录。实际开发中，采用文件的全路径。//参数mode也是字符串，表示打开文件的方式（模式），打开方式可以是下列值中的一个。//r 只读 文件必须存在，否则打开失败//w 只写 如果文件存在，则清除原文件内容；如果文件不存在，则新建文件。//a 追加只写 如果文件存在，则打开文件，如果文件不存在，则新建文件。//r+ 读写 文件必须存在。在只读 r 的基础上加 &#x27;+&#x27; 表示增加可写的功能。//w+ 在只写w的方式上增加可读的功能。//a+ 在追加只写a的方式上增加可读的功能。/*注意了，不同教材中对文件打开的方式有不同的说法。有的说打开文本文件的方式要用&quot;rt&quot;、&quot;wt&quot;、&quot;at&quot;、&quot;rt+&quot;、&quot;wt+&quot;、&quot;at+&quot;，&quot;t&quot;是text的简写，&quot;t&quot;可以省略不写。有的说打开二进制文件的方式要用&quot;rb&quot;、&quot;wb&quot;、&quot;ab&quot;、&quot;rb+&quot;、&quot;wb+&quot;、&quot;ab+&quot;，&quot;b&quot;是binary的简写。准确的说，在Linux平台下，打开文本文件和二进制文件的方式没有区别。在windows平台下，如果以“文本”方式打开文件，当读取文件的时候，系统会将所有的&quot;\\r\\n&quot;转换成&quot;\\n&quot;；当写入文件的时候，系统会将&quot;\\n&quot;转换成&quot;\\r\\n&quot;写入， 如果以&quot;二进制&quot;方式打开文件，则读和写都不会进行这样的转换，真是罗嗦。*/int fclose(FILE *fp);int fprintf(FILE *fp, const char *format, ...);char *fgets(char *buf, int size, FILE *fp);/*fgets的功能是从文件中读取一行。参数buf是一个字符串，用于保存从文件中读到的数据。参数size是打算读取内容的长度。参数fp是待读取文件的文件指针。如果文件中将要读取的这一行的内容的长度小于size，fgets函数就读取一行，如果这一行的内容大于等于size，fgets函数就读取size-1字节的内容。调用fgets函数如果成功的读取到内容，函数返回buf，如果读取错误或文件已结束，返回空，即0。如果fgets返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。*/ 二进制文件处理 12345678910111213141516size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);//ptr：为内存区块的指针，存放了要写入的数据的地址，它可以是数组、变量、结构体等。//size：固定填1。//nmemb：表示打算写入数据的字节数。//fp：表示文件指针。//函数的返回值是本次成功写入数据的字节数size_t fread(void *ptr, size_t size, size_t nmemb, FILE *fp);//ptr：用于存放从文件中读取数据的变量地址，它可以是数组、变量、结构体等。//size：固定填1。//nmemb：表示打算读取的数据的字节数。//fp：表示文件指针。//调用fread函数如果成功的读取到内容，函数返回读取到的内容的字节数，如果读取错误或文件已结束，返回空，即0。如果fread返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。 文件定位12345678910111213141516171819202122//ftell函数用来返回当前文件位置指针的值，这个值是当前位置相对于文件开始位置的字节数。long ftell(FILE *fp);//rewind函数用来将位置指针移动到文件开头void rewind ( FILE *fp );//fseek() 用来将位置指针移动到任意位置int fseek ( FILE *fp, long offset, int origin );//fp 为文件指针，也就是被移动的文件。//offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。//origin 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为：0-文件开头；1-当前位置；2-文件末尾。fseek(fp,100,0); // 从文件的开始位置计算，向后移动100字节。fseek(fp,100,1); // 从文件的当前位置计算，向后移动100字节。fseek(fp,-100,2); // 从文件的尾部位置计算，向前移动100字节。/**当offset是向文件尾方向偏移的时候，无论偏移量是否超出文件尾，fseek都是返回0，当偏移量没有超出文件尾的时候，文件指针式指向正常的偏移地址的，当偏移量超出文件尾的时候，文件指针是指向文件尾的，不会返回偏移出错-1值。当offset是向文件头方向偏移的时候，如果offset没有超出文件头，是正常偏移，文件指针指向正确的偏移地址，fseek返回值为0，当offset超出文件头时，fseek返回出错-1值，文件指针还是处于原来的位置。**/ 文件缓冲区在操作系统中，存在一个内存缓冲区，当调用fprintf、fwrite等函数往文件写入数据的时候，数据并不会立即写入磁盘文件，而是先写入缓冲区，等缓冲区的数据满了之后才写入文件。还有一种情况就是程序调用了fclose时也会把缓冲区的数据写入文件。 1int fflush(FILE *fp); 标准输入、标准输出、标准错误Linux操作系统为每个程序默认打开三个文件，即标准输入stdin、标准输出stdout和标准错误输出stderr，其中0就是stdin，表示输入流，指从键盘输入，1代表stdout，2代表stderr，1,2默认是显示器。 目录操作1234567891011121314151617181920212223242526272829303132333435363738//获取当前目录char strpwd[301];memset(strpwd,0,sizeof(strpwd));getcwd(strpwd,300);printf(&quot;当前目录是：%s\\n&quot;,strpwd);//切换工作目录int chdir(const char *path);//目录的创建和删除int mkdir(const char *pathname, mode_t mode);int rmdir(const char *pathname);//获取目录中的文件列表#include &lt;dirent.h&gt;//打开目录DIR *opendir(const char *pathname);//读取目录struct dirent *readdir(DIR *dirp);//关闭目录int closedir(DIR *dirp);//目录指针DIR *目录指针名;//每调用一次readdir函数会返回一个struct dirent的地址，存放了本次读取到的内容，它的原理与fgets函数读取文件相同。struct dirent&#123; long d_ino; // inode number 索引节点号 off_t d_off; // offset to this dirent 在目录文件中的偏移 unsigned short d_reclen; // length of this d_name 文件名长 unsigned char d_type; // the type of d_name 文件类型 char d_name [NAME_MAX+1]; // file name文件名，最长255字符&#125;; 时间操作123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef long time_t;time_t tnow;tnow =time(0); // 将空地址传递给time函数，并将time返回值赋给变量tnowtime(&amp;tnow); // 将变量tnow的地址作为参数传递给time函数struct tm&#123; int tm_sec; // 秒：取值区间为[0,59] int tm_min; // 分：取值区间为[0,59] int tm_hour; // 时：取值区间为[0,23] int tm_mday; // 日期：一个月中的日期：取值区间为[1,31] int tm_mon; // 月份：（从一月开始，0代表一月），取值区间为[0,11] int tm_year; // 年份：其值等于实际年份减去1900 int tm_wday; // 星期：取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 int tm_yday; // 从每年的1月1日开始的天数：取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 int tm_isdst; // 夏令时标识符，该字段意义不大，我们不用夏令时。&#125;;struct tm * localtime(const time_t *);//函数用于把struct tm表示的时间转换为time_t表示的时间time_t mktime(struct tm *tm);//unsigned int sleep(unsigned int seconds);int usleep(useconds_t usec);struct timeval&#123; long tv_sec; // 1970年1月1日到现在的秒。 long tv_usec; // 当前秒的微妙，即百万分之一秒。&#125;;struct timezone&#123; int tz_minuteswest; // 和UTC（格林威治时间）差了多少分钟。 int tz_dsttime; // type of DST correction，修正参数据，忽略&#125;;//gettimeofday是获得当前的秒和微秒的时间，其中的秒是指1970年1月1日到现在的秒，微秒是指当前秒已逝去的微秒数int gettimeofday(struct timeval *tv, struct timezone *tz ) 编译预处理 C源程序－&gt;编译预处理－&gt;编译－&gt;优化程序－&gt;汇编程序－&gt;链接程序－&gt;可执行文件 预处理指令 包含文件：将源文件中以#include格式包含的文件复制到编译的源文件中，可以是头文件，也可以是其它的程序文件。 宏定义指令：#define指令定义一个宏，#undef指令删除一个宏定义。 条件编译：根据#ifdef和#ifndef后面的条件决定需要编译的代码。 12345678910111213141516171819202122232425262728//如果使用尖括号&lt;&gt;括起文件名，则编译程序将到C语言开发环境中设置好的 include文件中去找指定的文件（/usr/include）//#include包含文件，可以是 “.h”,表示C语言程序的头文件，也可以是“.c”,表示包含普通C语言源程序。#include &lt;文件名&gt;#include &quot;文件名&quot;//宏定义#define 宏名 字符串/*define 关键字“define”为宏定义命令。宏名 是一个标示符，必须符合C语言标示符的规定，一般以大写字母标识宏名。字符串 可以是常数，表达式，格式串等。在前面使用的符号常量的定义就是一个无参数宏定义。*/#define PI 3.141592/*宏定义是宏名来表示一个字符串，在宏展开时又以该字符串取代宏名。这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，编译预处理时不会对它进行语法检查，如有错误，只能在编译已被宏展开后的源程序时发现。 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层替换。建议不要这么做，会把程序复杂化。 习惯上宏名用大写字母表示，以方便与变量区别。但也可以用小写字母。*///带参数的宏#define 宏名(形参表) 字符串#define MAX(x,y) ((x)&gt;(y) ? (x) : (y)) 条件编译123456789101112131415#ifdef 标识符 程序段 1#else 程序段 2#endif#ifndef 标识符 程序段 1#else 程序段 2 #endif//取消已定义的标志符#undef 系统错误我们在写程序的时候需要调用C语言提供的库函数，并通过函数的返回值判断调用是否成功。其实在C语言中，还有一个全局变量errno，存放了函数调用过程中产生的错误码。 为防止和正常的返回值混淆，库函数的调用一般并不直接返回错误码，而是将错误码（是一个整数值，不同的值代表不同的含义）存入一个名为 errno 的全局变量中，errno 不同数值所代表的错误消息定义在 &lt;errno.h&gt; 文件中。如果库函数调用失败，可以通过读出 errno 的值来确定问题所在，推测程序出错的原因，这也是调试程序的一个重要方法。 配合 strerror和perror两个库函数，可以很方便地查看出错的详细信息。 strerror 在 &lt;string.h&gt; 中声明，用于获取错误码对应的消息描述。 perror 在 &lt;stdio.h&gt; 中声明，用于在屏幕上最近一次系统错误码消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。 1234char *strerror(int errno);//strerror()用来依参数errno 的错误代码来查询其错误原因的描述字符串，然后将该字符串指针返回。 参考 https://freecplus.net/3e27bfb1a810493d9a0550131e2a1633.html","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://shjlone.github.io/tags/C/"}]},{"title":"数据结构（红黑树）","slug":"数据结构/红黑树","date":"2021-06-07T01:45:07.565Z","updated":"2021-06-07T01:45:07.565Z","comments":true,"path":"wiki/数据结构/红黑树/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/","excerpt":"","text":"定义红黑树是一种自平衡二叉查找树，它可以在 O($\\log(n)$ ) 时间内完成查找、插入和删除，这里的n是树中元素的数目。 红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求： 节点是红色或黑色。 根节点是黑色。 每个叶子节点都是黑色的空节点（NIL节点）。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 操作因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量（O($\\log(n)$)的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为 O ($\\log(n)$)次。 左旋转 逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。下图中身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。 右旋转 顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。下图中身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。 插入应用场景 JDK的集合类TreeMap、TreeSet、HashMap 参考 https://www.cxyxiaowu.com/3173.html https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法 数据结构","slug":"算法-数据结构","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构（线性表）","slug":"数据结构/线性表","date":"2021-06-07T01:45:07.565Z","updated":"2021-06-07T01:45:07.565Z","comments":true,"path":"wiki/数据结构/线性表/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"定义线性表（Linear List）是具有相同特性的数据元素的一个有限序列。该序列中所含元素的个数叫做线性表的长度，用n表示，n&gt;=0。当n=0时，表示线性表是一个空表。设序列中第i个元素为a1（1 ≤ i ≤ n），则线性表的一般表示为： (a1,a2,a3,…,ai,…,an) 特性 元素在位置上是有序的 长度是可变的 线性存储将数据依次存储在连续的整块物理空间中。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。 链式存储数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系。 在线性表的链接存储中，存储的第一个元素的结点称为表头结点，存储最后一个元素的结点称为表尾结点，其余为中间结点。每个链接表都需要设置一个指针指向表头结点，称为表头指针。从表头指针出发，沿着结点的链可以访问到每一个结点。 链接表由于每个结点带有指针域，因而在存储空间上比线性存储要付出较大代价。由于每个结点的存储位置可以任意安排，因此插入、删除操作方便又省时。 单链表 双链表 循环双链表尾结点的下一个结点是头结点。 代码实现","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法 数据结构","slug":"算法-数据结构","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"C++学习笔记","slug":"程序语言/C++/C++学习笔记","date":"2021-06-07T01:45:07.565Z","updated":"2021-06-07T01:45:07.565Z","comments":true,"path":"wiki/程序语言/C++/C++学习笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"函数重载（Function Overloading）定义：函数名相同，函数的参数列表包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。 12345// 解析XML字符串的函数族，支持int、char *和double三种类型。// 返回值：0-成功，-1-失败。int GetXMLBuffer(const char *in_XMLBuffer,const char *in_FieldName,int *out_Value);int GetXMLBuffer(const char *in_XMLBuffer,const char *in_FieldName,char *out_Value);int GetXMLBuffer(const char *in_XMLBuffer,const char *in_FieldName,double *out_Value); C++编译器在编译的时候会根据参数列表的类型对函数进行重命名，比如： 1int GetXMLBuffer_char_char_int(const char *in_XMLBuffer,const char *in_FieldName,int *out_Value); 结构体新特征在C++中，结构体的成员可以有函数。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct st_girl &#123; char name[50]; // 姓名 int age; // 年龄 int height; // 身高，单位：厘米cm char sc[30]; // 身材，火辣；普通；飞机场。 char yz[30]; // 颜值，漂亮；一般；歪瓜裂枣。 int show(); // 声明结构体成员函数show，用于显示其它成员变量的值。&#125;;int main() &#123; st_girl stgirl; // struct关键定可以不书写 memset(&amp;stgirl, 0, sizeof(stgirl)); strcpy(stgirl.name, &quot;西施&quot;); stgirl.age = 22; stgirl.height = 168; strcpy(stgirl.sc, &quot;火辣&quot;); strcpy(stgirl.yz, &quot;漂亮&quot;); stgirl.show(); // 调用结构体的成员函数&#125;int st_girl::show() // 结构体st_girl成员函数的定义&#123; printf(&quot;name=%s,age=%d,height=%d,sc=%s,yz=%s\\n&quot;, name, age, height, sc, yz);&#125; 类详解构造函数 构造函数必须是 public 属性。 构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许。 构造函数可以有参数，允许重载。一个类可以有多个重载的构造函数，创建对象时根据传递的参数来判断调用哪一个构造函数。 构造函数在实际开发中会大量使用，它往往用来做一些初始化工作，对成员变量进行初始化等，注意，不能用memset对整个类进行初始化。 析构函数 析构函数必须是 public 属性的。 析构函数没有参数。 析构函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许。 析构函数不允许重载的。一个类只能有一个析构函数。 1234567891011121314151617181920212223242526272829303132//头文件class CFile&#123;private: FILE *m_fp; // 文件指针 bool m_bEnBuffer; // 是否启用缓冲区，true-启用；false-不启用 public: CFile(); // 类的构造函数 CFile(bool bEnBuffer); // 类的构造函数 ~CFile(); // 类的析构函数 void EnBuffer(bool bEnBuffer=true); // 启、禁用缓冲区 // 打开文件，参数与fopen相同，打开成功true，失败返回false bool Open(const char *filename,const char *openmode); // 调用fprintf向文件写入数据 void Fprintf(const char *fmt, ... ); // 调用fgets从文件中读取一行 bool Fgets(char *strBuffer,const int ReadSize); // 关闭文件指针 void Close();&#125;; 12345678910111213141516171819//实现文件CFile::CFile() // 类的构造函数&#123; m_fp=0; m_bEnBuffer=true;&#125; CFile::CFile(bool bEnBuffer) // 类的构造函数&#123; m_fp=0; m_bEnBuffer=bEnBuffer; &#125;CFile::~CFile() // 类的析构函数&#123; Close(); // 调用Close释放资源&#125; C++引用引用就是变量的别名，对引用的操作与对变量直接操作完全一样。 12345//数据类型 &amp;引用名=目标变量名；int ii;int &amp;rii=ii; // 定义引用rii，它是变量ii的引用，即别名。rii=1; 等价于 ii=1; &amp;在此不是求地址运算，而是声明引用。 数据类型可以是C语言的基本数据类型，也可以是结构体和类等构造类型。 引用在声明的时候必须对其进行初始化（指向目标变量名），否则编译器会报错。 引用初始化之后，不能再用作其他变量名的别名。 引用声明后，相当于目标变量名有两个名称。 不能建立数组的引用，因为数组是多个变量的集合。 引用可以用const修饰，表示只读，用这种方式声明的引用，不能通过引用名对目标变量的值进行修改。 运算符重载123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt; class CGirl // 定义类&#123;public: char m_name[50]; // 姓名 char m_sc[30]; // 身材，火辣；普通；飞机场。 bool operator==(const CGirl &amp;Girl); // 重载==运算符&#125;; int main()&#123; CGirl Girl1,Girl2; strcpy(Girl1.m_name,&quot;西施&quot;); strcpy(Girl2.m_name,&quot;东施&quot;); if (Girl1 == Girl2) printf(&quot;Girl1和Girl2是同一个人。\\n&quot;); else printf(&quot;Girl1和Girl2不是同一个人。\\n&quot;);&#125; bool CGirl::operator==(const CGirl &amp;Girl) // 重载==运算符&#123; // 如果两个类的姓名相同，就相等 if (strcmp(m_name,Girl.m_name)== 0) return true; return false;&#125; string类123456789101112131415#include &lt;string&gt;//string是一个模板类，位于std命名空间内，为方便使用还需要在程序中增加：using namespace std; // 指定缺省的使名空间。string str; // 创建string对象。//如果不指定命名空间std::string str;const char *c_str();//c_str函数返回这个字符串的地址int size(); // 返回当前字符串的大小。int length(); // 返回当前字符串的长度，注意和size的区别。void clear(); // 清空字符串。 vector类12345678910111213141516171819202122232425262728iterator begin()：返回容器头的指针，指向容器第一个元素的位置。iterator end()：返回容器尾的指针，指向容器最后一个元素的下一个位置。void push_back(const T&amp; x)：向容器的尾部增加一个元素x。iterator insert(iterator it,const T&amp; x)：向容器中指定位置（it）前插入一个元素x。iterator erase(iterator it)：删除容器中指定位置（it）的元素。bool empty()：判断容器是否为空。int size()：返回容器中元素的个数。sort(begin,end,cmp);/**sort函数包含在头文件为#include &lt;algorithm&gt;的c++标准库中，调用排序方法不必知道其内部是如何实现的，只要出现我们想要的结果就行。sort函数有三个参数：（1）第一个是要排序的数组的起始地址。（2）第二个是结束的地址。（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时缺省的排序方法是从小到大排序。如果vector容器中元素的数据类型不是基本数据类型，sort函数必须指定排序方法函数。**/ C++动态内存123456789101112datatype *pointer = new datatype; // 其它代码delete pointer;//datatype可以是C语言的基本数据类型，也可以是结构体，还可以是类。//pointer是一个指针，指向new返回的地址。int *pi= new int; // 动态分配一个整数大小的内存(*pi)=10;delete pi; // 释放pi指向的内存 继承和派生123456789101112class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…&#123; // 派生类类体&#125;;class CGirl // 定义超女类&#123;&#125;class CKCon:public CGirl // 定义王妃类，从超女类继承&#123;&#125; 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种方式，当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当类派生以public方式继承时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当类派生以protected方式继承时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当类派生以private方式继承时，基类的公有和保护成员将成为派生类的私有成员。 多态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;string.h&gt;class CGirl // 定义超女类&#123;public: char m_name[50]; // 姓名 int m_age; // 年龄 int m_height; // 身高，单位：厘米cm char m_sc[30]; // 身材，火辣；普通；飞机场。 char m_yz[30]; // 颜值，漂亮；一般；歪瓜裂枣。 int Show() // 显示超女基本信息的成员函数体 &#123; printf(&quot;CGirl 姓名：%s，年龄：%d，身高：%d，身材：%s，颜值：%s\\n&quot;, m_name, m_age, m_height, m_sc, m_yz); &#125;&#125;;class CKCon : public CGirl // 定义王妃类，从超女类继承&#123;public: char m_ch[50]; // 称号 char m_palace[50]; // 居住的宫殿 int m_sal; // 奉禄 int Show() // 显示王妃的称号、宫殿和奉禄 &#123; printf(&quot;CKCon 姓名：%s，称号：%s，栖：%s，奉禄：%d两银子。\\n&quot;, m_name, m_ch, m_palace, m_sal); &#125;&#125;;int main() &#123; CKCon KCon; strcpy(KCon.m_name, &quot;杨玉环&quot;); KCon.m_age = 28; KCon.m_height = 168; strcpy(KCon.m_sc, &quot;火辣&quot;); strcpy(KCon.m_yz, &quot;漂亮&quot;); strcpy(KCon.m_ch, &quot;杨贵妃&quot;); strcpy(KCon.m_palace, &quot;华清宫&quot;); KCon.m_sal = 10000; CGirl *pGirl; // 基类的指针 CKCon *pCon; // 派生类的指针 pGirl = pCon = &amp;KCon; // 都指向派生类 pGirl-&gt;Show(); // 将调用的是基类的Show方法 pCon-&gt;Show(); // 将调用的是派生类的Show方法&#125; 动态多态 动态多态是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。在CGirl类中，Show方法的声明前放置关键字 virtual，则pGirl-&gt;Show()会打印出CKCon中的show方法内容。 虚函数 虚函数是在基类中使用关键字 virtual 声明的函数，在派生类中重新定义虚函数。我们想要的是在程序中可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 纯虚函数 只声明，具体实现在派生类中实现 1234567891011class CGirl // 定义超女类&#123;public: char m_name[50]; // 姓名 int m_age; // 年龄 int m_height; // 身高，单位：厘米cm char m_sc[30]; // 身材，火辣；普通；飞机场。 char m_yz[30]; // 颜值，漂亮；一般；歪瓜裂枣。 virtual int Show()=0; // 申明一个纯虚函数。&#125;;","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://shjlone.github.io/tags/C/"}]},{"title":"数据结构（树）","slug":"数据结构/树","date":"2021-06-07T01:45:07.564Z","updated":"2021-06-07T01:45:07.564Z","comments":true,"path":"wiki/数据结构/树/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/","excerpt":"","text":"定义 树是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 树的术语 节点的度：一个节点含有的子树的个数称为该节点的度； 树的度：一棵树中，最大的节点的度称为树的度； 叶节点或终端节点：度为零的节点； 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 兄弟节点：具有相同父节点的节点互称为兄弟节点； 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 树的高度或深度：树中节点的最大层次； 堂兄弟节点：父节点在同一层的节点互为堂兄弟； 节点的祖先：从根到该节点所经分支上的所有节点； 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。 森林：由m（m ≥ 0）棵互不相交的树的集合称为森林； 树的种类 无序树： 树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树 有序树 树中任意节点的子节点之间有顺序关系，这种树称为有序树 二叉树：每个节点最多含有两个子树的树称为二叉树 完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树; 平衡二叉树：当且仅当任何节点的两棵子树的高度差不大于1的二叉树； 排序二叉树： 霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树； B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。 树的性质 树中的节点数等于所有节点的度数加1。 度为k的树中第i层上至多有ki-1个节点（i ≥ 1）。 深度为h的k叉树至多有个节点 $\\frac{k^{h}-1}{h-1}$ 个节点。 具有n个节点的k叉树的最小深度为 ⌈$\\log_{k} (n(k-1)+1)$⌉ 二叉树 二叉树（Binary Tree）是指树的度为2的有序树。每个节点的左子树的根节点称为左孩子（left child），右子树的根节点称为右孩子（right child）。 性质 二叉树上终端节点数等于双分支节点数加1。 二叉树上第i层至多有2i-1个节点（i ≥ 1）。 深度为h的二叉树至多有2h-1个节点。 对完全二叉树中编号为i的节点（1 ≤ i ≤ n， n ≥ 1，n为节点数 ）有： 若i ≤ ⌊n/2⌋，即2i ≤ n，则编号为i的节点为分支节点，否则为叶子节点。 若n为奇数，则每个分支节点都既有左孩子，又有右孩子；若n为偶数，则编号最大的分支节点（编号为n/2）只有左孩子，没有右孩子，其余分支节点左、右孩子都有。 若编号为i的节点右左孩子，则左孩子节点的编号为2i；若编号为i的节点有右孩子，则右孩子节点的编号为2i+1。 除树根节点外，若一个节点的编号为i，则他的双亲节点的编号为 ⌊i/2⌋，也就是说，当i为偶数时，其双亲节点的编号为i/2，它时双亲节点的左孩子，当i为奇数时，其双亲节点的编号为(i-1)/2，它是双亲节点的右孩子。 具有n个（n &gt; 0）节点的完全二叉树的深度为⌈$\\log_{2} (n+1)$⌉或⌊$\\log_{2} n$⌋+1。 二叉树的存储结构 二叉树的遍历 遍历二叉树的问题可以分为： 访问根节点 遍历左子树 遍历右子树 遍历方式分为：DLR、LDR、LRD、DRL、RDL、RLD。 前序遍历算法 中序遍历算法 后续遍历算法 线索二叉树二叉树的线索化对二叉树进行某种遍历得到的节点序列，可以看做一个线性表，在该线性表中，除第一个节点外，每个节点有且仅有一个前驱，除最后一个节点外，每个节点有且仅有一个后继。为了同节点在二叉树中具有的前驱（即双亲）和后继（即孩子）区别开来，在容易混淆的地方，我们通常把序列中节点的前驱或后继冠以某种遍历的名称，如把中序序列中节点的前驱称做中序前驱，节点的后继称做中序后继。 对于一颗具有n个节点的二叉树，对应的二叉链表中共有2n个指针域，其中n-1个用于指向除树根节点的其余n-1个节点，另有n+1个指针域空着。若把每个节点中空着的左指针域和右指针域用于分别指向某种遍历次序的前驱节点和后继节点，则在遍历这种二叉树时，可由此信息直接找到在该遍历次序下的前驱节点或后继节点，从而比递归遍历提高了遍历速度和节省了建立系统栈所使用的存储空间。这种在节点的空指针域中存放的该节点在某次遍历次序下的前驱节点或后继节点的指针叫做线索，其中在空的左指针域中存放的指向其前驱节点的指针叫做左线索或前驱线索，在空的右指针域中存放的指向其后继节点的指针叫做右线索或后继线索。对一颗二叉树中的所有节点的空指针域按照某种遍历次序加线索的过程叫做线索化，被线索化了的二叉树叫做线索二叉树。 二叉排序树定义二叉排序树（Binary Sort Tree）又称为二叉查找树（Binary Search Tree），它或者是一颗空树，或者是一颗具有如下特征的非空二叉树： 若它的左子树非空，则左子树上所有节点的关键字小于根节点的关键字； 若它的右子树非空，则右子树上所有节点的关键字均大于（若允许具有相同的关键字的节点存在，则大于等于）根节点的关键字； 左、右子树本身又是二叉排序树。 查找和插入当二叉查找树不为空时： 首先将给定值与根节点的关键字比较，若相等，则查找成功 若小于根节点的关键字值，递归查左子树 若大于根节点的关键字值，递归查右子树 若子树为空，查找不成功 二叉排序树是一种动态树表。其特点是：树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的节点时再进行插入。新插入的节点一定是一个新添加的叶子节点，并且是查找不成功时查找路径上访问的最后一个节点的左孩子或右孩子节点。如下图所示： 删除二叉查找树的删除操作分为三种情况： 如果待删除的节点是叶子节点，那么可以立即被删除，如下图所示： 如果节点只有一个儿子，则将此节点parent的指针指向此节点的儿子，然后删除节点，如下图所示： 如果节点有两个儿子，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除，如下图所示： 参考 https://pegasuswang.github.io/python_data_structures_and_algorithms/17_%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/binary_search_tree/ 哈夫曼树（最优二叉树） 路径和路径长度 若在一颗树中存在着一个节点序列k1，k2，….kj，使得kj是kj+1的双亲（1 ≤ i &lt; j），则称此节点序列是从k1～kj的路径，因树中每个节点只有一个双亲节点，所以它也是这两个节点之间的唯一路径。从k1～kj所经过的分支数称为这两点之间的路径长度，它等于路径上的节点数减1。 节点的权和带权路径长度 在许多应用中，常常将树中的节点赋上一个有着某种意义的实数，我们称此实数为该节点的权。节点的带权路径长度规定为从树根节点到该节点之间的路径长度于该节点上权的乘积。 树的带权路径长度 树的带权路径长度定义为树中所有叶子节点的带权路径长度之和，通常记为： $\\sum_{i=1}^n {w_{i}}l_{i}$ 其中n表示叶子节点的数目，wi和li分别表示叶子节点ki的权值和根到ki之间的路径长度。 哈夫曼树 哈夫曼树（Huffman）树又称最优二叉树。它是n个带权叶子节点构成的所有二叉树中，带权路径长度WPL最小的二叉树。 构造哈夫曼树 根据给定的n个权值{w1,w2,…,wn}构成二叉树集合F={T1,T2,…,Tn},其中每棵二叉树Ti中只有一个带权为wi的根节点,其左右子树为空。 在F中选取两棵根节点权值最小的树作为左右子树构造一棵新的二叉树,且置新的二叉树的根节点的权值为左右子树根节点的权值之和。 在F中删除这两棵树,同时将新的二叉树加入F中。 重复2、3,直到F只含有一棵树为止.(得到哈夫曼树)。 平衡二叉树（AVL树）二叉搜索树中，每一个节点的左右子树深度差的绝对值不大于1。 (a）所示为 AVL 树，而（b）所示则不是 AVL 树。 那么，如何判断一棵树是否符合 AVL 树的性质？答案就是维护每个节点的平衡因子。每个节点的平衡因子即为节点左子树的深度减去右子树的深度得到的差。在符合 AVL 性质的情况下，平衡因子只能取 -1、0、1。 正因为这样，在插入或删除一个节点之后，要从插入或删除的位置沿通向根的路径回溯，更新这些经过的节点的平衡因子。在检测到当前节点的平衡因子的绝对值大于1时，停止回溯，根据回溯路径中当前节点以及当前节点深度+1 和深度+2 两层节点的位置，选择旋转方法对二叉树的结构进行调整。 如果一棵平衡二叉树中的节点发生了变化，使二叉树不再平衡，此时需要采用平衡化旋转来调整树的结构，使得在不破坏二叉搜索树性质的情况下，让二叉树重新达到平衡。 平衡化旋转分为两种：单向旋转和双向旋转。如果回溯路径中当前节点以及下两层节点处于一条直线上，就可以采用单向旋转。如果在下两层的节点中，每一个节点都是父亲节点的右孩子，那么如图 3 所示，此时采用单向左旋。 由于此处 A&lt;B&lt;C，所以左旋后并不破坏二叉搜索树的性质，而刚好使得平衡因子恢复到符合 AVL 树性质的大小。 这样的过程同样可以用图来展示。举例来说，在图 4 这样一棵平衡二叉树中插入节点后，整棵树就变得不平衡了。每个节点上方的数字就是该节点的平衡因子，而长方形代表子树，长方形里面的式子等于它的深度。 要想调整二叉树的结构，这里就要用到平衡左旋了。我们取每一棵子树的根节点来代表这一整棵子树，用一共 5 个节点来演示单向左旋的过程。图 5 所示就是单向左旋的效果。 平衡树的结构最后被调整成了图 6 所示这样，而平衡因子也重新变得符合 AVL 树性质了。 同样的道理，如果需要进行平衡旋转时，当前节点的下两层节点都是父节点的左孩子，那么就需要采用单向右旋。单向右旋的道理和单向左旋非常相似，下面就主要用图来演示，不多做讲解了。单向右旋的过程如图 7～图 9 所示。 参考 https://www.cxyxiaowu.com/1663.html","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法 数据结构","slug":"算法-数据结构","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构（稀疏矩阵和广义表）","slug":"数据结构/稀疏矩阵和广义表","date":"2021-06-07T01:45:07.564Z","updated":"2021-06-07T01:45:07.564Z","comments":true,"path":"wiki/数据结构/稀疏矩阵和广义表/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/","excerpt":"","text":"定义矩阵矩阵是一个具有m行 x n列的数表，共包含m x n个数（元素），每个元素处在确定行和列的交点位置上，都与一对行号和列号唯一对应。当一个矩阵中的行数和列数相同时，即m = n时则称为n阶矩阵或方阵。 稀疏矩阵（SparseMatrix）是矩阵中的一种特殊情况，其非零元素的个数小于零元素的个数。 对于稀疏矩阵中的每个非零元素，可用它所在的行号、列号以及元素这三元组（i，j，aij）来表示。若把所有的三元组按照行号为主序（即主关键字）、列号为辅序（次关键字）进行排序，就构成一个表示稀疏矩阵的三元组线性表。 ((1,1,3),(1,4,5),(2,3,-2),(3,1,1),(3,3,4),(3,5,6),(5,3,-1)) 稀疏矩阵的存储结构顺序存储链式存储 带行指针向量的链接存储 在这种链接存储中，需要把具有相同行号的三元组结点按照列号从小到大的顺序链接成一个单链表，每个三元组结点的类型可定义为： 1234567class TripleNode: def __init__(self): self.row = 0 self.col = 0 self.val = None self.next = None # 指向同一行的下一个结点 稀疏矩阵中的每一行对应一个单链表，每一个单链表都有一个表头指针，为了把它们保存起来，便于访问每一个单链表，需要一个行指针向量，该向量中的第i个分量用来存储稀疏矩阵中的第i行所对应的单链表的表头指针。 12345678class LMatrix: def __init__(self): self.m = 0 self.n = 0 self.t = 0 # 非零元素的个数 self.vector = [] 十字链接存储 既带行指针向量又带列指针向量的链接存储。在这种链接存储中，每个三元组结点既处于同一行的单链表中，又处于同一列的单链表中，即处于所在的行单链表和列单链表的交点处。 1234567891011121314151617class CrossNode: def __init__(self): self.row = 0 self.col = 0 self.val = None self.right = None # 存储指向同一行下一个结点的指针 self.down = None # 存储同一列下一个结点的指针class CLMatrix: def __init__(self): self.m = 0 self.n = 0 self.t = 0 self.rv = [] # 行向量指针，存储行单链表的表头指针 self.cv = [] # 列向量指针，存储列单链表的表头指针 广义表(Generalized List)一个广义表是n（n ≥ 0）个元素的一个序列，当n = 0时则称为空表。在一个非空的广义表中，其元素可以是某一确定类型的对象（这种元素被称为单元素），也可以是由单元素构成的表（这种元素可相对的被称为子表或表元素）。显然，广义表的定义是递归的。 设ai为广义表的第i个元素，则广义表的一般表示与线性表相同： (a1,a2,a3,…,ai,…,an) 其中n表示广义表的长度，即广义表中所含元素的个数，n ≥ 0。 深度：表中括号的最大层数 表示方式 用小写字母表示单元素，用大写字母表示表 A = ()A是空表，长度为0，深度为1。 B = (e)B是长度为1的广义表，深度为1。线性表。 C = (a, (b,c,d))C是长度为2的广义表，深度为2。 D = (A, B, C) = ((), (e), (a, (b, c, d)))D是长度为3的广义表，深度为3。A、B、C为子表。 E = ((a, (a,b), ((a,b), c))) 用圆圈和方框分别表示表和单元素，并用线段把表和它的元素连接起来，则可得到一个广义表的图形表示。 抽象数据类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ADT GList&#123;数据对象： D=&#123;ei | i=1,2,...,n; n&gt;0; ei∈AtomSet 或ei∈GList, AtomSet为某个数据对象 &#125;数据关系： R1=&#123;&lt;ei-1,ei&gt; | ei-1,ei∈D, 2&lt;=i&lt;=n&#125;基本操作： InitGList(&amp;L); 操作结果： 创建空的广义表L。 CreateGList(&amp;L, S); 初始条件： S是广义表的书写形式串。 操作结果： 由S创建广义表L。 DestroyGList(&amp;L); 初始条件： 广义表L存在 操作结果： 销毁广义表L。 CopyGList(&amp;T, L); 初始条件： 广义表L存在 操作结果： 由广义表L复制得到广义表T。 GListLength(L); 初始条件： 广义表L存在 操作结果： 求广义表L的长度 GListenDepth(L); 初始条件： 广义表L存在 操作结果： 求广义表L的深度 GListEmpty(L); 初始条件： 广义表L存在 操作结果： 判定广义表L是否为空 GetHead(L); 初始条件： 广义表L存在 操作结果： 取广义表L的头 GetTail(L); 初始条件： 广义表L存在 操作结果： 取广义表L的尾 InsertFirst_GL(&amp;L, e); 初始条件： 广义表L存在 操作结果： 插入元素e作为广义表L的第一元素 DeleteFirst_GL(&amp;L, &amp;e); 初始条件： 广义表L存在 操作结果： 删除广义表L的第一元素，并用e返回其值 Traverse_GL(L, Visit()); 初始条件： 广义表L存在 操作结果： 遍历广义表L，用函数Visit处理每个元素&#125;ADT GList; 存储在一个广义表中，其数据元素有单元素和子表之分，所以在对应的存储结构中，其存储结点也有单元素结点和子表结点之分。对于单元素结点，应包括值域和指向其后继结点的指针域；对于子表结点，应包括指向子表中第一个结点的表头指针域和指向其后继结点的指针域。为了把广义表中的单元素结点和子表结点区别开，还必须在每个结点中增设一个标志域，让标志域取不同的值，从而区别不同的结点。 由于列表中的数据元素可能为原子或列表， 由此需要两种结构的结点： 一种是表结点，用于表示列表；一种是原子结点，用以表示原子。若列表不空，则可分解成表头和表尾；反之，一对确定的表头和表尾可唯一确定列表。由此，一个表结点可由3个域组成： 标志域、指示表头的指针域和指示表尾的指针域； 而原子结点只需两个域： 标志域和值域。 头尾链表存储结构123456789101112131415161718//------ 广义表的头尾链表存储表示 -------typedef enum&#123; ATOM, //ATOM == 0: 原子 LIST //LIST == 1: 子表&#125;ElemTag;typedef GLNode&#123; ElemTag tag; //公共部分，用于区分原子结点和表结点 union&#123; //原子结点和表结点的联合部分 AtomType atom; //atom是原子结点的值域，AtomType由用户定义 struct&#123; struct GLNode *hp; struct GLNode *tp; &#125;ptr; //ptr是表节点的指针域，ptr.hp和ptr.tp分别指向表头和表尾 &#125;&#125;*GList; //广义表类型 扩展线性链表存储结构123456789101112131415161718//------ 广义表的扩展线性链表存储表示 -------typedef enum&#123; ATOM, //ATOM == 0: 原子 LIST //LIST == 1: 子表&#125;ElemTag;typedef GLNode&#123; ElemTag tag; //公共部分，用于区分原子结点和表结点 union&#123; //原子结点和表结点的联合部分 AtomType atom; //atom是原子结点的值域，AtomType由用户定义 struct GLNode *hp; //表结点的表头指针 &#125;; struct GLNode *tp; //相当于线性链表的next，指向下一个元素结点&#125;*GList; 参考 https://www.scipy.org/ SciPy使用多个数据结构为创建稀疏矩阵提供了工具，以及将稠密矩阵转化为稀疏矩阵的工具。 csc_matrix: Compressed Sparse Column format csr_matrix: Compressed Sparse Row format bsr_matrix: Block Sparse Row format lil_matrix: List of Lists format dok_matrix: Dictionary of Keys format coo_matrix: COOrdinate format (aka IJV, triplet format) dia_matrix: DIAgonal format","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法 数据结构","slug":"算法-数据结构","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构（图）","slug":"数据结构/图","date":"2021-06-07T01:45:07.563Z","updated":"2021-06-07T01:45:07.563Z","comments":true,"path":"wiki/数据结构/图/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/","excerpt":"","text":"定义图（Graph）是图形结构的简称。 G = (V, E) V称为顶点集（Vertices set），E称为边集（Edges set）。E的元素是一个二元组数对，用(x,y)表示，其中x,y∈V。 其中V是非空的顶点集合，即V = {Vi|0≤i≤n-1,n≥1, Vi$\\in$VertexType}，其中VertexType表示任何类型，n为顶点数；E是V上二元关系的集合。 V(G1) = {0,1,2,3,4,5,}E(G1) = {(0,1),(0,2),(0,3),(0,4),(1,4),(2,4),(3,5),(4,5)}V(G2) = {0,1,2,3,4}E(G2) = {&lt;0,1&gt;,&lt;0,2&gt;,&lt;1,2&gt;,&lt;1,4&gt;,&lt;2,1&gt;,&lt;2,3&gt;,&lt;4,3&gt;} G1为无向图（undirected graph），图中每个元素为一个无序二元组 (u,v)，称作无向边 (Undirected edge)，简称**边 (Edge)，其中 u,v∈V。设 e=(u,v)，则 u,v 称为 e 的端点 (End-vertex)**。 G2为有向图（directed graph），每一个元素为一个 (有序) 二元组 (u,v)，有时也写作 u→v，称作有向边 (Directed edge) 或弧 (Arc)，在不引起混淆的情况下也可以称作边。设 e=u→v，则此时 u 称为 e 的起点 (Origin)，v 称为 e 的终点 (Terminus)，起点和终点也称为 e 的端点。 对于 V 中的每个元素，我们称其为**顶点 (Vertex)或节点 (Node)**，简称点 (Vertex)，顶点的集合称为点集 (Vertex set)，边的集合称为边集 (Edge set)。 图 G 的点集和边集可以表示为 V(G) 和 E(G)，在不引起混淆的情况下，也能表示成 V,E。图 G 的点数 |V(G)| 也被称作图 G 的阶 (Order)。 基本术语 顶点的度、入度、出度度：顶点v的度（Degree）是和v相关联的边的数目，记为TD(v)。 对于有向图G=(V,{E})，如果弧∈E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v。弧和顶点v，v’相关联。以顶点v为头弧的数目称为v的入度（InDegree），记为ID(v)；以v为尾的弧的数目称为v的出度（OutDegree），记为OD(v)； 顶点v的度为TD(v)=ID(v)+OD(v)。 完全图、稠密图、稀疏图完全图：每个顶点都与其他顶点相邻接的图。 有很少条边或弧（边的条数|E|远小于|V|²）的图称为稀疏图（sparse graph），反之边的条数|E|接近|V|²，称为稠密图（dense graph）。 路径和回路依次遍历顶点序列之间的边所形成的轨迹。下图中依次访问顶点 V0 、V3 和 V2 ，则构成一条路径。 连通和连通分量在无向图 G 中，如果从顶点 v 到顶点 v’ 有路径，则称 v 和 v’ 是连通的。 如果对于图中任意两个顶点 vi 、vj ∈E， vi，和vj都是连通的，则称 G 是连通图，否则图为非连通图。 非连通图： 连通图： 强连通图和强连通分量在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。 网“权”指边上面的信息，一般为数字。 每条边上都带有权的图叫做网。 存储结构12345678910111213141516171819ADT 图(Graph)Data 顶点的有穷非空集合和边的集合。Operation CreateGraph(*G, V, VR): 按照顶点集V和边弧集VR的定义构造图G。 DestroyGraph(*G): 图G存在则销毁。 LocateVex(G, u): 若图G中存在顶点u，则返回图中的位置。 GetVex(G, v): 返回图G中顶点v的值。 PutVex(G, v, value): 将图G中顶点v赋值value。 FirstAdjVex(G, *v): 返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。 NextAdjVex(G, v, *w): 返回顶点v相对于顶点w的下一个邻接顶点， 若w是v的最后一个邻接点则返回“空”。 InsertVex(*G, v): 在图G中增添新顶点v。 DeleteVex(*G, v): 删除图G中顶点v及其相关的弧。 InsertArc(*G, v, w): 在图G中增添弧&lt;v,w&gt;，若G是无向图，还需要增添对称弧&lt;w,v&gt;。 DeleteArc(*G, v, w): 在图G中删除弧&lt;v,w&gt;，若G是无向图，则还删除对称弧&lt;w,v&gt;。 DFSTraverse(G): 对图G中进行深度优先遍历，在遍历过程对每个顶点调用。 HFSTraverse(G): 对图G中进行广度优先遍历，在遍历过程对每个顶点调用。endADT 邻接矩阵（Adjacency Matrix）用两个数组来表示图。一个一维的数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。 对于 n 个点，构造一个 n * n 的矩阵，如果有从点 i 到点 j 的边，就将矩阵的位置 matrix[i][j] 置为 1。 通常会将图 G 中的结点编为1，2，…，|V| （这种编号可以是任意的），然后使用一个 |V| ×|V| 的矩阵 A=(aij) 表示，该矩阵满足以下条件： 可以看出邻接矩阵是在无向图的表示中是转置矩阵，而在有向图中则不是。 对于带权图来说，可以将aij用来存储权值，如果两结点无连接，用0或无穷表示： 无向图邻接矩阵的特征 无向图的邻接矩阵对称且唯一。 有向图的邻接矩阵的第 i 行非零元素个数为第 i 个顶点的出度；第 j 列非零元素个数为第 j 个顶点的入度。 可快速判断两结点间是否有边。 A[i][j] = 1代表顶点i与顶点j邻接，A[i][j] = 0代表顶点i与顶点j不邻接。 顶点与自身之间并未邻接关系，因此边数组的对角线上的元素均为0。 顶点的度即为顶点所在的行或者列1的数目。 有向图邻接矩阵的特征 顶点数组长度为图的顶点数目n。边数组为n X n的二维数组。 边数组中，数组元素为1，即A[i][j] = 1,代表第i个顶点与第j个顶点邻接，且i为尾，j为头。 A[i][j] = 0代表顶点与顶点不邻接。 在有向图中，由于边存在方向性，因此数组不一定为对称数组。 对角线上元素为0。 第i行中，1的数目代表第i个顶点的出度。例如：顶点V1的出度为2，则顶点V1所在行的1的数目为2。 第j列中，1的数目代表第j个顶点的入度。例如：V3的入度为1，则V3所在列中1的数目为1。 邻接表（adjacency list）邻接链表（adjacency list）由图中的每一个结点及其相邻结点生成以该结点为头结点的一组链表。 当处理稀疏图时，相对于邻接矩阵，邻接链表无需一次就分配那么大的空间，而是在遍历图的过程中一点一点地分配，它是一种顺序分配和链式分配相结合的存储结构。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。 虽然邻接链表是一种非常节约空间的结构，但在无向图中用邻接链表表示也会出现数据冗余。这是因为表头结点A所指链表中存在一个指向C的表结点的同时，表头结点C所指链表也会存在一个指向A的表结点。 邻接表存储方法是一种数组存储和链式存储相结合的存储方法。在邻接表中，对图中的每个顶点建立一个单链表，第 i 个单链表中的结点依附于顶点 Vi 的边（对有向图是以顶点Vi为尾的弧）。链表中的节点称为表节点，共有 3个域，具体结构见下图： 表结点由三个域组成，adjvex存储与Vi邻接的点在图中的位置，nextarc存储下一条边或弧的结点，info存储与边或弧相关的信息如权值。 除表结点外，需要在数组中存储头结点，头结点由两个域组成，分别指向链表中第一个顶点和存储Vi的名或其他信息。具体结构如下图： 其中，data域中存储顶点相关信息，firstarc指向链表的第一个节点。 无向图采用邻接表方式存储 采用邻接表方式存储图 6.1 中的无向图，绘图过程中忽略边节点的info信息，头结点中的 data 域存储顶点名称。以V1顶点为例，V1顶点的邻接顶点为V2、V3、V4，则可以创建3个表节点，表节点中adjvex分别存储V2、V3、V4的索引1、2、3，按照此方式，得到的邻接表为： 特征 数组中头节点的数目为图的顶点数目。 链表的长度即为顶点的度。例如：V1顶点的度为3，则以V1为头节点的链表中表节点的数目为3。 有向图采用邻接链表方式存储 采用邻接表方式存储图6.3中的有向图，绘图过程中忽略边节点的info信息，头结点中的data域存储顶点名称。以V1顶点为例，V1顶点的邻接顶点为V2、V3、V4，但是以V1顶点为尾的边只有两条，即和因此，创建2个表节点。表节点中adjvex分别存储V3、V4的索引2、3，按照此方式，得到的邻接表为： 特征 数组中表节点的数目为图的顶点数目。 链表的长度即为顶点的出度。例如V1的出度为2，V1为头节点的链表中，表节点的数目为2。 顶点Vi的入度为邻接表中所有adjvex值域为i的表结点数目。例如：顶点V3的入度为4，则链表中所有adjvex值域为2的表结点数目为4。 逆邻接表在邻接表中，可以轻易的得出顶点的出度，但是想要得到顶点的入度，则需要遍历整个链表。为了便于确定顶点的入度，可以建立有向图的逆邻接表。逆邻接表的建立与邻接表相反。 十字链表对于有向图而言，邻接链表的缺陷是要查询某个顶点的入度时需要遍历整个链表，而逆邻接链表在查询某个顶点的出度时要遍历整个链表。为了解决这些问题，十字链表将邻接链表和逆邻接链表综合了起来，而得到的一种十字链表。在十字链表中，每一条边对应一种边节点，每一个顶点对应为顶点节点。 顶点结点 顶点节点即为头节点，由3个域构成，具体形式如下： 其中，data域存储与顶点相关的信息，firstin和firstout分别指向以此顶点为头或尾的第一个边节点。 边结点 在边节点为链表节点，共有5个域，具体形式如下： 其中，尾域tailvex和头域headvex分别指向尾和头的顶点在图中的位置。链域hlink指向头相同的下一条边，链域tlink指向尾相同的下一条边。info 存储此条边的相关信息。 例如： 采用十字链表的方式存储图的有向图，绘图过程忽略边节点中的info信息，表头节点中的data域存储顶点名称。以V1顶点为例，顶点节点的data域存储V1顶点名，firstin存储以V1顶点为头第一个边节点，以V1顶点为头边为，firstout存储以以V1顶点为尾第一个边节点，对应边为。按照此规则，得到的十字链表存储为： 邻接多重表对于无向图而言，其每条边在邻接链表中都需要两个结点来表示，而邻接多重表正是对其进行优化，让同一条边只用一个结点表示即可。邻接多重表仿照了十字链表的思想，对邻接链表的边表结点进行了改进。 其中，ivex和jvex是指某条边依附的两个顶点在顶点表中的下标。 ilink指向依附顶点ivex的下一条边，jlink指向依附顶点jvex的下一条边。info存储边的相关信息。 重新定义的顶点结构如下图： 其中，data存储顶点的相关信息，firstedge指向第一条依附于该顶点的边。 所示的无向图，采用邻接多重表存储，以 V0 为例，顶点节点的data域存储V0名称，firstedge 指向(V0 , V1)边，边节点中的ilink指向依附V0顶点的下一条边(V0 , V3)，jlink指向依附V1顶点的下一条边(V1 , V2)，按照此方式建立邻接多重表： 关联矩阵邻接矩阵和邻接链表都是用来表示图中各个点和每个点之间的关系，而关联矩阵（incidence matrix）即用一个矩阵来表示各个点和每条边之间的关系。 设无向图 G=(V,E)，其中顶点集 V=v1,v2,⋯,vn, 边集 E=e1,e2,⋯,em，用 aij 表示顶点vi与边ej 关联的次数，可能取值为0, 1, 2, ….，我们称所得矩阵A=A(G)=(aij)n×m为图 G 的关联矩阵。 对于关联矩阵第一行1 1 1 0，表示点v1和各边的关系。如图所示，v1和e1,e2,e3相连，和e4未连，故关联矩阵的值为1 1 1 0. 下面各行为点v2，v3,v4 和各边的关联，以此类推。因此每一行值的总和为该点的度。 对于有向图，若bij=1，表示边j离开点i。 若 bij= -1， 表示边j进入点i。 若 bij = 0，表示边j和点i不相关联。 图的遍历 深度优先搜索遍历（DFS: Depdth First Search）广度优先搜索遍历（BFS: Breadth First Search）非连通图的遍历 图的生成树和最小生成树普里姆算法克鲁斯卡尔算法最短路径 从一顶点到其余顶点的最短路径每对顶点之间的最短路径拓扑排序 关键路径参考 https://www.cxyxiaowu.com/1293.html","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法 数据结构","slug":"算法-数据结构","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构（平衡二叉树AVL）","slug":"数据结构/平衡二叉树AVL","date":"2021-06-07T01:45:07.563Z","updated":"2021-06-07T01:45:07.563Z","comments":true,"path":"wiki/数据结构/平衡二叉树AVL/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL/","excerpt":"","text":"定义平衡二叉树也叫自平衡二叉搜索树（Self-Balancing Binary Search Tree），所以其本质也是一颗二叉搜索树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树（旋转操作）。 最小失衡子树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过1的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。Ï 平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的。根据旋转的方向有两种处理方式，左旋与右旋。 旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。 左旋 节点的右孩子替代此节点位置 右孩子的左子树变为该节点的右子树 节点本身变为右孩子的左子树 右旋 节点的左孩子代表此节点 节点的左孩子的右子树变为节点的左子树 将此节点作为左孩子节点的右子树。 AVL树的四种插入节点方式平衡二叉树插入节点的情况分为以下四种： 插入方式 描述 旋转方式 LL 在 A 的左子树根节点的左子树上插入节点而破坏平衡 右旋转 RR 在 A 的右子树根节点的右子树上插入节点而破坏平衡 左旋转 LR 在A的左子树根节点的右子树上插入节点而破坏平衡 先左旋后右旋 RL 在 A 的右子树根节点的左子树上插入节点而破坏平衡 先右旋后左旋 详细分析删除AVL 树和二叉查找树的删除操作情况一致，都分为四种情况： 删除叶子节点 删除的节点只有左子树 删除的节点只有右子树 删除的节点既有左子树又有右子树 只不过AVL树在删除节点后需要重新检查平衡性并修正，同时，删除操作与插入操作后的平衡修正区别在于，插入操作后只需要对插入栈中的弹出的第一个非平衡节点进行修正，而删除操作需要修正栈中的所有非平衡节点。 删除操作的大致步骤如下： 以前三种情况为基础尝试删除节点，并将访问节点入栈。 如果尝试删除成功，则依次检查栈顶节点的平衡状态，遇到非平衡节点，即进行旋转平衡，直到栈空。 如果尝试删除失败，证明是第四种情况。这时先找到被删除节点的右子树最小节点并删除它，将访问节点继续入栈。 再依次检查栈顶节点的平衡状态和修正直到栈空。 对于删除操作造成的非平衡状态的修正，可以这样理解：对左或者右子树的删除操作相当于对右或者左子树的插入操作，然后再对应上插入的四种情况选择相应的旋转就好了。 详细分析参考 https://blog.csdn.net/jyy305/article/details/70949010 https://zhuanlan.zhihu.com/p/56066942 https://www.cs.usfca.edu/~galles/visualization/AVLtree.html","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法 数据结构","slug":"算法-数据结构","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构（栈和队列）","slug":"数据结构/栈和队列","date":"2021-06-07T01:45:07.563Z","updated":"2021-06-07T01:45:07.564Z","comments":true,"path":"wiki/数据结构/栈和队列/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"","text":"栈栈（Stack），也叫后进先出表（Last In First Out），是一种运算受限的线性表，其限制是仅允许在表的一端进行插入和删除运算。这一端称为栈顶，栈顶的第一个元素被称为栈顶元素，相对的，另一端称为栈底。向一个栈插入新元素称为进栈或入栈，从一个栈删除元素又称为出栈或退栈。 存储结构栈分为顺序栈和链式栈，可以使用数组或链表（单向链表、双向链表或循环链表）作为底层数据结构。 顺序存储链式存储队列队列（Queue），也叫先进先出表（First In First Out）仅允许在表的一端（队尾rear）进行插入，在表的另一端（队首front）进行删除。","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构（B树、B+树）","slug":"数据结构/B树","date":"2021-06-07T01:45:07.562Z","updated":"2021-06-07T01:45:07.563Z","comments":true,"path":"wiki/数据结构/B树/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B%E6%A0%91/","excerpt":"","text":"B树B树也称B-树,它是一颗多路平衡查找树。描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。 一颗m阶的B树定义如下： 每个结点最多包含m个子结点；且M&gt;2 根结点的儿子数为[2, M] 除根结点以外，非叶子结点的子结点数为[M/2, M] 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字） 非叶子结点的关键字个数=指向儿子的指针个数-1； 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]； 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 所有叶子结点位于同一层； 插入插入在叶节点级别完成。要将项目插入B树，需要遵循以下算法。 遍历B树以找到可插入节点的适当叶节点。 如果叶节点包含少于m-1个键，则按递增顺序插入元素。 否则，如果叶节点包含m-1个键，则按照以下步骤操作。 按元素的递增顺序插入新元素。 将节点拆分为中间的两个节点。 将中值元素推送到其父节点。 如果父节点还包含m-1个键，则按照相同的步骤将其拆分。 删除还在叶节点处执行删除。 要删除的节点可以是叶节点或内部节点。 需要遵循以下算法才能从B树中删除节点。 找到叶节点。 如果叶节点中有多于m/2个键，则从节点中删除所需的键。 如果叶节点不包含m/2个键，则通过从8个或左兄弟中获取元素来完成键。 如果左侧兄弟包含多于m/2个元素，则将其最大元素推送到其父元素，并将插入元素向下移动到删除键的节点。 如果右侧兄弟包含多于m/2个元素，则将其最小元素向上推送到父节点，并将插入元素向下移动到删除键的节点。 如果兄弟节点都不包含多于m/2个元素，则通过连接两个叶节点和父节点的插入元素来创建新的叶节点。 如果父节点的节点少于m/2，那么也应在父节点上应用上述过程。 如果要删除的节点是内部节点，则将节点替换为其有序后继或前一个节点。 由于后继或前任将始终位于叶节点上，因此该过程将类似于从叶节点中删除节点。 应用场景 查找磁盘中的大量数据。 数据库中的索引。 参考 https://www.yiibai.com/data_structure/b-tree.html B+树B+树是B树的变体，有着更高的查询性能。 参考 https://www.cnblogs.com/nullzx/p/8729425.html","raw":null,"content":null,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法 数据结构","slug":"算法-数据结构","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"FFMpeg常用命令","slug":"技术开发/杂项/常用ffmpeg命令","date":"2021-06-07T01:45:07.562Z","updated":"2021-06-07T06:12:10.827Z","comments":true,"path":"wiki/技术开发/杂项/常用ffmpeg命令/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%B8%B8%E7%94%A8ffmpeg%E5%91%BD%E4%BB%A4/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#格式转换ffmpeg -i input.avi output.mp4ffmpeg -i input.mp4 output.ts#提取音频ffmpeg -i input.mp4 -acodec copy -vn output.aac#提取视频ffmpeg -i input.mp4 -vcodec copy -an output.mp4#视频剪切 -ss表示开始时间 -t表示长度ffmpeg -ss 00:00:00 -t 00:00:10 -i input.mp4 -vcodec copy -acodec copy output.mp4#码率控制 bitrate=filesize/duration，比如一个文件20.8M，时长1分钟，那么，码率就是：biterate = 20.8M bit/60s = 20.8*1024*1024*8 bit/60s= 2831Kbps一般音频的码率只有固定几种，比如是128Kbps，那么，video的就是：video biterate = 2831Kbps -128Kbps = 2703Kbps。ffmpeg -i input.mp4 -b:v 2000k output.mp4ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4 # 官方建议加上-bufsize，用于设置码率控制缓冲器的大小ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4 # -minrate -maxrate 最小最大范围#视频编码格式转换ffmpeg -i input.mp4 -vcodec h264 output.mp4 #使用h264编码ffmpeg -i input.mp4 -vcodec mpeg4 output.mp4 #使用mpeg4编码#视频大小修改ffmpeg -i input.mp4 -vf scale=960:540 output.mp4 //ps: 如果540不写，写成-1，即scale=960:-1, 那也是可以的，ffmpeg会通知缩放滤镜在输出时保持原始的宽高比#添加水印ffmpeg -i input.mp4 -i logo.png -filter_complex overlay output.mp4ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4 #右上角ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4 #左下角ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4 #右下角#去掉logo有时候，下载了某个网站的视频，但是有logo很烦，咋办？有办法，用ffmpeg的delogo过滤器。语法：-vf delogo=x:y:w:h[:t[:show]]x:y 离左上角的坐标w:h logo的宽和高t: 矩形边缘的厚度默认值4show：若设置为1有一个绿色的矩形，默认值0。ffmpeg -i input.mp4 -vf delogo=0:0:220:90:100:1 output.mp4#从视频中获取指定尺寸的缩略图， -ss参数要在-i参数之前ffmpeg.exe -ss 2672 -i input.mkv -y -f mjpeg -t 0.01 -s 96x54 U:/xiaodao/src/temp/xxx.jpg#将gif转成mp4ffmpeg -f gif -i origin.gif -pix_fmt yuv420p output.mp4#使用基于GDI的抓屏设备ffmpeg -f gdigrab -i desktop out.mpg#从屏幕的（10,20）点处开始，抓取640x480的屏幕，设定帧率为5ffmpeg -f gdigrab -framerate 5 -offset_x 10 -offset_y 20 -video_size 640x480 -i desktop out.mpg#设置帧率ffmpeg -i input.avi -r 29.97 output.mpg#码率 ABR、CBR、VBRffmpeg -i film.avi -b 1.5M film.mp4ffmpeg -i file.avi -b:v 1500k output.mp4设置输出文件最大大小ffmpeg -i input.avi -fs 10MB output.mp4文件大小计算video_size = video_bitrate * time_in_seconds / 8如果音频没有压缩：audio_size = sampling_rate * bit_depth * channels * time_in_seconds / 8压缩音频的文件：audio_size = bitrate * time_in_seconds / 8缩放视频ffmpeg -i input_file -s 320x240 output_file高级缩放 scale=width:height[:interl=&#123;1|-1&#125;]ffmpeg -i input.mpg -vf scale=320:240 output.mp4根据输入来设置缩放大小ffmpeg -i input.mpg -vf scale=iw/2:ih*0.9 裁剪视频 crop=ow[:oh[:x[:y[:keep_aspect]]]]从左上角裁剪，宽度为原始尺寸的一半，高宽跟原始尺寸一样ffmpeg -i input -vf crop=iw/2:ih:0:0 output移动视频 pad=width[:height[:x[:y[:color]]]]ffmpeg -i photo.jpg -vf pad=860:660:30:30:pink framed_photo.jpg将视频比例从4:3转为16:9ffmpeg -i input -vf pad=ih*16/9:ih:(ow-iw)/2:0:color output翻转和旋转视频水平翻转ffplay -f lavfi -i testsrc -vf hflip旋转 transpose=&#123;0, 1, 2, 3&#125;ffplay -f lavfi -i smptebars -vf transpose=2, vflip画中画ffmpeg -i input1 -i input2 -filter_complex overlay=x:y output水印在右下角ffmpeg -i pair.mp4 -i logo.png -filter_complex overlay=W-w:H-h pair1.mp4指定水印开始的时间ffmpeg -i video_width_timer.mp4 -itsoffset 5 -i logo.png -filter_complex overlay timer_width_logo.mp4修改速度ffplay -i input.mpg -vf setpts=PTS/3快放2倍，取值范围0.5-2.0ffplay -i speech.mp3 -af atempo=2创建元数据 -metadata 后面跟键值对ffmpeg -i input -metadata artist=FFmpeg -metadata title=&quot;test&quot; output保存元数据到文件ffmpeg -i video.wmv -f ffmetadata data.txt删除元数据ffmpeg -i input.avi -map_metadata -l output.mp4截图ffmpeg -i videoclip.avi -ss 01:23:45 image.jpg获取gif动画ffmpeg -i promotion.swf -pix_fmt rgb24 promotion.gif根据图片创建视频ffmpeg -loop l -i photo.jpg -t 10 photo.mp4根据多张图片生成视频ffmpeg -f image2 -i img%d.jpg -r 25 video.mp4播放rtmpffplay &quot;rtmp://live.hkstv.hk.lxdns.com/live/hks&quot;保存直播流ffmpeg -i http://60.199.188.151/HLS/WG_ETTV-N/index.m3u8 -c:v copy -c:a copy -bsf:a aac_adtstoasc d:\\cap.mp4从视频中抽离部分生成webpffmpeg -t 3 -ss 00:00:01 -i $&#123;video_path&#125; -vf scale=320:-1 -q:v 50 -r 10 -compression_level 6 -vcodec libwebp -loop 0 $&#123;output_path&#125;从视频中提取关键帧图片ffmpeg -i video_name.mp4 -vf select=&#x27;eq(pict_type\\,I)&#x27; -vsync 2 -s 1920*1080 -f image2 keyframe-%02d.jpeg计算视频的时长ffmpeg -i source.mp4 2&gt;&amp;1 | grep &#x27;Duration&#x27; | cut -d &#x27; &#x27; -f 4 | sed s/,//合并两个视频实用文件的方式：1. 编写filetext.txt文件file ‘a.mp4’file ‘b.mp4’2. 执行命令ffmpeg -f concat -i filelist.txt -c copy output.mp4直接用命令行ffmpeg -i “concat:a.mp4|b.mp4&quot; -c copy output.mp4","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://shjlone.github.io/tags/ffmpeg/"}]},{"title":"按键精灵的使用记录","slug":"技术开发/杂项/按键精灵的使用记录","date":"2021-06-07T01:45:07.562Z","updated":"2021-06-07T01:45:07.562Z","comments":true,"path":"wiki/技术开发/杂项/按键精灵的使用记录/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"最近因为工作需要，研究了下按键精灵和相关生态。按键精灵的主要功能是模拟用户行为，可以导出Android、iOS的包。直接在手机上运行。大致猜测下实现原理： 电脑上通过用户的脚本，转换成相关指令，在电脑上的脚本应该通过adb相关指令来控制模拟器或者手机，到处的apk应该是通过调用系统的相关命令（sendevent等）来实现的。 图片检测像素检测应该是通过opencv相关库来实现的。 脚本的编写也是蹲守基本的编程规则，基本的运算、流程控制、多线程，不过还不够完善。 基本的脚本编写方式也比较傻瓜式，得到具体的坐标，模拟用户点击、输入。哪怕没学过编程的，上手也比较容易。 因为有了这样自动化的工具，再加上大量的需求（用户想刷游戏里的金币、自动完成任务），从而衍生出了许多贩售脚本的。根据这几天的调查，从事这一行的并不少。有依赖按键精灵开发脚本卖钱的，有根据用户需求定制脚本的，还有自己自主开发脚本卖VIP的（如：http://hm.hy6665.cn）。说明这个市场还是蛮大的。 按键精灵的使用按键精灵分为PC版和移动版，移动版在脚本开发完成后，可以导出相应App，在手机和模拟器直接安装即可使用。启动后，会有一个悬浮窗来控制脚本的运行。手机助手还有一个抓抓的功能，可以对模拟器进行截图，截图后可以使用像素点点颜色判断或者图片判断位置。 按键精灵的命令分类： 基本命令 界面命令 悬浮窗命令 扩展命令 标准库命令 运算符命令 插件命令 如何发送语音文件模拟用户按下开始录音，录音过程中替换音频文件使用e2eSoft vsc，将扬声器声音转到麦克风中。当用户按下时，播放提前准备好的音频文件，直接录制改声音。wwww.e2esoft.cn/record-music-with-vsc JSDROID实例 王者荣耀大厅自动喊话和给好友发送语音消息脚本","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"按键精灵","slug":"按键精灵","permalink":"http://shjlone.github.io/tags/%E6%8C%89%E9%94%AE%E7%B2%BE%E7%81%B5/"}]},{"title":"虚拟主机的玩法","slug":"技术开发/杂项/虚拟主机的玩法","date":"2021-06-07T01:45:07.562Z","updated":"2021-06-07T01:45:07.562Z","comments":true,"path":"wiki/技术开发/杂项/虚拟主机的玩法/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%8E%A9%E6%B3%95/","excerpt":"","text":"代理神器Shadowsocks安装 wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 操作 启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 设置密码 查看ss服务器所开放的端口 ss -lntp | grep ssserver 查看ss的配置文件 ps aux | grep ssserver 修改对应的配置文件，重启 云储存工具seafiledocker run -d --name seafile -e SEAFILE_SERVER_HOSTNAME=seafile.example.com -e SEAFILE_ADMIN_EMAIL=xxxj@gmail.com -e SEAFILE_ADMIN_PASSWORD=123456 -v /opt/seafile-data:/shared -p 8088:80 seafileltd/seafile:latest 搭建Maven仓库docker pull sonatype/nexus docker run -d -p 8081:8081 --name nexus -v /home/alone/nexus-data:/nexus-data sonatype/nexus3 /home/alone/nexus-data:/nexus-data表示数据存储目录 搭建FTP服务器修改ssh端口vim /etc/ssh/sshd_config修改Port 2222重启服务/etc/init.d/ssh restart 安装v2ray123456789101112131415161718192021222324252627282930313233343536373839404142卸载v2raysystemctl stop v2raysystemctl disable v2rayservice v2ray stopupdate-rc.d -f v2ray removerm -rf /etc/v2ray/* #(配置文件)rm -rf /usr/bin/v2ray/* #(程序)rm -rf /var/log/v2ray/* #(日志)rm -rf /lib/systemd/system/v2ray.service #(systemd 启动项)rm -rf /etc/init.d/v2ray #(sysv 启动项)wget https://install.direct/go.shsudo bash go.shwget https://git.io/v2ray.sh## 启动systemctl start v2ray## 停止systemctl stop v2ray## 重启systemctl restart v2ray## 开机自启systemctl enable v2ray查看状态service v2ray statuscenter os使用## 查看已开放端口firewall-cmd --zone=public --list-ports## 添加开放端口firewall-cmd --zone=public --add-port=80/tcp --permanent","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://shjlone.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"计算机网络知识总结","slug":"技术开发/杂项/计算机网络知识总结","date":"2021-06-07T01:45:07.562Z","updated":"2021-06-07T01:45:07.562Z","comments":true,"path":"wiki/技术开发/杂项/计算机网络知识总结/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"计算机网络的带宽网络可通用的最高数据率，即每秒多少比特bit。 计算机网络性能指标 速率带宽吞吐量时延（delay或latency）： 传输时延：从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需时间 传播时延：电磁波在信道中需要传播一定的距离而花费的时间 处理时延：交换结点为存储转发而进行一些必要的处理所花费的时间 排队时延：结点缓存队列中分组排队所经历的时延时延带宽积利用率： 信道利用率 网络利用率 数据链路层： 信道主要有以下两种类型： 点对点信道： 广播信道： 各层传输的数据单位：网络层：IP数据报数据链路层：帧物理层：比特 数据链路层传输数据时三个基本问题： 封装成帧 透明传输 差错控制 点对点协议（Point-to-Point Protocol） PPP协议应满足的需求： 简单 封装成帧 透明性 多种网络层协议 多种类型链路 差错检测 检测连接状态 最大传输单元 网络层地址协商 数据压缩协商 PPP协议不需要的功能： 纠错 流量控制 序号 多点线路 半双工或单工链路 PPP协议有三个组成部分 一个将IP数据报封装到串行链路的方法； 链路控制协议LCP 网络控制协议NCP PPP协议之不使用序号和确认机制 网际协议IP IP时TCP/IP体系中两个最主要的协议之一，与IP协议配套使用的还有四个协议：地址解析协议ARP（Address Resolution Protocol）逆地址解析协议RARP（Reverse Address Resolution Protocol）网际控制报文协议ICMP（Internet Control Message Protocol）网际组管理协议IGMP（Internet Group Management Protocol） 网络互相连接起来要使用的一些中间设备物理层中继系统：转发器（repeater）、中继器数据链路层中继系统：网桥或桥接器网络层中继系统：路由器网桥和路由器的混合物：桥路器（brouter）网络层以上的中继系统：网关（gateway） TCP、UDP的区别 TCP三次握手 TCP四次挥手 参考 https://program-think.blogspot.com/2021/03/Computer-Networks-Overview.html","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://shjlone.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"关于建设技术团队的思考","slug":"技术开发/杂项/关于建设技术团队的思考","date":"2021-06-07T01:45:07.561Z","updated":"2021-06-07T01:45:07.561Z","comments":true,"path":"wiki/技术开发/杂项/关于建设技术团队的思考/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/%E5%85%B3%E4%BA%8E%E5%BB%BA%E8%AE%BE%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"一个好的技术领导者真的可以为公司省很多钱，可以保障产品的质量。自己在这条路上还有很多路要走，现将自己的一些感悟记录下来。 一个优秀的团队，首先要有靠谱的成员，至少核心成员要靠谱，要有主见，要想当“将军”，这样他才能带好手下的兵。一个优秀的团队，需要好的规范，无规矩不成方圆，有了规矩，大家都按照规矩来做事，能减少很多不必要的麻烦，不会让成员觉得无所适从。 开发流程需要的工具：文档管理工具团队的产品、设计、技术文档进行整理归档，随着版本不停的迭代，团队成员进进出出若干，如果没有这些文档，会需要很多时间跟新同事交代哪里哪里是干嘛的，哪里哪里需要注意什么。有了这些文档，一方面方便新来的同事，一方面也是对现有技术的沉淀。 文档分为： 公共文档：用来存放团队所有成员都应知晓的事情，比如团队的开发流程，各个岗位的指责，一些规范注意事项等； 产品文档：用来存放产品的版本迭代详细文案，使用说明等； 设计文档：用来存放PS源文件，sketch源文件，sketch导出的html文件，设计规范等； 技术接口文档：存放不同端的API Docs，方便其他端同事查阅，特别是后端接口文档，非常必要； 技术博客，技术上的沉淀能反映出一家公司的技术底蕴； 各种release包的存放，方便以后使用，有时候需要找到很老的版本找不到的时候会很痛苦的。 如何进行管理：目前的做法是将文档统一存放到服务器上，服务器通过配置Nginx指向不同的文件夹，配置不同的域名分别表示各种类型的文档。 项目管理工具 项目整个周期的时间规划； 任务的分派，所有人都应该把自己的任务规划好计划开始、结束时间，实际开始、结束时间； 项目需要一个人来跟踪进度，每天汇总、统计，同步给项目相关的所有人，发现问题及时调整；（这样做的目的是让大家彼此知道大家的进展，督促自己按时完成自己的任务，管理人员也好根据实际情况调配） 自动构建、持续集成工具Jenkins自动构建，比起本地构建，不依赖个人机器的环境，相应有权限的人都可以进行构建。 Bug统计、管理工具友盟等第三方统计 持续部署工具Docker Kubernetes 技术管理OKRs制定目标，目标拆分，制定关键节点，核对结果。 Review Code代码Review，提升代码质量 Unit Test单元测试，减少bug数 技术分享技术沉淀 一些感悟金无足赤、人无完人，想要团队内所有的人都积极主动，把工作当成自己生命中很重要的东西是很困难的。所以才需要管理，需要规则。让大家努力工作的几个核心： 赏罚分明。且要加大力度，如果做的很好，才奖励几百块，出了事故就批评一下；会让大家变的不在乎。所以一定要加大赏罚力度。让大家感觉有奔头，比如如果能完成全年KPI，奖金就能超过基本工资，那大家一定会想尽办法来完成它。如果出现严重的bug，会严厉批评，扣奖金；更严重的会让你直接走人。那么大家就会重视自己的每一行代码了。 比较强势的团队文化。一个好的团队，是需要狼性的，为了目标就应该全力以赴。而不是拖拖拉拉。当然，适当的调整也是有必要的，如果一直在强压力工作下，人也会受不了的。这是相辅相成的。 关于需求变动在日常开发中，需求的变动是很正常的。但因此带来的影响则需要好好分析，而不是一味的来了需求就安排。正常情况下，每个周期的需求定好之后，团队中所有人的工作安排应该都是100%满负荷的。如果在开发过程中，有需求要修改或者新增，则要么版本的周期进行调整，要么大家加班加点把它做完。在这里，我会先评估改动对整个周期造成的影响，如果影响并不大，则会安排人员在周期内进行消化；如果消化不了，也是不建议修改版本周期的。如果因为个别的改动，造成大部分人的影响是不值得的。比如，开发团队30人，新增的需求需要3个人开发3天，如果将周期延后3天，则其他27人是要重新安排工作的。如果经常出现需求变动的时候，就应该思考需求提出者是不是没有把本职工作做好。 按职能还是按业务来分配子团队不同人数的团队 如何进行良好的沟通所有事情有开始有结束。当你把一件事情交代给某一个人时，首先要描述清楚自己想要的结果，然后让对方明确是否明白，再确认最后完成时间。作为收到任务的一方，也应该把自己的理解表达清楚，双方达成一致；最好能在deadline之前就找需求方告知结果，而不是踩着时间线甚至延期告知。 如何带新人对于刚进来的同事，应该准备一份详细的注意事项。比如我们的开发流程是怎样的；有那些账号需要申请，申请流程；常用的工具，工具的使用文档、下载地址；还有许多平常开发中常见的问题。有这样一份文档，新人也不需要一遇到问题就来找你，也节省了你的时间。","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"技术管理","slug":"技术管理","permalink":"http://shjlone.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"}]},{"title":"多线程","slug":"操作系统/线程/多线程","date":"2021-06-07T01:45:07.561Z","updated":"2021-06-07T01:45:07.561Z","comments":true,"path":"wiki/操作系统/线程/多线程/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"线程的概念引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。 线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。 线程的状态 新建状态: 线程对象已经创建，还没有在其上调用start()方法。 可运行状态: 当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。 运行状态: 就绪状态的线程获取了CPU，执行程序代码。 阻塞状态: 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入可运行状态，才有机会转到运行状态。 阻塞的情况分三种： 等待阻塞:运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒. (注意:当调用wait()后，线程会释放掉它所占有的&#39;锁&#39;，所以线程只有在持有&#39;锁&#39;才能进入可运行状态.) 同步阻塞:运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。 其他阻塞:运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态: 线程执行完了或者因异常退出了run()时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 线程的实现方式线程间通讯参考","raw":null,"content":null,"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://shjlone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"线程","slug":"操作系统/线程","permalink":"http://shjlone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://shjlone.github.io/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"PC客户端技术方案分析","slug":"技术开发/杂项/PC客户端技术方案分析","date":"2021-06-07T01:45:07.560Z","updated":"2021-06-07T01:45:07.560Z","comments":true,"path":"wiki/技术开发/杂项/PC客户端技术方案分析/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/PC%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/","excerpt":"","text":"不同PC客户端技术方案的比较Qt官网：https://www.qt.io/ Qt具有跨平台的特性，可选择QWidget、QQuick。整个包比较大。虽然可以根据实际情况去掉一部分动态库和文件，还是比较大。 CEF（Chromium Embedded Framework）官网：https://bitbucket.org/chromiumembedded/cef/src/master/ 是一个基于Google Chromium 的开源项目。Google Chromium项目主要是为Google Chrome应用开发的，而CEF的目标则是为第三方应用提供可嵌入浏览器支持。CEF隔离底层Chromium和Blink的复杂代码，并提供一套产品级稳定的API，发布跟踪具体Chromium版本的分支，以及二进制包。通过封装接口, 然后由chromium回调到自己的程序, 驱动整个程序运行。 个人认为选择CEF的主要原因有以下几点： 基于JS、Html这一套Web技术，开发速度快； 能做出高性能的动画效果 Electron官网：http://www.electronjs.org/ 使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。Electron是在chromium的基础之上, 再嵌入一了个js执行的v8引擎, 由此v8引擎与chromium内部的v8进行信号的交互, 驱动程序运行。 duilib官网：https://github.com/duilib/duilib 开源，小巧灵活，容易扩展，界面与业务逻辑分离。国内有许多大厂都在用这个库，不过应该都进行过深入的定制，官方版本的更新并不频繁，文档跟其他几个比起来差距较大。 教程： https://blog.oo87.com/cpp/6868.html WPF（Windows Presentation Foundation）微软推出的基于Windows Vista的用户界面框架，属于.NET Framework 3.0的一部分。基于Direct3D创建，使用GPU，拥有更好的性能。 UMP（Universal Windows Platform）官方介绍：https://docs.microsoft.com/zh-cn/windows/uwp/get-started/universal-application-platform-guide 在 Windows 10 中，微软首次引入了 UWP（通用 Windows 平台）的概念，让开发者只需一次编写，就能让程序在电脑和手机等多种设备上运行。 PyQt下载地址： https://pypi.org/project/PyQt5/ 基于Qt的Python封装，由于Python的简易特性，开发效率极高。 不同软件的技术实现方案： yy：Qt+CEF 钉钉：CEF+Qt5+duilib 斗鱼：Qt+声网SDK+CrashRpt 虎牙：.Net+Qt4 刀锋电竞：Electron 微信PC端：duilib 网易CC：Qt4+PyQt4+ActionScript(Flex) 参考 https://www.dazhuanlan.com/2019/09/29/5d8f936a633a2/?cf_chl_jschl_tk=ef7184070e28df4b7ee98496aa8b8ff50c47dcd7-1602323919-0-ASFIF35e3NpZNuU7Ndt3pR36r7hlqGch5EsER64Huxe0jFolt_H3NQYXXDmvjWl_m8WVlRnkeLLk1CpX-mLzObrx_mpJIWdumnG8N-g4L7RCf1XxZyM3Ucv6EPDJhAfJSexUlyeoz-AzeC4nE10bcWsW6MyJjhJRQfvo2ABHsoKcu0RLGe4_PIkvL8ox7CchII1vJKWNus0JBvjUiLa0TWyWOGE2WLCwUAwYSEIRE5vqTnW4bMP0C5MTZnjw6sk7Je9gHmAM79oqXilMJdJrVonFl3oItVG8fPn-iwqZbFdBK3iqj7xjlstE8HSgJ7ZEdQ","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"PC","slug":"PC","permalink":"http://shjlone.github.io/tags/PC/"}]},{"title":"ReactiveX","slug":"技术开发/杂项/ReactiveX","date":"2021-06-07T01:45:07.560Z","updated":"2021-06-07T01:45:07.560Z","comments":true,"path":"wiki/技术开发/杂项/ReactiveX/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/ReactiveX/","excerpt":"","text":"Observables概述ReactiveX是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流，Rx库支持大部分主流语言。 使用这种方法的优点是，当你有一大堆的任务是不相互依赖，你就可以同时执行他们，而不是等待每一个类启动下一个前完成，这样你的整个任务包只需要花最长的任务时间。 在ReactiveX中，一个观察者(Observer)订阅一个可观察对象(Observable)。观察者对Observable发射的数据或数据序列作出响应。这种模式可以极大地简化并发操作，因为它创建了一个处于待命状态的观察者哨兵，在未来某个时刻响应Observable的通知，不需要阻塞等待Observable发射数据。 背景知识在很多软件编程任务中，或多或少你都会期望你写的代码能按照编写的顺序，一次一个的顺序执行和完成。但是在ReactiveX中，很多指令可能是并行执行的，之后他们的执行结果才会被观察者捕获，顺序是不确定的。为达到这个目的，你定义一种获取和变换数据的机制，而不是调用一个方法。在这种机制下，存在一个可观察对象(Observable)，观察者(Observer)订阅(Subscribe)它，当数据就绪时，之前定义的机制就会分发数据给一直处于等待状态的观察者哨兵。 这种方法的优点是，如果你有大量的任务要处理，它们互相之间没有依赖关系。你可以同时开始执行它们，不用等待一个完成再开始下一个（用这种方式，你的整个任务队列能耗费的最长时间，不会超过任务里最耗时的那个）。 有很多术语可用于描述这种异步编程和设计模式，在在本文里我们使用这些术语：一个观察者订阅一个可观察对象 (An observer subscribes to an Observable)。通过调用观察者的方法，Observable发射数据或通知给它的观察者。 在其它的文档和场景里，有时我们也将Observer叫做Subscriber、Watcher、Reactor。这个模型通常被称作Reactor模式。 创建观察者关于Observers的创建 同步方式： 调用一个方法 用一个变量存储方法返回值 使用这个变量作为一个新的值做其他事情 例如： 123//写一个回调returnVal = someMethod(paramters);//做新的事情 异步方式： 定义一个方法，此方法是做一些事情并带有来之于异步调用的返回值；这个方法也是observer的一部分 定义异步调用自身作为一个Observable 通过订阅的方式连接observer到Observable 执行你的业务 123def myOnNext = &#123;it-&gt;do something useful with it&#125;;def myObservable = someOvservable(itsParamters);myObservable.subscribe(myOnNext); onNext，onCompleted，onError回调 onNext：每当Observable广播数据时将会调用该方法，这个方法将会被作为Observable的一个广播项目参数被发送 onError：表示内部已经发生异常 onCompleted：成功调用onNext 123456def myOnNext = &#123; item -&gt; /* 任务执行 */ &#125;;def myError = &#123; throwable -&gt; /* 失败时的响应 */ &#125;;def myComplete = &#123; /* 成功后的响应 */ &#125;;def myObservable = someMethod(itsParameters);myObservable.subscribe(myOnNext, myError, myComplete);// 继续执行相应的业务逻辑 取消订阅（Ubsubscribing）在一些ReactiveX实现中，有一个特殊的观察者接口Subscriber，它有一个unsubscribe方法。调用这个方法表示你不关心当前订阅的Observable了，因此Observable可以选择停止发射新的数据项（如果没有其它观察者订阅）。 取消订阅的结果会传递给这个Observable的操作符链，而且会导致这个链条上的每个环节都停止发射数据项。这些并不保证会立即发生，然而，对一个Observable来说，即使没有观察者了，它也可以在一个while循环中继续生成并尝试发射数据项。 关于命名约定ReactiveX的每种特定语言的实现都有自己的命名偏好，虽然不同的实现之间有很多共同点，但并不存在一个统一的命名标准。 而且，在某些场景中，一些名字有不同的隐含意义，或者在某些语言看来比较怪异。 例如，有一个onEvent命名模式(onNext, onCompleted, onError)，在一些场景中，这些名字可能意味着事件处理器已经注册。然而在ReactiveX里，他们是事件处理器的名字。 Observables的”热”和”冷”Observable什么时候开始发射数据序列？这取决于Observable的实现，一个”热”的Observable可能一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了）。一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列。 在一些ReactiveX实现里，还存在一种被称作Connectable的Observable，不管有没有观察者订阅它，这种Observable都不会开始发射数据，除非Connect方法被调用。 用操作符组合Ovservable创建新的Observables的操作符： Create Defer Empty/Never/Throw From Interval Just Range Repeat Start Timer 转换被一个Observable发送的项目的操作付 Buffer FlatMap GroupBy Map Scan Window 过滤被Observable发送的项目的操作符 Debounce Distinct ElementAt Filter First IgnoreElements Last Sample Skip SkipLast Take TakeLast 将多个Observable合并成单个Observable的操作符 And/Then/When CombineLatest Join Merge StartWith Switch Zip 错误处理操作符 Catch Retry 实用工具操作符 Delay Do Materialize/Dematerialize ObserveOn Serialize Subscribe SubscribeOn TimeInterval Timeout Timestamp Using 条件和布尔运算操作符 All Amb Contains DefaultIfEmpty SequenceEqual SkipUntil SkipWhile TakeUntil TakeWhile 算术和集合操作符 Average Concat Count Max Min Reduce Sum 转换操作符 To 可连接Obervable的操作符 Connect Publish RefCount Replay SingleRxJava（以及它派生出来的RxGroovy和RxScala）中有一个名为Single的Observable变种。 Single类似于Observable，不同的是，它总是只发射一个值，或者一个错误通知，而不是发射一系列的值。 因此，不同于Observable需要三个方法onNext, onError, onCompleted，订阅Single只需要两个方法： onSuccess - Single发射单个的值到这个方法 onError - 如果无法发射需要的值，Single发射一个Throwable对象到这个方法 Single只会调用这两个方法中的一个，而且只会调用一次，调用了任何一个方法之后，订阅关系终止。 Single操作符 操作符 返回值 说明 compose Single 创建一个自定义的操作符 concat and concatWith Observable 连接多个Single和Observable发射的数据 create Single 调用观察者的create方法创建一个Single error Single 返回一个立即给订阅者发射错误通知的Single flatMap Single 返回一个Single，它发射对原Single的数据执行flatMap操作后的结果 flatMapObservable Observable 返回一个Observable，它发射对原Single的数据执行flatMap操作后的结果 from Single 将Future转换成Single just Single 返回一个发射一个指定值的Single map Single 返回一个Single，它发射对原Single的数据执行map操作后的结果 merge Single 将一个Single(它发射的数据是另一个Single，假设为B)转换成另一个Single(它发射来自另一个Single(B)的数据) merge and mergeWith Observable 合并发射来自多个Single的数据 observeOn Single 指示Single在指定的调度程序上调用订阅者的方法 onErrorReturn Single 将一个发射错误通知的Single转换成一个发射指定数据项的Single subscribeOn Single 指示Single在指定的调度程序上执行操作 timeout Single 它给原有的Single添加超时控制，如果超时了就发射一个错误通知 toSingle Single 将一个发射单个值的Observable转换为一个Single zip and zipWith Single 将多个Single转换为一个，后者发射的数据是对前者应用一个函数后的结果 SubjectSubject可以看成是一个桥梁或者代理，在某些ReactiveX实现中（如RxJava），它同时充当了Observer和Observable的角色。因为它是一个Observer，它可以订阅一个或多个Observable；又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。 由于一个Subject订阅一个Observable，它可以触发这个Observable开始发射数据（如果那个Observable是”冷”的–就是说，它等待有订阅才开始发射数据）。因此有这样的效果，Subject可以把原来那个”冷”的Observable变成”热”的。 Subject种类AsyncSubjectBehaviorSubjectPublishSubjectReplaySubjectScheduler如果你想给Observable操作符链添加多线程功能，你可以指定操作符（或者特定的Observable）在特定的调度器(Scheduler)上执行。 某些ReactiveX的Observable操作符有一些变体，它们可以接受一个Scheduler参数。这个参数指定操作符将它们的部分或全部任务放在一个特定的调度器上执行。 默认情况下，可观察对象和观察者的订阅方法是在同一个线程中运行的。使用ObserveOn和SubscribeOn操作符，你可以让Observable在一个特定的调度器上执行，ObserveOn指示一个Observable在一个特定的调度器上调用观察者的onNext, onError和onCompleted方法，SubscribeOn更进一步，它指示Observable将全部的处理过程（包括发射数据和通知）放在特定的调度器上执行。 RxJava示例调度器的种类下表展示了RxJava中可用的调度器种类： 调度器类型 效果 Schedulers.computation( ) 用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量 Schedulers.from(executor) 使用指定的Executor作为调度器 Schedulers.immediate( ) 在当前线程立即开始执行任务 Schedulers.io( ) 用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器 Schedulers.newThread( ) 为每个任务创建一个新线程 Schedulers.trampoline( ) 当其它排队的任务完成后，在当前线程排队开始执行 默认调度器在RxJava中，某些Observable操作符的变体允许你设置用于操作执行的调度器，其它的则不在任何特定的调度器上执行，或者在一个指定的默认调度器上执行。下面的表格个列出了一些操作符的默认调度器： 操作符 调度器 buffer(timespan) computation buffer(timespan, count) computation buffer(timespan, timeshift) computation debounce(timeout, unit) computation delay(delay, unit) computation delaySubscription(delay, unit) computation interval computation repeat trampoline replay(time, unit) computation replay(buffersize, time, unit) computation replay(selector, time, unit) computation replay(selector, buffersize, time, unit) computation retry trampoline sample(period, unit) computation skip(time, unit) computation skipLast(time, unit) computation take(time, unit) computation takeLast(time, unit) computation takeLast(count, time, unit) computation takeLastBuffer(time, unit) computation takeLastBuffer(count, time, unit) computation throttleFirst computation throttleLast computation throttleWithTimeout computation timeInterval immediate timeout(timeoutSelector) immediate timeout(firstTimeoutSelector, timeoutSelector) immediate timeout(timeoutSelector, other) immediate timeout(timeout, timeUnit) computation timeout(firstTimeoutSelector, timeoutSelector, other) immediate timeout(timeout, timeUnit, other) computation timer computation timestamp immediate window(timespan) computation window(timespan, count) computation window(timespan, timeshift) computation 使用调度器除了将这些调度器传递给RxJava的Observable操作符，你也可以用它们调度你自己的任务。下面的示例展示了Scheduler.Worker的用法： 1234567891011worker = Schedulers.newThread().createWorker();worker.schedule(new Action0() &#123; @Override public void call() &#123; yourWork(); &#125;&#125;);// some time later...worker.unsubscribe(); 递归调度器要调度递归的方法调用，你可以使用schedule，然后再用schedule(this)，示例： 12345678910111213worker = Schedulers.newThread().createWorker();worker.schedule(new Action0() &#123; @Override public void call() &#123; yourWork(); // recurse until unsubscribed (schedule will do nothing if unsubscribed) worker.schedule(this); &#125;&#125;);// some time later...worker.unsubscribe(); 检查或设置取消订阅状态Worker类的对象实现了Subscription接口，使用它的isUnsubscribed和unsubscribe方法，所以你可以在订阅取消时停止任务，或者从正在调度的任务内部取消订阅，示例： 123456789101112Worker worker = Schedulers.newThread().createWorker();Subscription mySubscription = worker.schedule(new Action0() &#123; @Override public void call() &#123; while(!worker.isUnsubscribed()) &#123; status = yourWork(); if(QUIT == status) &#123; worker.unsubscribe(); &#125; &#125; &#125;&#125;); 延时和周期调度器你可以使用schedule(action,delayTime,timeUnit)在指定的调度器上延时执行你的任务，下面例子中的任务将在500毫秒之后开始执行： 1someScheduler.schedule(someAction, 500, TimeUnit.MILLISECONDS); 使用另一个版本的schedule，schedulePeriodically(action,initialDelay,period,timeUnit)方法让你可以安排一个定期执行的任务，下面例子的任务将在500毫秒之后执行，然后每250毫秒执行一次： 1someScheduler.schedulePeriodically(someAction, 500, 250, TimeUnit.MILLISECONDS); 测试调度器TestScheduler让你可以对调度器的时钟表现进行手动微调。这对依赖精确时间安排的任务的测试很有用处。这个调度器有三个额外的方法： advanceTimeTo(time,unit) 向前波动调度器的时钟到一个指定的时间点 advanceTimeBy(time,unit) 将调度器的时钟向前拨动一个指定的时间段 triggerActions( ) 开始执行任何计划中的但是未启动的任务，如果它们的计划时间等于或者早于调度器时钟的当前时间 Operators创建操作 just( ) — 将一个或多个对象转换成发射这个或这些对象的一个Observable from( ) — 将一个Iterable, 一个Future, 或者一个数组转换成一个Observable repeat( ) — 创建一个重复发射指定数据或数据序列的Observable repeatWhen( ) — 创建一个重复发射指定数据或数据序列的Observable，它依赖于另一个Observable发射的数据 create( ) — 使用一个函数从头创建一个Observable defer( ) — 只有当订阅者订阅才创建Observable；为每个订阅创建一个新的Observable range( ) — 创建一个发射指定范围的整数序列的Observable interval( ) — 创建一个按照给定的时间间隔发射整数序列的Observable timer( ) — 创建一个在给定的延时之后发射单个数据的Observable empty( ) — 创建一个什么都不做直接通知完成的Observable error( ) — 创建一个什么都不做直接通知错误的Observable never( ) — 创建一个不发射任何数据的Observable 变换操作 map( ) — 对序列的每一项都应用一个函数来变换Observable发射的数据序列 flatMap( ), concatMap( ), and flatMapIterable( ) — 将Observable发射的数据集合变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable switchMap( ) — 将Observable发射的数据集合变换为Observables集合，然后只发射这些Observables最近发射的数据 scan( ) — 对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值 groupBy( ) — 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据 buffer( ) — 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个 window( ) — 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项 cast( ) — 在发射之前强制将Observable发射的所有数据转换为指定类型 过滤操作 filter( ) — 过滤数据 takeLast( ) — 只发射最后的N项数据 last( ) — 只发射最后的一项数据 lastOrDefault( ) — 只发射最后的一项数据，如果Observable为空就发射默认值 takeLastBuffer( ) — 将最后的N项数据当做单个数据发射 skip( ) — 跳过开始的N项数据 skipLast( ) — 跳过最后的N项数据 take( ) — 只发射开始的N项数据 first( ) and takeFirst( ) — 只发射第一项数据，或者满足某种条件的第一项数据 firstOrDefault( ) — 只发射第一项数据，如果Observable为空就发射默认值 elementAt( ) — 发射第N项数据 elementAtOrDefault( ) — 发射第N项数据，如果Observable数据少于N项就发射默认值 sample( ) or throttleLast( ) — 定期发射Observable最近的数据 throttleFirst( ) — 定期发射Observable发射的第一项数据 throttleWithTimeout( ) or debounce( ) — 只有当Observable在指定的时间后还没有发射数据时，才发射一个数据 timeout( ) — 如果在一个指定的时间段后还没发射数据，就发射一个异常 distinct( ) — 过滤掉重复数据 distinctUntilChanged( ) — 过滤掉连续重复的数据 ofType( ) — 只发射指定类型的数据 ignoreElements( ) — 丢弃所有的正常数据，只发射错误或完成通知 结合操作 startWith( ) — 在数据序列的开头增加一项数据 merge( ) — 将多个Observable合并为一个 mergeDelayError( ) — 合并多个Observables，让没有错误的Observable都完成后再发射错误通知 zip( ) — 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果 and( ), then( ), and when( ) — (rxjava-joins) 通过模式和计划组合多个Observables发射的数据集合 combineLatest( ) — 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果 join( ) and groupJoin( ) — 无论何时，如果一个Observable发射了一个数据项，只要在另一个Observable发射的数据项定义的时间窗口内，就将两个Observable发射的数据合并发射 switchOnNext( ) — 将一个发射Observables的Observable转换成另一个Observable，后者发射这些Observables最近发射的数据 错误操作很多操作符可用于对Observable发射的onError通知做出响应或者从错误中恢复，例如，你可以： 吞掉这个错误，切换到一个备用的Observable继续发射数据 吞掉这个错误然后发射默认值 吞掉这个错误并立即尝试重启这个Observable 吞掉这个错误，在一些回退间隔后重启这个Observable 这是操作符列表： onErrorResumeNext( ) — 指示Observable在遇到错误时发射一个数据序列 onErrorReturn( ) — 指示Observable在遇到错误时发射一个特定的数据 onExceptionResumeNext( ) — instructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)指示Observable遇到错误时继续发射数据 retry( ) — 指示Observable遇到错误时重试 retryWhen( ) — 指示Observable遇到错误时，将错误传递给另一个Observable来决定是否要重新给订阅这个Observable 辅助操作 materialize( ) — 将Observable转换成一个通知列表convert an Observable into a list of Notifications dematerialize( ) — 将上面的结果逆转回一个Observable timestamp( ) — 给Observable发射的每个数据项添加一个时间戳 serialize( ) — 强制Observable按次序发射数据并且要求功能是完好的 cache( ) — 记住Observable发射的数据序列并发射相同的数据序列给后续的订阅者 observeOn( ) — 指定观察者观察Observable的调度器 subscribeOn( ) — 指定Observable执行任务的调度器 doOnEach( ) — 注册一个动作，对Observable发射的每个数据项使用 doOnCompleted( ) — 注册一个动作，对正常完成的Observable使用 doOnError( ) — 注册一个动作，对发生错误的Observable使用 doOnTerminate( ) — 注册一个动作，对完成的Observable使用，无论是否发生错误 doOnSubscribe( ) — 注册一个动作，在观察者订阅时使用 doOnUnsubscribe( ) — 注册一个动作，在观察者取消订阅时使用 finallyDo( ) — 注册一个动作，在Observable完成时使用 delay( ) — 延时发射Observable的结果 delaySubscription( ) — 延时处理订阅请求 timeInterval( ) — 定期发射数据 using( ) — 创建一个只在Observable生命周期存在的资源 single( ) — 强制返回单个数据，否则抛出异常 singleOrDefault( ) — 如果Observable完成时返回了单个数据，就返回它，否则返回默认数据 toFuture( ), toIterable( ), toList( ) — 将Observable转换为其它对象或数据结构 条件和布尔操作条件操作符 amb( ) — 给定多个Observable，只让第一个发射数据的Observable发射全部数据 defaultIfEmpty( ) — 发射来自原始Observable的数据，如果原始Observable没有发射数据，就发射一个默认数据 (rxjava-computation-expressions) doWhile( ) — 发射原始Observable的数据序列，然后重复发射这个序列直到不满足这个条件为止 (rxjava-computation-expressions) ifThen( ) — 只有当某个条件为真时才发射原始Observable的数据序列，否则发射一个空的或默认的序列 skipUntil( ) — 丢弃原始Observable发射的数据，直到第二个Observable发射了一个数据，然后发射原始Observable的剩余数据 skipWhile( ) — 丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始Observable剩余的数据 (rxjava-computation-expressions) switchCase( ) — 基于一个计算结果，发射一个指定Observable的数据序列 takeUntil( ) — 发射来自原始Observable的数据，直到第二个Observable发射了一个数据或一个通知 takeWhile( ) and takeWhileWithIndex( ) — 发射原始Observable的数据，直到一个特定的条件为真，然后跳过剩余的数据 布尔操作符 all( ) — 判断是否所有的数据项都满足某个条件 contains( ) — 判断Observable是否会发射一个指定的值 exists( ) and isEmpty( ) — 判断Observable是否发射了一个值 sequenceEqual( ) — 判断两个Observables发射的序列是否相等 算数和聚合操作rxjava-math 模块的操作符 averageInteger( ) — 求序列平均数并发射 averageLong( ) — 求序列平均数并发射 averageFloat( ) — 求序列平均数并发射 averageDouble( ) — 求序列平均数并发射 max( ) — 求序列最大值并发射 maxBy( ) — 求最大key对应的值并发射 min( ) — 求最小值并发射 minBy( ) — 求最小Key对应的值并发射 sumInteger( ) — 求和并发射 sumLong( ) — 求和并发射 sumFloat( ) — 求和并发射 sumDouble( ) — 求和并发射 其它聚合操作符 concat( ) — 顺序连接多个Observables count( ) and countLong( ) — 计算数据项的个数并发射结果 reduce( ) — 对序列使用reduce()函数并发射最终的结果 collect( ) — 将原始Observable发射的数据放到一个单一的可变的数据结构中，然后返回一个发射这个数据结构的Observable toList( ) — 收集原始Observable发射的所有数据到一个列表，然后返回这个列表 toSortedList( ) — 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表 toMap( ) — 将序列数据转换为一个Map，Map的key是根据一个函数计算的 toMultiMap( ) — 将序列数据转换为一个列表，同时也是一个Map，Map的key是根据一个函数计算的 异步操作下面的这些操作符属于单独的rxjava-async模块，它们用于将同步对象转换为Observable。 start( ) — 创建一个Observable，它发射一个函数的返回值 toAsync( ) or asyncAction( ) or asyncFunc( ) — 将一个函数或者Action转换为已Observable，它执行这个函数并发射函数的返回值 startFuture( ) — 将一个返回Future的函数转换为一个Observable，它发射Future的返回值 deferFuture( ) — 将一个返回Observable的Future转换为一个Observable，但是并不尝试获取这个Future返回的Observable，直到有订阅者订阅它 forEachFuture( ) — 传递Subscriber方法给一个Subscriber，但是同时表现得像一个Future一样阻塞直到它完成 fromAction( ) — 将一个Action转换为Observable，当一个订阅者订阅时，它执行这个action并发射它的返回值 fromCallable( ) — 将一个Callable转换为Observable，当一个订阅者订阅时，它执行这个Callable并发射Callable的返回值，或者发射异常 fromRunnable( ) — convert a Runnable into an Observable that invokes the runable and emits its result when a Subscriber subscribes将一个Runnable转换为Observable，当一个订阅者订阅时，它执行这个Runnable并发射Runnable的返回值 runAsync( ) — 返回一个StoppableObservable，它发射某个Scheduler上指定的Action生成的多个actions 连接操作 ConnectableObservable.connect( ) — 指示一个可连接的Observable开始发射数据 Observable.publish( ) — 将一个Observable转换为一个可连接的Observable Observable.replay( ) — 确保所有的订阅者看到相同的数据序列，即使它们在Observable开始发射数据之后才订阅 ConnectableObservable.refCount( ) — 让一个可连接的Observable表现得像一个普通的Observable 转换操作阻塞操作要将普通的Observable 转换为 BlockingObservable，可以使用 Observable.toBlocking( )) 方法或者BlockingObservable.from( )) 方法。 forEach( ) — 对Observable发射的每一项数据调用一个方法，会阻塞直到Observable完成 first( ) — 阻塞直到Observable发射了一个数据，然后返回第一项数据 firstOrDefault( ) — 阻塞直到Observable发射了一个数据或者终止，返回第一项数据，或者返回默认值 last( ) — 阻塞直到Observable终止，然后返回最后一项数据 lastOrDefault( ) — 阻塞直到Observable终止，然后返回最后一项的数据，或者返回默认值 mostRecent( ) — 返回一个总是返回Observable最近发射的数据的iterable next( ) — 返回一个Iterable，会阻塞直到Observable发射了另一个值，然后返回那个值 latest( ) — 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值 single( ) — 如果Observable终止时只发射了一个值，返回那个值，否则抛出异常 singleOrDefault( ) — 如果Observable终止时只发射了一个值，返回那个值，否则否好默认值 toFuture( ) — 将Observable转换为一个Future toIterable( ) — 将一个发射数据序列的Observable转换为一个Iterable getIterator( ) — 将一个发射数据序列的Observable转换为一个Iterator 字符串操作 byLine( ) — 将一个字符串的Observable转换为一个行序列的Observable，这个Observable将原来的序列当做流处理，然后按换行符分割 decode( ) — 将一个多字节的字符流转换为一个Observable，它按字符边界发射字节数组 encode( ) — 对一个发射字符串的Observable执行变换操作，变换后的Observable发射一个在原始字符串中表示多字节字符边界的字节数组 from( ) — 将一个字符流或者Reader转换为一个发射字节数组或者字符串的Observable join( ) — 将一个发射字符串序列的Observable转换为一个发射单个字符串的Observable，后者用一个指定的字符串连接所有的字符串 split( ) — 将一个发射字符串的Observable转换为另一个发射字符串的Observable，后者使用一个指定的正则表达式边界分割前者发射的所有字符串 stringConcat( ) — 将一个发射字符串序列的Observable转换为一个发射单个字符串的Observable，后者连接前者发射的所有字符串 参考 reactivex.io https://github.com/ReactiveX https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Getting-Started.html","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"Rx","slug":"Rx","permalink":"http://shjlone.github.io/tags/Rx/"}]},{"title":"Redis笔记","slug":"技术开发/服务端/redis笔记","date":"2021-06-07T01:45:07.559Z","updated":"2021-06-07T01:45:07.559Z","comments":true,"path":"wiki/技术开发/服务端/redis笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/redis%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"Docker笔记","slug":"技术开发/杂项/Docker笔记","date":"2021-06-07T01:45:07.559Z","updated":"2021-06-07T01:45:07.559Z","comments":true,"path":"wiki/技术开发/杂项/Docker笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Docker%E7%AC%94%E8%AE%B0/","excerpt":"","text":"容器生态系统： 容器核心技术： 容器规范： OCI（Open Container Initiative）： runtime spec image format spec 容器runtime： lxc：Linux上老牌的容器runtime，Docker最初也是用lxc作为runtime runc：Docker自己开发的容器runtime，符合oci规范，也是现在Docker默认的runtime rkt：CoreOS开发的容器runtime 容器管理工具： lxd：lxc对应的管理工具 runc：docker engine，包含后台deamon和cli两部分。 rkt cli：rkt对应的管理工具 容器定义工具：允许用户定义容器的内容和属性，这样容器就能够被保存、共享和重建 docker image：Docker容器的模板，runtime依据docker image创建容器。 dockerfile：包含若干命令的文本文件，可以通过这些命令创建出docker image。 ACI(App Container Image)：CoreOS开发的rkt容器的image格式。 Registries：存放image的仓库 Docker Registry：企业可以用Docker Registry构建私有的Registry Docker Hub：Docker为公众提供的托管Registry Quay.io 容器OS：专门运行容器的操作系统，与常规OS相比，容器OS体积更小，启动更快。 coreos atomic ubuntu core 容器平台技术： 容器编排引擎： docker swarm：Docker开发的容器编排引擎。 kubernetes：Google领导开发的，同时支持Docker和CoreOS容器。 mesos+marathon：通用的集群资源调度平台，mesos与marathon一起提供容器编排引擎。 容器管理平台：在容器编排引擎之上的一个更为通用的平台。 Rancher ContainerShip 基于容器的Paas： Deis Flynn Dokku 容器支持技术： 容器网络： docker network: none host bridge joined container overlay macvian flannel weave calico 服务发现： etcd consul zookeeper 监控： docker ps/top/stats：Docker原生命令行监控工具 docker stats API sysdig cAvisor/Heapster Weave Scope 数据管理： Rex-Ray 日志管理： docker logs logspout 安全性： OpenSCAP 特性 集装箱 Docker 打包对象 几乎任何物品 任何软件及其依赖 标准形状和接口允许集装箱被卸载到 各种交通工具，整个运输过程无需打开 容器无需修改便可运行在几乎所有的平台 隔离性 可以重叠起来一起运输 资源、网络、库都是隔离的，不会出现依赖问题 自动化 标准接口使集装箱很容易自动装卸和移动 提供run、start、stop等标准化操作 高效性 无须开箱 轻量级 职责分工 货主只需要考虑把什么放到集装箱 开发人员只需要考虑怎么写代码，运维只需关心如何配置基础环境 Docker核心组件 Docker客户端：Client Docker服务器：Docker daemon，负责创建、运行、监控容器，构建、存储镜像。 Docker镜像：Image Registry：镜像仓库 Docker容器：Container 镜像（Image）一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后不会改变。 常用镜像 1234Docker 图形管理工具docker run -d -p 9001:9000 -v &quot;/var/run/docker.sock:/var/run/docker.sock&quot; portainer/portainer 容器（Container）镜像和容器的关系，就像是面对对象程序设计中的类和实例一一样，镜像是静态的定义，容器是镜像运行的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。 基本用法12345678910拉取最小的镜像docker pull hello-world查看镜像docker image ls运行镜像docker run hello-world hello-world镜像的内容 123FROM scratch # 从0开始构建COPY hello /CMD [&quot;/hello&quot;] base镜像：提供一个基本的操作系统环境，用户可以根据需要安装和配置软件。 不依赖其他镜像，从scratch构建； 其他镜像可以以之为基础进行扩展。 能称为base镜像的通常是各种Linux发行版的Docker镜像，比如Ubuntu、Debian、CentOS等。 构建镜像：docker commit包含三个步骤： 运行容器 修改容器 将容器保存为新的镜像 Dockerfile构建镜像的步骤： 从base镜像运行一个容器 执行一条指令，对容器做修改 执行类似docker commit的操作，生成一个新的镜像层 Docker再基于刚刚提交的镜像运行一个新容器 重复2-4步，直到Dockerfile中的所有指令执行完毕。 Dockerfile实例 12FROM ubuntuRUN apt-get update &amp;&amp; apt-get install -y vim Dockerfile常用命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051指定base镜像FROM设置镜像的作者MAINTSINER从src目录复制文件到容器的dest，其中src可以是Dockerfile所在目录的相对路径，也可以是一个URL。如果src是归档文件，文件会被自动解压到destADD &lt;src&gt;... &lt;dest&gt;设置构建时的环境变量，在容器运行时是不会存在这些变量的。ARG &lt;name&gt;[=&lt;default value&gt;]CMD指令指定容器启动运行指定的命令，* 如果docker run指定了其他命令，CMD指定的默认命令将被忽略。* 每个Dockerfile可以有多个CMD，但只有最后一个生效。CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off&quot;]复制文件COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]设置容器启动时运行的命令，可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run之后的参数会被当做参数传递给ENTRYPOINT。ENTRYPOINT设置环境变量ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...声明在运行时容器提供服务的端口EXPOSE &lt;port&gt; [&lt;port&gt;...]LABEL 为镜像添加元数据LABEL version=&quot;1.0&quot;运行指定的命令，并创建新的镜像层，经常用于安装软件包。RUN &lt;command&gt;RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]USER设置用户VOLUME指定挂载点指定工作目录WORKDIR容器暴露端口EXPOSE 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104* attach：依附到一个正在运行的容器中；* build：从一个 Dockerfile 创建一个镜像；* commit：从一个容器的修改中创建一个新的镜像；* cp：在容器和本地宿主系统之间复制文件中；* create：创建一个新容器，但并不运行它；* diff：检查一个容器内文件系统的修改，包括修改和增加；* events：从服务端获取实时的事件；* exec：在运行的容器内执行命令；* export：导出容器内容为一个 tar 包；* history：显示一个镜像的历史信息；* images：列出存在的镜像；* import：导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；* info：显示一些相关的系统信息；* inspect：显示一个容器的具体配置信息；* kill：关闭一个运行中的容器 (包括进程和所有相关资源)；* load：从一个 tar 包中加载一个镜像；* login：注册或登录到一个 Docker 的仓库服务器；* logout：从 Docker 的仓库服务器登出；* logs：获取容器的 log 信息；* network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；* node：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；* pause：暂停一个容器中的所有进程；* port：查找一个 nat 到一个私有网口的公共口；* ps：列出主机上的容器；* pull：从一个Docker的仓库服务器下拉一个镜像或仓库；* push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；* rename：重命名一个容器；* restart：重启一个运行中的容器；* rm：删除给定的若干个容器；* rmi：删除给定的若干个镜像；* run：创建一个新容器，并在其中运行给定命令；* save：保存一个镜像为 tar 包文件；* search：在 Docker index 中搜索一个镜像；* service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；* start：启动一个容器；* stats：输出（一个或多个）容器的资源使用统计信息；* stop：终止一个运行中的容器；* swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；* tag：为一个镜像打标签；* top：查看一个容器中的正在运行的进程信息；* unpause：将一个容器内所有的进程从暂停状态中恢复；* update：更新指定的若干容器的配置信息；* version：输出 Docker 的版本信息；* volume：管理 Docker volume，包括查看、创建、删除等；* wait：阻塞直到一个容器终止，然后输出它的退出符。进入容器的方式：docker attach：直接进入容器启动命令的终端，不会启动新的进程。docker exec -it &lt;container&gt; bash|shdocker run参数：-d：后台运行-P：随机端口映射-p：指定端口映射，有以下四种格式 ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort-network:指定网络模式，有以下可选参数： -network=brigde 默认选项，表示连接默认的网桥。 -network=host 容器使用宿主主机的网络 -network=container:NAME_or_ID 告诉DOcker让新建的容器使用以有容器的网络配置 -network=none 不配置该容器的网络，用户可自定义网络配置查看运行的容器docker ps停止容器docker stop强制停止容器docker kill进入容器docker attach进入启动的容器交互界面docker exec -it container-id bash删除容器docker rm导出容器docker export red_panda &gt; lastest.tar导入容器docker import nignx2.tar nginxdocker rm $(docker ps -q -f status=exited)docker rmi $(docker images -q -f dangling=true)进入正在运行的容器，39表示容器id前面几位docker exec -it 39 /bin/bash","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[]},{"title":"Git使用笔记","slug":"技术开发/杂项/Git使用笔记","date":"2021-06-07T01:45:07.559Z","updated":"2021-06-07T01:45:07.559Z","comments":true,"path":"wiki/技术开发/杂项/Git使用笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"基本命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364git init // 输出 Initialized empty Git repository in .git/ 建立空仓库git add . //添加到仓库 把所有修改提交到暂存区(Stage)git commit //提交到仓库 把暂存区的所有修改提交到分支git push remote_branch local_branch //将本地库提交到远程库git status //查看修改状态git log //显示从最近到最远的提交日志git clone git@github.com:xxx/gitskills.git //克隆仓库git checkout -b dev 创建并切换分支，相当于下面的两句 git branch experimental 创建分支 git checkout experimental 切换到分支git branch 查看所有已存在的分支。git branch -a 查看远程分支git branch -v 查看所有分支的最后一次操作git branch -vv 查看当前分支git brabch -b 分支名 origin/分支名 //创建远程分支到本地git branch --merged //查看别的分支和当前分支合并过的分支git branch --no-merged //查看未与当前分支合并的分支git branch -d xxx 删除本地分支git branch -D crazy-idea 强制删除分支git merge 分支名 合并分支到当前分支上git push origin --delete &lt;branchname&gt; 删除远程分支git push origin :&lt;branchName&gt; 删除远程分支git remote -v 查看现有的远程仓库git remote add pb git://github.com/paulboone/ticgit.git 添加一个远程仓库 并用pb命名。git remote rm paul 删除远程仓库git remote rename pb paul 重名远程仓库 本地也会跟着修改git remote 查看远程参考暂存操作：git stash 暂存当前修改git stash apply 恢复最近的一次暂存git stash pop 恢复暂存并删除暂存记录git stash list 查看暂存列表git stash drop 暂存名(例：stash@&#123;0&#125;) 移除某次暂存git stash clear 清除暂存回退操作：git reset --hard HEAD^ 回退到上一个版本git reset --hard ahdhs1(commit_id) 回退到某个版本git checkout -- file撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态)git reset HEAD file 撤回暂存区的文件修改到工作区标签操作：tag的作用是方便用户回滚操作，只需要记住tag的名字就能迅速回滚git tag //列出所有标签列表，可以按照标签进行checkoutgit tag 标签名 //添加标签(默认对当前版本)git tag 标签名 commit_id //对某一提交记录打标签git tag -a 标签名 -m &#x27;描述&#x27; //创建新标签并增加备注git show 标签名 //查看标签信息git tag -d 标签名 //删除本地标签git push origin 标签名 推送标签到远程仓库git push origin --tags 推送所有标签到远程仓库git push origin :refs/tags/标签名 从远程仓库中删除标签 拉取体积很大的仓库12345git clone --depth 1 仓库地址git branch -agit remote set-branches origin &#x27;远程分支名称’git fetch --depth 1 origin 远程分支名称git checkout ‘远程分支名称’ 仓库之间的迁移整个仓库迁移123git clone --bare 旧仓库地址git push --mirror 新仓库地址 迁移一个分支12git remote add 本地分支 新仓库地址 //关联远程分支git push 远程分支 本地分支 //提交分支","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://shjlone.github.io/tags/Git/"}]},{"title":"Linux常用操作","slug":"技术开发/杂项/Linux常用操作","date":"2021-06-07T01:45:07.559Z","updated":"2021-06-07T01:45:07.559Z","comments":true,"path":"wiki/技术开发/杂项/Linux常用操作/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"添加用户并赋予权限#添加用户 adduser -m xxx vim /etc/sudoers 添加：%sudo ALL=(ALL:ALL) ALL 将用户添加到sudo组 gpasswd -a xxx sudo ssh操作配置 ssh -p 端口号 用户名@ip地址 ssh -p 22 root@192.168.1.1 #设置私钥的权限 chmod 666 id_rsa","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://shjlone.github.io/tags/linux/"}]},{"title":"Mac软件安装笔记","slug":"技术开发/杂项/Mac软件安装笔记","date":"2021-06-07T01:45:07.559Z","updated":"2021-06-07T01:45:07.559Z","comments":true,"path":"wiki/技术开发/杂项/Mac软件安装笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Mac%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/","excerpt":"","text":"brew命令1234567brew services list 查看服务状态brew services run mysql # 启动mysql 服务brew services start mysql # 启动 mysql 服务，并注册开机自启brew services stop mysql # 停止 mysql 服务，并取消开机自启brew services restart mysql # 重启 mysql 服务，并注册开机自启brew services cleanup # 清除已卸载应用的无用配置 mysql123456789101112131415161718brew install mysqlbrew services start mysqlbrew services stop mysqlmysql -urootSHOW VARIABLES LIKE &#x27;validate_password%&#x27;; //查看密码初始策略SET GLOBAL validate_password.policy=LOW; //设置某个属性SET GLOBAL validate_password.length=6; //修改密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH caching_sha2_password BY &#x27;yourpasswd&#x27;;flush privileges;describe user; //查看表字段 使用mysql的配置脚本：/usr/local/opt/mysql/bin/mysql_secure_installation //mysql 提供的配置向导启动这个脚本后 重置密码123456$ brew services stop mysql$ pkill mysqld$ rm -rf /usr/local/var/mysql/ # NOTE: this will delete your existing database!!!$ brew postinstall mysql$ brew services restart mysql$ mysql -u root","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://shjlone.github.io/tags/mac/"}]},{"title":"Connection reset by peer) while reading response header from upstream","slug":"技术开发/服务端/Connection reset by peer","date":"2021-06-07T01:45:07.558Z","updated":"2021-06-07T01:45:07.558Z","comments":true,"path":"wiki/技术开发/服务端/Connection reset by peer/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Connection%20reset%20by%20peer/","excerpt":"","text":"问题：Connection reset by peer) while reading response header from upstream描述：某些请求一直返回502 Bad Gateway的错误，查看服务端的error日志，显示Connection reset by peer。当时的场景是一个每隔一分钟的定时脚本每次运行时，获取需要处理的数据，同步请求某个服务端接口进行文件上传。猜测是这个接口请求响应很慢，一分钟后又再次请求同样的接口而出现问题。 处理：修改接口对应的逻辑，让这个接口能快速响应；此问题消失。查阅资料，Nginx的响应有几个参数设置： keepalive_timeout：设置客户端的长连接超时时间，如果超过这个时间客户端没有发起请求，则Nginx服务器会主动关闭长连接。 keepalive_requests：设置与客户端的建立的一个长连接可以处理的最大请求次数，如果超过这个值，则Nginx会主动关闭该长连接。 对于此类问题，也可以尝试将keepalive_timeout的时间设置的长一些。","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"Linux常用命令","slug":"技术开发/服务端/Linux常用命令","date":"2021-06-07T01:45:07.558Z","updated":"2021-06-07T01:45:07.558Z","comments":true,"path":"wiki/技术开发/服务端/Linux常用命令/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"grep常用命令12345678910111213141516171819202122232425# 查找进程中所有跟nginx匹配的ps -ef | grep nginx# 查看进程数ps -ef | grep nginx -c # 搜索某个文件夹下，哪些文件包含关键字grep -r &quot;关键字&quot; 文件夹# 根据字符串搜索grep “被查找的字符串” 文件名 # 根据正则搜索grep –e “正则表达式” 文件名# 搜索不区分大小写grep –i “被查找的字符串” 文件名# 显示搜索出来的信息所在的行数grep -c “被查找的字符串” 文件名 find常用命令1234567891011# 查看当前目录下所有php文件find . &quot;*.php&quot;find . -name &quot;*.php&quot;# 查找当前目录下，最近120分钟修改过的文件find . -mmin -120# 查看当前目录下，是否有名字叫“通讯录”的文件夹，-type：表示设定类型，d表示文件夹类型，可以替换为f(普通文件)、l(链接文件)find . -type d -name 通讯录","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"MySQL知识点","slug":"技术开发/服务端/MySQL知识点","date":"2021-06-07T01:45:07.558Z","updated":"2021-06-07T01:45:07.558Z","comments":true,"path":"wiki/技术开发/服务端/MySQL知识点/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"explain 使用 列名 说明 id 执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置 select_type 显示本行是简单或复杂select。如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT） table 访问引用哪个表（引用某个查询，如“derived3”） type 数据访问/读取操作类型（ALL、index、range、ref、eq_ref、const/system、NULL） possible_keys 揭示哪一些索引可能有利于高效的查找 key 显示mysql决定采用哪个索引来优化查询 key_len 显示mysql在索引里使用的字节数 ref 显示了之前的表在key列记录的索引中查找值所用的列或常量 rows 为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可粗略估算整个查询会检查的行数 Extra 额外信息，如using index、filesort等 select_type 类型 说明 simple 简单子查询，不包含子查询和union primary 包含union或者子查询，最外层的部分标记为primary subquery 一般子查询中的子查询被标记为subquery，也就是位于select列表中的查询 derived 派生表——该临时表是从子查询派生出来的，位于form中的子查询 union 位于union中第二个及其以后的子查询被标记为union，第一个就被标记为primary如果是union位于from中则标记为derived union result 用来从匿名临时表里检索结果的select被标记为union result dependent union 顾名思义，首先需要满足UNION的条件，及UNION中第二个以及后面的SELECT语句，同时该语句依赖外部的查询 subquery 子查询中第一个SELECT语句 dependent subquery 和DEPENDENT UNION相对UNION一样 type type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL ，一般来说，得保证查询至少达到range级别，最好能达到ref。 类型 说明 All 最坏的情况,全表扫描 index 和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序, 但是开销仍然非常大。如在Extra列看到Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多 range 范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用=、 &lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN 或者 IN 操作符,用常量比较关键字列时,可以使用 range ref 一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟eq_ref不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是UNIQUE和PRIMARY KEY。ref可以用于使用=或&lt;=&gt;操作符的带索引的列。 eq_ref 最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效） const 当确定最多只会有一行匹配的时候，MySQL优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入where子句时，mysql把这个查询转为一个常量（高效） system 这是const连接类型的一种特例，表仅有一行满足条件。 Null 意味说mysql能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效） Extra Extra是EXPLAIN输出中另外一个很重要的列，该列显示MySQL在查询过程中的一些详细信息，MySQL查询优化器执行查询的过程中对查询计划的重要补充信息。 类型 说明 Using filesort MySQL有两种方式可以生成有序的结果，通过排序操作或者使用索引，当Extra中出现了Using filesort 说明MySQL使用了后者，但注意虽然叫filesort但并不是说明就是用了文件来进行排序，只要可能排序都是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这是可能是ordery by，group by语句的结果，这可能是一个CPU密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。 Using temporary 用临时表保存中间结果，常用于GROUP BY 和 ORDER BY操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用。 Not exists MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行， 就不再搜索了。 Using index 说明查询是覆盖了索引的，不需要读取数据文件，从索引树（索引文件）中即可获得信息。如果同时出现using where，表明索引被用来执行索引键值的查找，没有using where，表明索引用来读取数据而非执行查找动作。这是MySQL服务层完成的，但无需再回表查询记录。 Using index condition 这是MySQL 5.6出来的新特性，叫做“索引条件推送”。简单说一点就是MySQL原来在索引上是不能执行如like这样的操作的，但是现在可以了，这样减少了不必要的IO操作，但是只能用在二级索引上。 Using where 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。注意：Extra列出现Using where表示MySQL服务器将存储引擎返回服务层以后再应用WHERE条件过滤。 Using join buffer 使用了连接缓存：Block Nested Loop，连接算法是块嵌套循环连接;Batched Key Access，连接算法是批量索引连接 impossible where where子句的值总是false，不能用来获取任何元组 select tables optimized away 在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作，或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。 distinct 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作 慢查询分析查询日志设置1234567show variables like &#x27;general_log&#x27;; #查询是否开启查询日志set global general_log = on; # 开启查询日志show variables like &#x27;log_output&#x27;; # 查看日志写入类型set global log_output = &#x27;table&#x27;; #修改日志写入类型select *from mysql.slow_loglimit 100; # 慢查询日志记录表 mysql.slow_log 表字段意义 123456query_time： SQL语句的查询时间(在 MySQL 中所有类型的 SQL 语句执行的时间都叫做 query_time,而在 Oracle 中则仅指 select)lock_time: 锁的时间rows_sent: 返回了多少行,如果做了聚合就不准确了rows_examined: #执行这条 SQL 处理了多少行数据db: 使用了哪个数据库sql_text： 执行的sql语句 存疑的点 什么情况下需要开启查询缓存？ 常见问题","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"RabbitMQ笔记","slug":"技术开发/服务端/RabbitMQ笔记","date":"2021-06-07T01:45:07.558Z","updated":"2021-06-07T01:45:07.558Z","comments":true,"path":"wiki/技术开发/服务端/RabbitMQ笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/RabbitMQ%E7%AC%94%E8%AE%B0/","excerpt":"","text":"安装安装PHP扩展amqp12345678910111213141516PHP &lt; 7.3#install some base extensionsRUN apt-get install -y \\ libzip-dev \\ zip \\ &amp;&amp; docker-php-ext-configure zip --with-libzip \\ &amp;&amp; docker-php-ext-install zipPHP &gt;= 7.3#install some base extensionsRUN apt-get install -y \\libzip-dev \\zip \\&amp;&amp; docker-php-ext-install zip 安装RabbitMQdocker安装，使用localhost:5672访问其后台 123456789101112rabbitmq: image:rabbitmq:management restart: always environment: RABBITMQ_DEFAULT_USER: &quot;root&quot; RABBITMQ_DEFAULT_PASS: &quot;root&quot; volumes: - ./code/rabbitmq/rabbitmq:/var/lib/rabbitmq - ./code/rabbitmq/log:/log/rabbitmq/log ports: - 15672:15672 - 5672:5672 Symfony安装扩展https://github.com/php-amqplib/RabbitMqBundle Symfony中的composer中添加 1&quot;php-amqplib/rabbitmq-bundle&quot;: &quot;1.14.4&quot; 执行更新命令 1php composer update php-amqplib/rabbitmq-bundle 使用参考 https://rabbitmq.com https://blog.csdn.net/whoamiyang/article/details/54954780","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"服务端","slug":"技术开发/服务端","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"http://shjlone.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"高效的使用Mac","slug":"工具软件/高效的使用Mac","date":"2021-06-07T01:45:07.557Z","updated":"2021-06-07T01:45:07.557Z","comments":true,"path":"wiki/工具软件/高效的使用Mac/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/%E9%AB%98%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8Mac/","excerpt":"","text":"Effective use of XXX系列 Effective use of Mac Effective use of iPhone Effective use of Windows Effective use of Firefox Effective use of Alfred 对于高效使用的理解 所谓的高效，在笔者看来就是可以一步完成的事情，一定不要花两步。虽然Mac本身的操作已经比较人性化了，但还是有很多地方可以值得我们优化的。下面列一些场景分析一下。 场景一：想在不同软件之间快速切换。一般的做法是使用Command+Tab进行已经打开的软件间切换，使用聚焦搜索软件名进行打开。其实可以使用快捷键进行切换，参考Alfred的用法。 场景二：比如当前在文本编辑器页面写文章，突然想到某个东西需要去百度搜索一下。一般的做法是，使用Command+Tab切换到浏览器，在浏览器中新建tab页，输入baidu.com，输入关键字，进行搜索。而使用Alfred，则可以优化为：Alt+space打开Alfred搜索框，输入bd+空格，输入关键字，回车，即可自动打开浏览器搜索页。 场景三：在做复制粘贴的时候，有时候想对以前复制过的内容进行粘贴。 场景四：有一些使用率非常高的词，比如QQ号、邮箱、手机号、身份证号等信息，需要不停的输入，如果可以做到输入几个关键字就能全部输出岂不是提升了很多时间？ 好了，下面正式开始动手吧！ 此文致力于提高使用效率，基本的操作请读者自行阅读官方文档或其他文档。 Mac的基本优化访达的优化显示隐藏文件方法一： 使用快捷键Command+Shift+. 方法二： 终端中输入下面的命令，这种方式会长久生效。 1234隐藏defaults write com.apple.finder AppleShowAllFiles -boolean true;killall Finder显示defaults write com.apple.finder AppleShowAllFiles -boolean false;killall Finder 顶部栏显示完整路径可以通过在访达中设置显示路径栏的方式显示，不过这种方式会在访达底部多一栏。可以通过终端输入以下命令。 123456显示完整路径defaults write com.apple.finder _FXShowPosixPathInTitle -bool TRUE;killall Finder隐藏完整路径defaults delete com.apple.finder _FXShowPosixPathInTitle;killall Finder 标签的使用这是一个非常实用的功能，将文件/文件夹标记成不同的标签，然后通过点击标签来快速定位。对于目录层次很深的文件非常有用。 使用也很简单，右键某个文件或文件夹，点击某个标签即可。标签也可以进行管理，标签的图标也可以自定义，选中标签栏中某个标签，使用command+control+空格。 对于使用频率非常高的文件夹，可以直接拖拽到个人收藏栏，也可以拖拽到工具栏 开机启动脚本设置首先创建一个shell文件，根据自己的需求实现一些逻辑，比如： 123456789#开机启动脚本# 开机需要启动的程序open /Applications/DingTalk.appopen /Applications/QQ.app# 其他操作#exit 然后给这个文件添加执行权限，chmod +x 文件名。然后设置打开方式为终端。 然后打开系统偏好设置–&gt;用户与群组–&gt;登录项，添加新建的shell文件。 Mac上的提高效率的软件Alfred（神器）由于此软件非常强大，因此单独写一篇来介绍它，[点击查看]() switchhost（hosts切换）该软件是用来做hosts管理的，对于程序员来说非常友好，用法也很简单。可以建立一个个tab来分组管理，每个tab可以的显示隐藏互不影响。点击行号可以对该行进行快速注释或者取消注释。 [img] iTerm（终端的替代品）配置 资源管理器工具Commander One不完善的地方： 路径栏无法直接编辑，不方便直接跳转到某个路径。Total Commander的路径是可编辑的。 无法直接使用快捷键将当前页面显示到另外一测。Total Commander可以直接使用Ctrl+←→来操作。 不可配置编辑所使用的软件，只能用默认的。 BatterZip（文件解压压缩）Sublime Text（文件编辑器）轻量级文本编辑器，可配置性很强。 CleanMyMac（优化工具）Dash（程序员API查询工具）Mac常用命令12lsof -i:port 查询端口对应的进程idkill pid 杀死进程 参考","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://shjlone.github.io/tags/mac/"}]},{"title":"Proxifier使用","slug":"工具软件/Proxifier使用","date":"2021-06-07T01:45:07.556Z","updated":"2021-06-07T01:45:07.556Z","comments":true,"path":"wiki/工具软件/Proxifier使用/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Proxifier%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Proxifier的作用：让电脑上的软件的网络请求先经过代理，可用于翻墙、接口抓取等。 设置Proxies设置Server设置为代理对应的IP地址，本地使用localhost/127.0.0.1 Protocol可设置为Socks或https Rules设置可以做一些个性化设置，比如某些应用不走代理 参考 https://xiandan.in/posts/mac-global-proxy.html https://www.hizxc.com/1546.html","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"Firefox插件推荐","slug":"工具软件/Firefox插件推荐","date":"2021-06-07T01:45:07.556Z","updated":"2021-06-07T01:45:07.556Z","comments":true,"path":"wiki/工具软件/Firefox插件推荐/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Firefox%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"","text":"AdGuard去广告神器 https://github.com/AdGuardTeam/AdGuardBrowserExtension In My Pocket将网页内容缓存起来，方便以后阅读，查看。 JSON Lite对json类型格式化显示 OctotreeGithub的文件目录用树形表示 Greasemonkey脚本管理器 Dark Reader设置黑色主题 印象笔记·剪藏保存网页内容到Evernote iCloud书签同步Firefox和Safira书签","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://shjlone.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"Windows优秀的工具软件","slug":"工具软件/Windows优秀的工具软件","date":"2021-06-07T01:45:07.556Z","updated":"2021-06-07T01:45:07.556Z","comments":true,"path":"wiki/工具软件/Windows优秀的工具软件/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Windows%E4%BC%98%E7%A7%80%E7%9A%84%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"文件解锁工具 魔方解锁独立版 内存、CPU监控工具TrafficMonitor 介绍：https://www.appinn.com/trafficmonitor/ Github地址：https://github.com/zhongyang219/TrafficMonitor 文件管理工具TotalCommand 官网地址：https://www.ghisler.com/ 文件搜索工具Everything 官网地址：http://www.voidtools.com/ 剪切板增强工具Ditto 官网地址：https://ditto-cp.sourceforge.io/ 屏幕截图工具 Snagit FSCapture 相关介绍 颜色吸取工具getcolor! 下载地址： https://www.wincatalog.com/getcolor.html","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://shjlone.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"屏幕截图工具","slug":"工具软件/屏幕截图工具","date":"2021-06-07T01:45:07.556Z","updated":"2021-06-07T01:45:07.556Z","comments":true,"path":"wiki/工具软件/屏幕截图工具/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/","excerpt":"","text":"平时工作中有很多场景需要使用屏幕截图，原来一直使用QQ自带的截图功能。虽然功能不是很全，但也够了。但由于其是QQ的一个子功能，每次一定要启动QQ才能使用。于是想看有木有更加方便好用的截图软件。 这里推荐两款自认为不错的工具： Snagit主要功能： 捕获窗口截图 区域截图 全屏幕截图 抓取文字 屏幕录像 捕获滚动窗口 FSCapture主要功能： 捕获窗口截图 区域截图 全屏幕截图 抓取文字 屏幕录像 捕获滚动窗口 捕获手绘区域 QQ截屏独立版包含所需的基本功能，且可执行文件很小，不到800K。添加桌面快捷方式，配置好快捷键后，使用非常方便。 下载地址：","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://shjlone.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"文本编辑工具Sublime Text","slug":"工具软件/文本编辑工具Sublime Text","date":"2021-06-07T01:45:07.556Z","updated":"2021-06-07T01:45:07.557Z","comments":true,"path":"wiki/工具软件/文本编辑工具Sublime Text/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7Sublime%20Text/","excerpt":"","text":"Markdown环境搭建安装扩展MarkdownEditing下载地址： https://github.com/SublimeText-Markdown/MarkdownEditing 快捷键 Windows/Linux 描述 CtrlAltV Creates or pastes the contents of the clipboard as an inline link on selected text. CtrlAltR Creates or pastes the contents of the clipboard as a reference link. ShiftWinK Creates or pastes the contents of the clipboard as an inline image on selected text. AltB AltI These are bound to bold and italic. They work both with and without selections. If there is no selection, they will just transform the word under the cursor. These keybindings will unbold/unitalicize selection if it is already bold/italic. Ctrl1...6 These will add the corresponding number of hashmarks for headlines. Works on blank lines and selected text in tandem with the above headline tools. If you select an entire existing headline, the current hashmarks will be removed and replaced with the header level you requested. This command respects the mde.match_header_hashes preference setting. AltShift6 Inserts a footnote. ShiftTab Fold/Unfold current section. CtrlShiftTab Fold all sections under headings of a certain level. CtrlAltShiftPageUp CtrlAltShiftPageDown Go to the previous/next heading of the same or higher level CtrlShiftPageUp CtrlShiftPageDown Go to the previous/next heading CtrlShiftH Open home page CtrlShiftD Open wiki page under the cursor CtrlShiftJ Open journal page for today CtrlShiftB List back links 表格编辑插件下载地址： https://packagecontrol.io/packages/Table%20Editor PHP环境搭建Python环境搭建安装Anaconda插件(代码提示、自动补全、格式化)//快捷键配置 [ &#123; &quot;command&quot;: &quot;anaconda_goto&quot;, &quot;keys&quot;: [&quot;ctrl+alt+g&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125; ]&#125;, &#123; &quot;command&quot;: &quot;anaconda_find_usages&quot;, &quot;keys&quot;: [&quot;ctrl+alt+f&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125; ]&#125;, &#123; &quot;command&quot;: &quot;anaconda_doc&quot;, &quot;keys&quot;: [&quot;ctrl+alt+d&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125; ]&#125;, //格式化 &#123; &quot;command&quot;: &quot;anaconda_auto_format&quot;, &quot;keys&quot;: [&quot;ctrl+alt+r&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125; ]&#125;, &#123; &quot;command&quot;: &quot;anaconda_fill_funcargs&quot;, &quot;keys&quot;: [&quot;tab&quot;], &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125;, &#123;&quot;key&quot;: &quot;anaconda_insert_funcargs&quot;&#125; ]&#125;, &#123; &quot;command&quot;: &quot;anaconda_fill_funcargs&quot;, &quot;keys&quot;: [&quot;ctrl+tab&quot;], &quot;args&quot;: &#123;&quot;all&quot;: true&#125;, &quot;context&quot;: [ &#123;&quot;key&quot;: &quot;selector&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;source.python&quot;&#125;, &#123;&quot;key&quot;: &quot;anaconda_insert_funcargs&quot;&#125; ]&#125; ] 配置Python解释器打开Preferences--&gt;Package Settings--&gt;Anaconda--&gt;Settings-User &#123; //设置python解释器路径 &quot;python_interpreter&quot;: &quot;D:\\\\Python\\\\Python364-64\\\\python.exe&quot;, &quot;suppress_word_completions&quot;: true, &quot;suppress_explicit_completions&quot;: true, &quot;complete_parameters&quot;: true, &quot;anaconda_linting&quot;: false &#125; Sublime中console交互，安装SublimeREPL配置SUblimeREPL快捷键1. Preferences--&gt;Browse Packages--&gt;SublimeREPL文件夹--&gt;config文件夹--&gt;Python文件夹--&gt;Default.sublime-commands 2. 找到对应的command，添加到Preferences--&gt;Key Bindings User中。 &#123; &quot;keys&quot;: [&quot;f5&quot;], &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123; &quot;id&quot;: &quot;repl_python&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot; &#125; &#125;, 如何设置快捷键打开Preferences--&gt;Key Bindings，对于向要定义自己喜好的快捷键的操作，复制左边默认的配置到用户栏，进行修改。 如何修改默认配置打开Preferences--&gt;Settings，重写默认配置即可。 Sublime 插件Anaconda:Python插件 CodeFormatter：代码提示插件 ConvertToUTF8 SublimeCodeIntel Markdown Preview：Markdown预览插件 Emmet：HTML/CSS代码快速编写插件 SublimeLinter：代码检测插件 SideBarEnhancements：侧边栏扩展 PackageResourceViewer：Sublime配置管理插件,选择Open Resource,选择对应的配置进行修改 Boxy Theme:样式插件 Terminal：在Sublime中打开终端 CTags：[代码跳转](https://my.oschina.net/u/1024767/blog/495282) http://ctags.sourceforge.net/ Sublime PHP Companion All Autocomplete DocBlockr SublimeAStyleFormatter：C, C++, C#, 和 Java文件格式化 如何备份插件备份Preferences–&gt;Browse Packages的内容 属性配置&#123; //默认字体大小 &quot;font_size&quot;: 10, &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ], //是否检查更新 &quot;update_check&quot;: &quot;false&quot;, //显示空格符号 // &quot;draw_white_space&quot;: &quot;all&quot;, &#125; 常用快捷键配置[ //跳转到定义 &#123; &quot;keys&quot;: [&quot;f3&quot;], &quot;command&quot;: &quot;goto_definition&quot; &#125;, //删除当前行 &#123; &quot;keys&quot;: [&quot;ctrl+d&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;res://Packages/Default/Delete Line.sublime-macro&quot;&#125; &#125;, //back &#123; &quot;keys&quot;: [&quot;alt+left&quot;], &quot;command&quot;: &quot;jump_back&quot; &#125;, //forward &#123; &quot;keys&quot;: [&quot;alt+right&quot;], &quot;command&quot;: &quot;jump_forward&quot; &#125;, //移动当前行到上一行 &#123; &quot;keys&quot;: [&quot;alt+up&quot;], &quot;command&quot;: &quot;swap_line_up&quot; &#125;, //移动当前行到下一行 &#123; &quot;keys&quot;: [&quot;alt+down&quot;], &quot;command&quot;: &quot;swap_line_down&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+alt+f&quot;], &quot;command&quot;: &quot;reindent&quot; &#125;, // 自动提示、补全 &#123; &quot;keys&quot;: [&quot;alt+/&quot;], &quot;command&quot;: &quot;auto_complete&quot;&#125;, //代码提示 &#123; &quot;keys&quot;: [&quot;alt+/&quot;], &quot;command&quot;: &quot;replace_completion_with_auto_complete&quot;, &quot;context&quot;: [&#123; &quot;key&quot;: &quot;last_command&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: &quot;insert_best_completion&quot; &#125;, &#123; &quot;key&quot;: &quot;auto_complete_visible&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: false &#125;, &#123; &quot;key&quot;: &quot;setting.tab_completion&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: true &#125;] &#125;, //Ctrl+l 选中当前行 //编译当前脚本 &#123; &quot;keys&quot;: [&quot;ctrl+b&quot;], &quot;command&quot;: &quot;build&quot; &#125;, //隐藏Side Bar开关 &#123; &quot;keys&quot;: [&quot;ctrl+k&quot;], &quot;command&quot;: &quot;toggle_side_bar&quot; &#125;, //向左缩进 &#123; &quot;keys&quot;: [&quot;ctrl+]&quot;], &quot;command&quot;: &quot;indent&quot; &#125;, //向右缩进 &#123; &quot;keys&quot;: [&quot;ctrl+[&quot;], &quot;command&quot;: &quot;unindent&quot; &#125;, //列出当前打开的文件 &#123; &quot;keys&quot;: [&quot;ctrl+p&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;show_files&quot;: true&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+shift+p&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;command_palette&quot;&#125; &#125;, //跳转到符号 &#123; &quot;keys&quot;: [&quot;ctrl+r&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;@&quot;&#125; &#125;, //跳转到行 &#123; &quot;keys&quot;: [&quot;ctrl+g&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;:&quot;&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+;&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;#&quot;&#125; &#125;, //快速在起始括号和结尾括号间切换 &#123; &quot;keys&quot;: [&quot;ctrl+m&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;brackets&quot;&#125; &#125;, //选择括号间的内容 &#123; &quot;keys&quot;: [&quot;ctrl+shift+m&quot;], &quot;command&quot;: &quot;expand_selection&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;brackets&quot;&#125; &#125;, //当前行下面新增一行并跳至该行 &#123; &quot;keys&quot;: [&quot;ctrl+enter&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;res://Packages/Default/Add Line.sublime-macro&quot;&#125; &#125;, //当前行上面新增一行并调至该行 &#123; &quot;keys&quot;: [&quot;ctrl+shift+enter&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;res://Packages/Default/Add Line Before.sublime-macro&quot;&#125; &#125;, //进行逐词移动 &#123; &quot;keys&quot;: [&quot;ctrl+left&quot;], &quot;command&quot;: &quot;move&quot;, &quot;args&quot;: &#123;&quot;by&quot;: &quot;words&quot;, &quot;forward&quot;: false&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+right&quot;], &quot;command&quot;: &quot;move&quot;, &quot;args&quot;: &#123;&quot;by&quot;: &quot;word_ends&quot;, &quot;forward&quot;: true&#125; &#125;, //逐词选择 &#123; &quot;keys&quot;: [&quot;ctrl+shift+left&quot;], &quot;command&quot;: &quot;move&quot;, &quot;args&quot;: &#123;&quot;by&quot;: &quot;words&quot;, &quot;forward&quot;: false, &quot;extend&quot;: true&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+shift+right&quot;], &quot;command&quot;: &quot;move&quot;, &quot;args&quot;: &#123;&quot;by&quot;: &quot;word_ends&quot;, &quot;forward&quot;: true, &quot;extend&quot;: true&#125; &#125;, //上下移动当前显示区域 &#123; &quot;keys&quot;: [&quot;ctrl+up&quot;], &quot;command&quot;: &quot;scroll_lines&quot;, &quot;args&quot;: &#123;&quot;amount&quot;: 1.0 &#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+down&quot;], &quot;command&quot;: &quot;scroll_lines&quot;, &quot;args&quot;: &#123;&quot;amount&quot;: -1.0 &#125; &#125;, //移动当前行 &#123; &quot;keys&quot;: [&quot;ctrl+shift+up&quot;], &quot;command&quot;: &quot;swap_line_up&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+shift+down&quot;], &quot;command&quot;: &quot;swap_line_down&quot; &#125;, //删除当前 &#123; &quot;keys&quot;: [&quot;ctrl+shift+k&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;res://Packages/Default/Delete Line.sublime-macro&quot;&#125; &#125;, //Ctrl + D选择当前光标所在的词并高亮该词所有出现的位置，再次Ctrl + D选择该词出现的下一个位置，在多重选词的过程中，使用Ctrl + K进行跳过，使用Ctrl + U进行回退，使用Esc退出多重编辑。 &#123; &quot;keys&quot;: [&quot;ctrl+d&quot;], &quot;command&quot;: &quot;find_under_expand&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+k&quot;, &quot;ctrl+d&quot;], &quot;command&quot;: &quot;find_under_expand_skip&quot; &#125;, //打散所选区域 &#123; &quot;keys&quot;: [&quot;ctrl+shift+l&quot;], &quot;command&quot;: &quot;split_selection_into_lines&quot; &#125;, //将选中区域合并为一行 &#123; &quot;keys&quot;: [&quot;ctrl+j&quot;], &quot;command&quot;: &quot;join_&lt;l&gt;&lt;/l&gt;ines&quot; &#125;, //选择行 &#123; &quot;keys&quot;: [&quot;ctrl+l&quot;], &quot;command&quot;: &quot;expand_selection&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;line&quot;&#125; &#125;, //把选区分割 &#123; &quot;keys&quot;: [&quot;ctrl+shift+l&quot;], &quot;command&quot;: &quot;split_selection_into_lines&quot; &#125;, ] 如何自定义插件 如何自定义代码块 如何自定义语法 参考官方文档 Sublime Text非官方文档 Sublime Text3文档","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://shjlone.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"Alfred使用技巧","slug":"工具软件/Alfred使用技巧","date":"2021-06-07T01:45:07.555Z","updated":"2021-06-07T01:45:07.555Z","comments":true,"path":"wiki/工具软件/Alfred使用技巧/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Alfred%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"基本操作 使用Alt+空格启动，在输入框中输入相应命令进行操作。以下根据其设置界面的布局，按照相应的目录进行介绍。 General General界面主要是以下几个功能： Startup：是否在系统启动时自启动Alfred。 Alfred Hotkey：调出Alfred操作界面的热键。默认为Alt + 空格。 Where are you：你在哪个国家。Alfred内置了常用网站搜索功能，在搜索时打开对应国家的网站。 Features 这里包含了Alfred自己开发的功能，接下来一个一个介绍它们。有些功能在我们日常使用中非常有用！ Defalut Result 打开输入框后，按一下空格，即可在Finder中搜索相应文件。 Essentials： 基本的搜索设置 Extras： 额外的搜索设置 Search Scope： 搜索的范围，可以自定义一些常用文件夹 Fallbacks： 若上面的查询搜索不到结果时，就会调用这里设置的网站或搜索引擎来进行进一步的查询。 File Search SearchOpening Files open+文件名直接打开某个文件。 Revealing Files find+文件名则表示在Finder中打开该文件。 Inside Files in+内容可以把文件中包含内容的文件找出来。 File Tags tag+标签名字可以把打上标签的文件或文件夹搜索出来。 Don’t Show: 不显示某类型的文件 Result Limit： 搜索条数限制 NavigationBufferAdvancedActions顾名思义，Actions指你要对文件执行的动作。先搜索到你要处理的文件，然后点击Ctrl键。 Web Search 网络搜索，也可以自定义自己的搜索。比如使用百度搜索 Web Bookmarks搜索浏览器书签，目前只支持safari、chrome。 Clipboard History剪切板历史，可以自定义快捷键，打开历史面板。非常实用的一个功能。 Snippets短语设置，配置一些常用的短语，设置简短的关键字。还可以设置自动替换。 Calculator可以直接在aflred搜索框中使用计算功能 Workflows有了工作流，我们的效率会得到很大的提高。比如，可以迅速切换软件，快速查询自己想看的书评、电影评价，快速查询当前ip地址，快速查询当前股票的价格等。 AppLauncher设置快捷键快速打开软件 douban豆瓣搜索，dbb+书名和dbm+电影名进行相关搜索 Githubgithub搜索 Gitlabgitlab搜索 IP Address当前内网和外网ip查询 中国股票行情 进行股票查询，gp+股票号码进行实时股价查询，gp add xxxxxx把相应股票添加到自选股，gp list查看所有自选股的股价。 AppearanceAlfred主题 RemoteAdvanced","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"Chrome插件推荐","slug":"工具软件/Chrome插件推荐","date":"2021-06-07T01:45:07.555Z","updated":"2021-06-07T01:45:07.555Z","comments":true,"path":"wiki/工具软件/Chrome插件推荐/","link":"","permalink":"http://shjlone.github.io/wiki/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/Chrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"","text":"Proxy SwitchyOmegaVPN代理 Clear Cache清理缓存 DJSON ViewerJSON格式化显示 Gitlab TreeViewGitlab文件夹树形显示 Last Pass记录密码 Extensity扩展显示管理","raw":null,"content":null,"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://shjlone.github.io/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://shjlone.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"tushare","slug":"Python/tushare","date":"2021-06-07T01:45:07.554Z","updated":"2021-06-07T01:45:07.554Z","comments":true,"path":"wiki/Python/tushare/","link":"","permalink":"http://shjlone.github.io/wiki/Python/tushare/","excerpt":"","text":"股票数据抓取框架使用TuShare。 http://tushare.org/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"sqlalchemy","slug":"Python/sqlalchemy","date":"2021-06-07T01:45:07.553Z","updated":"2021-06-07T01:45:07.553Z","comments":true,"path":"wiki/Python/sqlalchemy/","link":"","permalink":"http://shjlone.github.io/wiki/Python/sqlalchemy/","excerpt":"","text":"为什么要使用ORM框架？ 为了方便，降低出错概率，可读性更好。 基本操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152连接数据#Unix/Mac - 4 initial slashes in totalengine = create_engine(&#x27;sqlite:////absolute/path/to/foo.db&#x27;)#Windowsengine = create_engine(&#x27;sqlite:///C:\\\\path\\\\to\\\\foo.db&#x27;)#Windows alternative using raw stringengine = create_engine(r&#x27;sqlite:///C:\\path\\to\\foo.db&#x27;)创建引擎engine = create_engine(&#x27;sqlite:///foo.db?check_same_thread=False&#x27;, echo=True)定义映射from sqlalchemy.ext.declarative import declarative_baseBase = declarative_base()创建实体类from sqlalchemy import Column, Integer, String# 定义映射类User，其继承上一步创建的Baseclass User(Base): # 指定本类映射到users表 __tablename__ = &#x27;users&#x27; # 如果有多个类指向同一张表，那么在后边的类需要把extend_existing设为True，表示在已有列基础上进行扩展 # 或者换句话说，sqlalchemy允许类是表的字集 # __table_args__ = &#123;&#x27;extend_existing&#x27;: True&#125; # 如果表在同一个数据库服务（datebase）的不同数据库中（schema），可使用schema参数进一步指定数据库 # __table_args__ = &#123;&#x27;schema&#x27;: &#x27;test_database&#x27;&#125; # 各变量名一定要与表的各字段名一样，因为相同的名字是他们之间的唯一关联关系 # 从语法上说，各变量类型和表的类型可以不完全一致，如表字段是String(64)，但我就定义成String(32) # 但为了避免造成不必要的错误，变量的类型和其对应的表的字段的类型还是要相一致 # sqlalchemy强制要求必须要有主键字段不然会报错，如果要映射一张已存在且没有主键的表，那么可行的做法是将所有字段都设为primary_key=True # 不要看随便将一个非主键字段设为primary_key，然后似乎就没报错就能使用了，sqlalchemy在接收到查询结果后还会自己根据主键进行一次去重 # 指定id映射到id字段; id字段为整型，为主键，自动增长（其实整型主键默认就自动增长） id = Column(Integer, primary_key=True, autoincrement=True) # 指定name映射到name字段; name字段为字符串类形， name = Column(String(20)) fullname = Column(String(32)) password = Column(String(32)) # __repr__方法用于输出该类的对象被print()时输出的字符串，如果不想写可以不写 def __repr__(self): return &quot;&lt;User(name=&#x27;%s&#x27;, fullname=&#x27;%s&#x27;, password=&#x27;%s&#x27;)&gt;&quot; % ( self.name, self.fullname, self.password)# 查看映射对应的表User.__table__# 创建数据表。一方面通过engine来连接数据库，另一方面根据哪些类继承了Base来决定创建哪些表# checkfirst=True，表示创建表前先检查该表是否存在，如同名表已存在则不再创建。其实默认就是TrueBase.metadata.create_all(engine, checkfirst=True)# 上边的写法会在engine对应的数据库中创建所有继承Base的类对应的表，但很多时候很多只是用来则试的或是其他库的# 此时可以通过tables参数指定方式，指示仅创建哪些表# Base.metadata.create_all(engine,tables=[Base.metadata.tables[&#x27;users&#x27;]],checkfirst=True)# 在项目中由于model经常在别的文件定义，没主动加载时上边的写法可能写导致报错，可使用下边这种更明确的写法# User.__table__.create(engine, checkfirst=True)# 另外我们说这一步的作用是创建表，当我们已经确定表已经在数据库中存在时，我完可以跳过这一步# 针对已存放有关键数据的表，或大家共用的表，直接不写这创建代码更让人心里踏实创建会话# engine是2.2中创建的连接Session = sessionmaker(bind=engine)# 创建Session类实例session = Session()新增# 创建User类实例ed_user = User(name=&#x27;ed&#x27;, fullname=&#x27;Ed Jones&#x27;, password=&#x27;edspassword&#x27;)# 将该实例插入到users表session.add(ed_user)# 一次插入多条记录形式session.add_all( [User(name=&#x27;wendy&#x27;, fullname=&#x27;Wendy Williams&#x27;, password=&#x27;foobar&#x27;), User(name=&#x27;mary&#x27;, fullname=&#x27;Mary Contrary&#x27;, password=&#x27;xxg527&#x27;), User(name=&#x27;fred&#x27;, fullname=&#x27;Fred Flinstone&#x27;, password=&#x27;blah&#x27;)])# 当前更改只是在session中，需要使用commit确认更改才会写入数据库session.commit()查询our_user = session.query(User).filter_by(name=&#x27;ed&#x27;).first()our_user# 比较ed_user与查询到的our_user是否为同一条记录ed_user is our_user# 只获取指定字段# 但要注意如果只获取部分字段，那么返回的就是元组而不是对象了# session.query(User.name).filter_by(name=&#x27;ed&#x27;).all()# like查询# session.query(User).filter(User.name.like(&quot;ed%&quot;)).all()# 正则查询# session.query(User).filter(User.name.op(&quot;regexp&quot;)(&quot;^ed&quot;)).all()# 统计数量# session.query(User).filter(User.name.like(&quot;ed%&quot;)).count()# 调用数据库内置函数# 以count()为例，都是直接func.func_name()这种格式，func_name与数据库内的写法保持一致# from sqlalchemy import func# session.query(func.count(User3.name)).one()# 字段名为字符串形式# column_name = &quot;name&quot;# session.query(User).filter(User3.__table__.columns[column_name].like(&quot;ed%&quot;)).all()# 获取执行的sql语句# 获取记录数的方法有all()/one()/first()等几个方法，如果没加这些方法，得到的只是一个将要执行的sql对象，并没真正提交执行# from sqlalchemy.dialects import mysql# sql_obj = session.query(User).filter_by(name=&#x27;ed&#x27;)# sql_command = sql_obj.statement.compile(dialect=mysql.dialect(), compile_kwargs=&#123;&quot;literal_binds&quot;: True&#125;)# sql_result = sql_obj.all()修改# session.query(User).filter_by(name=&#x27;ed&#x27;).update(&#123;User.password: &#x27;modify_passwd&#x27;&#125;)# session.commit()删除# 要删除需要先将记录查出来del_user = session.query(User).filter_by(name=&#x27;ed&#x27;).first()# 打印一下，确认未删除前记录存在del_user# 将ed用户记录删除session.delete(del_user)# 确认删除session.commit()# 遍历查看，已无ed用户记录for user in session.query(User): print(user)# 但上边的写法，先查询再删除，相当于给mysql服务端发了两条语句，和我们印象中的delete语句不一致# 可直接使用下边的写法，传给服务端的就是delete语句# session.query(User).filter_by(name=&#x27;ed&#x27;).first().delete() 参考 github官方地址：https://github.com/sqlalchemy/sqlalchemy 官方文档地址：https://docs.sqlalchemy.org/en/13/ https://docs.sqlalchemy.org/en/13/orm/tutorial.html","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"win32模块","slug":"Python/pywin32模块","date":"2021-06-07T01:45:07.553Z","updated":"2021-06-07T01:45:07.553Z","comments":true,"path":"wiki/Python/pywin32模块/","link":"","permalink":"http://shjlone.github.io/wiki/Python/pywin32%E6%A8%A1%E5%9D%97/","excerpt":"","text":"Python提供了调用系统级别API的功能，ctype、sip等都可以用来调用C++代码，以此来和系统交互。win32模块提供了调用本地win32 GUI API的接口，使得我们可以更方便的调用系统级别的API。可以做诸如监听全局快捷键、操作任务栏系统图标等功能。 在使用之前，先了解下WIndows常用的API。 1. WIndows API1.1 API之消息函数 函数 作用 BroadcastSystemMessage 将一条系统消息广播给系统中所有的顶级窗口 GetMessagePos 取得消息队列中上一条消息处理完毕时的鼠标指针屏幕位置 GetMessageTime 取得消息队列中上一条消息处理完毕时的时间 PostMessage 将一条消息投递到指定窗口的消息队列 PostThreadMessage 将一条消息投递给应用程序 RegisterWindowMessage 获取分配给一个字串标识符的消息编号 ReplyMessage 答复一个消息 SendMessage 调用一个窗口的窗口函数，将一条消息发给那个窗口 SendMessageCallback 将一条消息发给窗口 SendMessageTimeout 向窗口发送一条消息 SendNotifyMessage 向窗口发送一条消息 1.2 API之控件与消息函数 函数名 作用 AdjustWindowRect 给定一种窗口样式，计算获得目标客户区矩形所需的窗口大小 AnyPopup 判断屏幕上是否存在任何弹出式窗口 ArrangeIconicWindows 排列一个父窗口的最小化子窗口 AttachThreadInput 连接线程输入函数 BeginDeferWindowPos 启动构建一系列新窗口位置的过程 BringWindowToTop 将指定的窗口带至窗口列表顶部 CascadeWindows 以层叠方式排列窗口 ChildWindowFromPoint 返回父窗口中包含了指定点的第一个子窗口的句柄 ClientToScreen 判断窗口内以客户区坐标表示的一个点的屏幕坐标 CloseWindow 最小化指定的窗口 CopyRect 矩形内容复制 DeferWindowPos 该函数为特定的窗口指定一个新窗口位置 DestroyWindow 清除指定的窗口以及它的所有子窗口 DrawAnimatedRects 描绘一系列动态矩形 EnableWindow 指定的窗口里允许或禁止所有鼠标及键盘输入 EndDeferWindowPos 同时更新DeferWindowPos调用时指定的所有窗口的位置及状态 EnumChildWindows 为指定的父窗口枚举子窗口 EnumThreadWindows 枚举与指定任务相关的窗口 EnumWindows 枚举窗口列表中的所有父窗口 EqualRect 判断两个矩形结构是否相同 FindWindow 寻找窗口列表中第一个符合指定条件的顶级窗口 FindWindowEx 在窗口列表中寻找与指定条件相符的第一个子窗口 FlashWindow 闪烁显示指定窗口 GetActiveWindow 获得活动窗口的句柄 GetCapture 获得一个窗口的句柄，这个窗口位于当前输入线程，且拥有鼠标捕获（鼠标活动由它接收） GetClassInfo 取得WNDCLASS结构（或WNDCLASSEX结构）的一个副本，结构中包含了与指定类有关的信息 GetClassLong 取得窗口类的一个Long变量条目 GetClassName 为指定的窗口取得类名 GetClassWord 为窗口类取得一个整数变量 GetClientRect 返回指定窗口客户区矩形的大小 GetDesktopWindow 获得代表整个屏幕的一个窗口（桌面窗口）句柄 GetFocus 获得拥有输入焦点的窗口的句柄 GetForegroundWindow 获得前台窗口的句柄 GetLastActivePopup 获得在一个给定父窗口中最近激活过的弹出式窗口的句柄 GetParent 判断指定窗口的父窗口 GetTopWindow 搜索内部窗口列表，寻找隶属于指定窗口的头一个窗口的句柄 GetUpdateRect 获得一个矩形，它描叙了指定窗口中需要更新的那一部分 GetWindow 获得一个窗口的句柄，该窗口与某源窗口有特定的关系 GetWindowContextHelpId 取得与窗口关联在一起的帮助场景ID GetWindowLong 从指定窗口的结构中取得信息 GetWindowPlacement 获得指定窗口的状态及位置信息 GetWindowRect 获得整个窗口的范围矩形,窗口的边框、标题栏、滚动条及菜单等都在这个矩形内 GetWindowText 取得一个窗体的标题（caption）文字，或者一个控件的内容 GetWindowTextLength 调查窗口标题文字或控件内容的长短 GetWindowWord 获得指定窗口结构的信息 InflateRect 增大或减小一个矩形的大小 IntersectRect 这个函数在 lpDestRect 里载入一个矩形, 它是lpSrc1Rect与lpSrc2Rect两个矩形的交集 InvalidateRect 屏蔽一个窗口客户区的全部或部分区域 IsChild 判断一个窗口是否为另一窗口的子或隶属窗口 IsIconic 判断窗口是否已最小化 IsRectEmpty 判断一个矩形是否为空 IsWindow 判断一个窗口句柄是否有效 IsWindowEnabled 判断窗口是否处于活动状态 IsWindowUnicode 判断一个窗口是否为Unicode窗口。这意味着窗口为所有基于文本的消息都接收Unicode文字 IsWindowVisible 判断窗口是否可见 IsZoomed 判断窗口是否最大化 LockWindowUpdate 锁定指定窗口，禁止它更新 MapWindowPoints 将一个窗口客户区坐标的点转换到另一窗口的客户区坐标系统 MoveWindow 改变指定窗口的位置和大小 OffsetRect 通过应用一个指定的偏移，从而让矩形移动起来 OpenIcon 恢复一个最小化的程序，并将其激活 PtInRect 判断指定的点是否位于矩形内部 RedrawWindow 重画全部或部分窗口 ReleaseCapture 为当前的应用程序释放鼠标捕获 ScreenToClient 判断屏幕上一个指定点的客户区坐标 ScrollWindow 滚动窗口客户区的全部或一部分 ScrollWindowEx 根据附加的选项，滚动窗口客户区的全部或部分 SetActiveWindow 激活指定的窗口 SetCapture 将鼠标捕获设置到指定的窗口 SetClassLong 为窗口类设置一个Long变量条目 SetClassWord 为窗口类设置一个条目 SetFocusAPI 将输入焦点设到指定的窗口。如有必要，会激活窗口 SetForegroundWindow 将窗口设为系统的前台窗口 SetParent 指定一个窗口的新父 SetRect 设置指定矩形的内容 SetRectEmpty 将矩形设为一个空矩形 SetWindowContextHelpId 为指定的窗口设置帮助场景（上下文）ID SetWindowLong 在窗口结构中为指定的窗口设置信息 SetWindowPlacement 设置窗口状态和位置信息 SetWindowPos 为窗口指定一个新位置和状态 SetWindowText 设置窗口的标题文字或控件的内容 SetWindowWord 在窗口结构中为指定的窗口设置信息 ShowOwnedPopups 显示或隐藏由指定窗口所有的全部弹出式窗口 ShowWindow 控制窗口的可见性 ShowWindowAsync 与ShowWindow相似 SubtractRect 装载矩形lprcDst，它是在矩形lprcSrc1中减去lprcSrc2得到的结果 TileWindows 以平铺顺序排列窗口 UnionRect 装载一个lpDestRect目标矩形，它是lpSrc1Rect和lpSrc2Rect联合起来的结果 UpdateWindow 强制立即更新窗口 ValidateRect 校验窗口的全部或部分客户区 WindowFromPoint 返回包含了指定点的窗口的句柄。忽略屏蔽、隐藏以及透明窗口 1.3 API之文本和字体函数 函数名 作用 AddFontResource 在Windows系统中添加一种字体资源 CreateFont 用指定的属性创建一种逻辑字体 CreateFontIndirect 用指定的属性创建一种逻辑字体 CreateScalableFontResource 为一种TureType字体创建一个资源文件，以便能用API函数AddFontResource将其加入Windows系统 DrawText 将文本描绘到指定的矩形中 DrawTextEx 与DrawText相似，只是加入了更多的功能 EnumFontFamilies 列举指定设备可用的字体 EnumFontFamiliesEx 列举指定设备可用的字体 EnumFonts 列举指定设备可用的字体 ExtTextOut 经过扩展的文本描绘函数。也请参考SetTextAlign函数 GetAspectRatioFilterEx 用SetMapperFlags要求Windows只选择与设备当前纵横比相符的光栅字体时，本函数可判断纵横比大小 GetCharABCWidths 判断TureType字体中一个或多个字符的A-B-C大小 GetCharABCWidthsFloat 查询一种字体中一个或多个字符的A-B-C尺寸 GetCharacterPlacement 该函数用于了解如何用一个给定的字符显示一个字串 GetCharWidth 调查字体中一个或多个字符的宽度 GetFontData 接收一种可缩放字体文件的数据 GetFontLanguageInfo 返回目前选入指定设备场景中的字体的信息 GetGlyphOutline 取得TureType字体中构成一个字符的曲线信息 GetKerningPairs 取得指定字体的字距信息 GetOutlineTextMetrics 接收与TureType字体内部特征有关的详细信息 GetRasterizerCaps 了解系统是否有能力支持可缩放的字体 GetTabbedTextExtent 判断一个字串占据的范围，同时考虑制表站扩充的因素 GetTextAlign 接收一个设备场景当前的文本对齐标志 GetTextCharacterExtra 判断额外字符间距的当前值 GetTextCharset 接收当前选入指定设备场景的字体的字符集标识符 GetTextCharsetInfo 获取与当前选定字体的字符集有关的详细信息 GetTextColor 判断当前字体颜色。通常也称为“前景色” GetTextExtentExPoint 判断要填入指定区域的字符数量。也用一个数组装载每个字符的范围信息 GetTextExtentPoint 判断一个字串的大小（范围） GetTextFace 获取一种字体的字样名 GetTextMetrics 获取与选入一种设备场景的物理字体有关的信息 GrayString 描绘一个以灰色显示的字串。通常由Windows用于标识禁止状态 PolyTextOut 描绘一系列字串 RemoveFontResource 从Windows系统中删除一种字体资源 SetMapperFlags Windows 对字体进行映射时，可用该函数选择与目标设备的纵横比相符的光栅字体 SetTextAlign 设置文本对齐方式，并指定在文本输出过程中使用设备场景的当前位置 SetTextCharacterExtra 描绘文本的时候，指定要在字符间插入的额外间距 SetTextColor 设置当前文本颜色。这种颜色也称为“前景色” SetTextJustification 通过指定一个文本行应占据的额外空间，可用这个函数对文本进行两端对齐处理 TabbedTextOut 支持制表站的一个文本描绘函数 TextOut 文本绘图函数 1.4 API之位图、图标和光栅运算函数 函数名 作用 BitBlt 将一幅位图从一个设备场景复制到另一个 CopyIcon 制作指定图标或鼠标指针的一个副本。这个副本从属于发出调用的应用程序 CopyImage 复制位图、图标或指针，同时在复制过程中进行一些转换工作 CreateBitmap 按照规定的格式创建一幅与设备有关位图 CreateBitmapIndirect 创建一幅与设备有关位图 CreateCompatibleBitmap 创建一幅与设备有关位图，它与指定的设备场景兼容 CreateCursor 创建一个鼠标指针 CreateDIBitmap 根据一幅与设备无关的位图创建一幅与设备有关的位图 CreateDIBSection 创建一个DIBSection CreateIcon 创建一个图标 CreateIconIndirect 创建一个图标 DestroyCursor 清除指定的鼠标指针，并释放它占用的所有系统资源 DestroyIcon 清除图标 DrawIcon 在指定的位置画一个图标 DrawIconEx 描绘一个图标或鼠标指针。与DrawIcon相比，这个函数提供了更多的功能 ExtractAssociatedIcon 判断一个可执行程序或DLL中是否存在图标，或是否有图标与系统注册表中指定的文件存在关联并提取之 ExtractIcon 判断一个可执行文件或DLL中是否有图标存在，并将其提取出来 GetBitmapBits 将来自位图的二进制位复制到一个缓冲区 GetBitmapDimensionEx 取得一幅位图的宽度和高度 GetDIBColorTable 从选入设备场景的DIBSection中取得颜色表信息 GetDIBits 将来自一幅位图的二进制位复制到一幅与设备无关的位图里 GetIconInfo 取得与图标有关的信息 GetStretchBltMode 判断StretchBlt 和 StretchDIBits函数采用的伸缩模式 LoadBitmap 从指定的模块或应用程序实例中载入一幅位图 LoadCursor 从指定的模块或应用程序实例中载入一个鼠标指针 LoadCursorFromFile 在一个指针文件或一个动画指针文件的基础上创建一个指针 LoadIcon 从指定的模块或应用程序实例中载入一个图标 LoadImage 载入一个位图、图标或指针 MaskBlt 执行复杂的图象传输，同时进行掩模（MASK）处理 PatBlt 在当前选定的刷子的基础上，用一个图案填充指定的设备场景 PlgBlt 复制一幅位图，同时将其转换成一个平行四边形。利用它可对位图进行旋转处理 SetBitmapBits 将来自缓冲区的二进制位复制到一幅位图 SetBitmapDimensionEx 设置一幅位图的宽度。以一毫米的十分之一为单位 SetDIBColorTable 设置选入设备场景的一个DIBSection的颜色表信息 SetDIBits 将来自与设备无关位图的二进制位复制到一幅与设备有关的位图里 SetDIBitsToDevice 将一幅与设备无关位图的全部或部分数据直接复制到一个设备 SetStretchBltMode 指定StretchBlt 和 StretchDIBits函数的伸缩模式 StretchBlt 将一幅位图从一个设备场景复制到另一个 StretchDIBits 将一幅与设备无关位图的全部或部分数据直接复制到指定的设备场景 1.5 API之菜单函数 函数名 作用 AppendMenu 在指定的菜单里添加一个菜单项 CheckMenuItem 复选或撤消复选指定的菜单条目 CheckMenuRadioItem 指定一个菜单条目被复选成“单选”项目 CreateMenu 创建新菜单 CreatePopupMenu 创建一个空的弹出式菜单 DeleteMenu 删除指定的菜单条目 DestroyMenu 删除指定的菜单 DrawMenuBar 为指定的窗口重画菜单 EnableMenuItem 允许或禁止指定的菜单条目 GetMenu 取得窗口中一个菜单的句柄 GetMenuCheckMarkDimensions 返回一个菜单复选符的大小 GetMenuContextHelpId 取得一个菜单的帮助场景ID GetMenuDefaultItem 判断菜单中的哪个条目是默认条目 GetMenuItemCount 返回菜单中条目（菜单项）的数量 GetMenuItemID 返回位于菜单中指定位置处的条目的菜单ID GetMenuItemInfo 取得（接收）与一个菜单条目有关的特定信息 GetMenuItemRect 在一个矩形中装载指定菜单条目的屏幕坐标信息 GetMenuState 取得与指定菜单条目状态有关的信息 GetMenuString 取得指定菜单条目的字串 GetSubMenu 取得一个弹出式菜单的句柄，它位于菜单中指定的位置 GetSystemMenu 取得指定窗口的系统菜单的句柄 HiliteMenuItem 控制顶级菜单条目的加亮显示状态 InsertMenu 在菜单的指定位置处插入一个菜单条目，并根据需要将其他条目向下移动 InsertMenuItem 插入一个新菜单条目 IsMenu 判断指定的句柄是否为一个菜单的句柄 LoadMenu 从指定的模块或应用程序实例中载入一个菜单 LoadMenuIndirect 载入一个菜单 MenuItemFromPoint 判断哪个菜单条目包含了屏幕上一个指定的点 ModifyMenu 改变菜单条目 RemoveMenu 删除指定的菜单条目 SetMenu 设置窗口菜单 SetMenuContextHelpId 设置一个菜单的帮助场景ID SetMenuDefaultItem 将一个菜单条目设为默认条目 SetMenuItemBitmaps 设置一幅特定位图，令其在指定的菜单条目中使用，代替标准的复选符号（√） SetMenuItemInfo 为一个菜单条目设置指定的信息 TrackPopupMenu 在屏幕的任意地方显示一个弹出式菜单 TrackPopupMenuEx 与TrackPopupMenu 相似，只是它提供了额外的功能 1.6 API之设备场景函数 函数名 作用 CombineRgn 将两个区域组合为一个新区域 CombineTransform 驱动世界转换。它相当于依顺序进行两次转换 CreateCompatibleDC 创建一个与特定设备场景一致的内存设备场景 CreateDC 为专门设备创建设备场景 CreateEllipticRgn 创建一个椭圆 CreateEllipticRgnIndirect 创建一个内切于特定矩形的椭圆区域 CreateIC 为专用设备创建一个信息场景 CreatePolygonRgn 创建一个由一系列点围成的区域 CreatePolyPolygonRgn 创建由多个多边形构成的区域。每个多边形都应是封闭的 CreateRectRgn 创建一个矩形区域 CreateRectRgnIndirect 创建一个矩形区域 CreateRoundRectRgn 创建一个圆角矩形 DeleteDC 删除专用设备场景或信息场景，释放所有相关窗口资源 DPtoLP 将点阵从设备坐标转换到专用设备场景逻辑坐标 EqualRgn 确定两个区域是否相等 ExcludeClipRect 从专用设备场景的剪裁区中去掉一个矩形区。矩形内不能进行绘图 ExcludeUpdateRgn 从专用设备场景剪裁区去掉指定窗口的刷新区域 ExtCreateRegion 根据世界转换修改区域 ExtSelectClipRgn 将指定区域组合到设备场景的当前剪裁区 FillRgn 用指定刷子填充指定区域 FrameRgn 用指定刷子围绕指定区域画一个外框 GetBoundsRect 获取指定设备场景的边界矩形 GetClipBox 获取完全包含指定设备场景剪裁区的最小矩形 GetClipRgn 获取设备场景当前剪裁区 GetDC 获取指定窗口的设备场景 GetDCEx 为指定窗口获取设备场景。相比GetDC，本函数提供了更多的选项 GetDCOrgEx 获取指定设备场景起点位置（以屏幕坐标表示） GetDeviceCaps 根据指定设备场景代表的设备的功能返回信息 GetGraphicsMode 确定是否允许增强图形模式（世界转换） GetMapMode 为特定设备场景调入映象模式 GetRegionData 装入描述一个区域信息的RgnData结构或缓冲区 GetRgnBox 获取完全包含指定区域的最小矩形 GetUpdateRgn 确定指定窗口的刷新区域。该区域当前无效，需要刷新 GetViewportExtEx 获取设备场景视口（viewport）范围 GetViewportOrgEx 获取设备场景视口起点 GetWindowDC 获取整个窗口（包括边框、滚动条、标题栏、菜单等）的设备场景 GetWindowExtEx 获取指定设备场景的窗口范围 GetWindowOrgEx 获取指定设备场景的逻辑窗口的起点 GetWindowRgn 获取窗口区域 GetWorldTransform 如果有世界转换，为设备场景获取当前世界转换 IntersectClipRect 为指定设备定义一个新的剪裁区 InvalidateRgn 使窗口指定区域不活动，并将它加入窗口刷新区，使之可随后被重画 InvertRgn 通过颠倒每个像素值反转设备场景指定区域 LPtoDP 将点阵从指定设备场景逻辑坐标转换为设备坐标 ModifyWorldTransform 根据指定的模式修改世界转换 OffsetClipRgn 按指定量平移设备场景剪裁区 OffsetRgn 按指定偏移量平移指定区域 OffsetViewportOrgEx 平移设备场景视口区域 OffsetWindowOrgEx 平移指定设备场景窗口起点 PaintRgn 用当前刷子背景色填充指定区域 PtInRegion 确定点是否在指定区域内 PtVisible 确定指定点是否可见（即，点是否在设备场景剪裁区内） RectInRegion 确定矩形是否有部分在指定区域内 RectVisible 确定指定矩形是否有部分可见（是否在设备场景剪裁区内） ReleaseDC 释放由调用GetDC或GetWindowDC函数获取的指定设备场景 RestoreDC 从设备场景堆栈恢复一个原先保存的设备场景 SaveDC 将指定设备场景状态保存到Windows设备场景堆栈 ScaleViewportExtEx 缩放设备场景视口的范围 ScaleWindowExtEx 缩放指定设备场景窗口范围 ScrollDC 在窗口（由设备场景代表）中水平和（或）垂直滚动矩形 SelectClipRgn 为指定设备场景选择新的剪裁区 SetBoundsRect 设置指定设备场景的边界矩形 SetGraphicsMode 允许或禁止增强图形模式，以提供某些支持（包括世界转换） SetMapMode 设置指定设备场景的映射模式 SetRectRgn 设置区域为指定的矩形 SetViewportExtEx 设置设备场景视口范围 SetViewportOrgEx 设置设备场景视口起点 SetWindowExtEx 设置指定设备场景窗口范围 SetWindowOrgEx 设置指定设备场景窗口起点 SetWindowRgn 设置窗口区域 SetWorldTransform 设置世界转换 ValidateRgn 激活窗口中指定区域，把它从刷新区移走 WindowFromDC 取回与某一设备场景相关的窗口的句柄 1.7 API之进程和线程函数 函数名 作用 CancelWaitableTimer 这个函数用于取消一个可以等待下去的计时器操作 CallNamedPipe 这个函数由一个希望通过管道通信的一个客户进程调用 ConnectNamedPipe 指示一台服务器等待下去，直至客户机同一个命名管道连接 CreateEvent 创建一个事件对象 CreateMailslot 创建一个邮路。返回的句柄由邮路服务器使用（收件人） CreateMutex 创建一个互斥体（MUTEX） CreateNamedPipe 创建一个命名管道。返回的句柄由管道的服务器端使用 CreatePipe 创建一个匿名管道 CreateProcess 创建一个新进程（比如执行一个程序） CreateSemaphore 创建一个新的信号机 CreateWaitableTimer 创建一个可等待的计时器对象 DisconnectNamedPipe 断开一个客户与一个命名管道的连接 DuplicateHandle 在指出一个现有系统对象当前句柄的情况下，为那个对象创建一个新句柄 ExitProcess 中止一个进程 FindCloseChangeNotification 关闭一个改动通知对象 FindExecutable 查找与一个指定文件关联在一起的程序的文件名 FindFirstChangeNotification 创建一个文件通知对象。该对象用于监视文件系统发生的变化 FindNextChangeNotification 重设一个文件改变通知对象，令其继续监视下一次变化 FreeLibrary 释放指定的动态链接库 GetCurrentProcess 获取当前进程的一个伪句柄 GetCurrentProcessId 获取当前进程一个唯一的标识符 GetCurrentThread 获取当前线程的一个伪句柄 GetCurrentThreadId 获取当前线程一个唯一的线程标识符 GetExitCodeProces 获取一个已中断进程的退出代码 GetExitCodeThread 获取一个已中止线程的退出代码 GetHandleInformation 获取与一个系统对象句柄有关的信息 GetMailslotInfo 获取与一个邮路有关的信息 GetModuleFileName 获取一个已装载模板的完整路径名称 GetModuleHandle 获取一个应用程序或动态链接库的模块句柄 GetPriorityClass 获取特定进程的优先级别 GetProcessShutdownParameters 调查系统关闭时一个指定的进程相对于其它进程的关闭早迟情况 GetProcessTimes 获取与一个进程的经过时间有关的信息 GetProcessWorkingSetSize 了解一个应用程序在运行过程中实际向它交付了多大容量的内存 GetSartupInfo 获取一个进程的启动信息 GetThreadPriority 获取特定线程的优先级别 GetTheardTimes 获取与一个线程的经过时间有关的信息 GetWindowThreadProcessId 获取与指定窗口关联在一起的一个进程和线程标识符 LoadLibrary 载入指定的动态链接库，并将它映射到当前进程使用的地址空间 LoadLibraryEx 装载指定的动态链接库，并为当前进程把它映射到地址空间 LoadModule 载入一个Windows应用程序，并在指定的环境中运行 MsgWaitForMultipleObjects 等侯单个对象或一系列对象发出信号。如返回条件已经满足，则立即返回 SetPriorityClass 设置一个进程的优先级别 SetProcessShutdownParameters 在系统关闭期间，为指定进程设置他相对于其它程序的关闭顺序 SetProcessWorkingSetSize 设置操作系统实际划分给进程使用的内存容量 SetThreadPriority 设定线程的优先级别 ShellExecute 查找与指定文件关联在一起的程序的文件名 TerminateProcess 结束一个进程 WinExec 运行指定的程序 1.7 API之网络函数 函数名 作用 WNetAddConnection 创建同一个网络资源的永久性连接 WNetAddConnection2 创建同一个网络资源的连接 WNetAddConnection3 创建同一个网络资源的连接 WNetCancelConnection 结束一个网络连接 WNetCancelConnection2 结束一个网络连接 WNetCloseEnum 结束一次枚举操作 WNetConnectionDialog 启动一个标准对话框，以便建立同网络资源的连接 WNetDisconnectDialog 启动一个标准对话框，以便断开同网络资源的连接 WNetEnumResource 枚举网络资源 WNetGetConnection 获取本地或已连接的一个资源的网络名称 WNetGetLastError 获取网络错误的扩展错误信息 WNetGetUniversalName 获取网络中一个文件的远程名称以及/或者UNC（统一命名规范）名称 WNetGetUser 获取一个网络资源用以连接的名字 WNetOpenEnum 启动对网络资源进行枚举的过程 2. 安装和基本使用2.1 安装1python -m pip install pypiwin32 2.2 基本使用123456789101112131415161718192021hwnd = win32gui.FindWindow(&quot;类名&quot;, &quot;标题名&quot;) # 使用spy++查询窗口句柄的信息# 修改窗口大小win32gui.MoveWindow(hwnd, 100, 100, 200, 200, True) # 设置前台后台win32gui.SetForegroundWindow(hwnd)win32gui.SetBkMode(hwnd, win32con.TRANSPARENT)# 获取鼠标当前坐标win32api.GetCursorPos()# 将鼠标移动到某坐标处win32api.SetCursorPos((100,100))# 通过坐标获取句柄win32api.WindowFromPoint(win32api.GetCursorPos())# 根据窗口句柄id获取ClassNamewin32gui.GetClassName(hwnd)# 获取窗口标题win32gui.GetWindowText(hwnd)# 获取窗口坐标win32gui.GetWindowRect(hwnd)# 模拟点击win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 200, 200, 0, 0) 使用管理员权限启动python脚本12345678910111213141516171819202122232425262728def admin(func): def wrap(): def is_admin(): try: return ctypes.windll.shell32.IsUserAnAdmin() except: return False if is_script(): func() elif is_admin(): func() else: params = &#x27; &#x27;.join([&#x27;&quot;&#123;&#125;&quot;&#x27;.format(x) for x in sys.argv]) # 将启动参数传递给脚本 ctyps.windll.shell32.ShellExecuteW(None, &#x27;runas&#x27;, sys.executable, params, None, 1) return wrap### main.py@admindef main(): print(&#x27;init&#x27;)if __name__ == &#x27;__main__&#x27;: main() 参考 http://timgolden.me.uk/pywin32-docs/contents.html https://www.cnblogs.com/zoro-robin/p/5591185.html Shell_NotifyIcon Windows常用API","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"stockstats","slug":"Python/stockstats","date":"2021-06-07T01:45:07.553Z","updated":"2021-06-07T01:45:07.553Z","comments":true,"path":"wiki/Python/stockstats/","link":"","permalink":"http://shjlone.github.io/wiki/Python/stockstats/","excerpt":"","text":"对pandas进行了封装 https://github.com/jealous/stockstats","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"struct模块","slug":"Python/struct模块","date":"2021-06-07T01:45:07.553Z","updated":"2021-06-07T01:45:07.553Z","comments":true,"path":"wiki/Python/struct模块/","link":"","permalink":"http://shjlone.github.io/wiki/Python/struct%E6%A8%A1%E5%9D%97/","excerpt":"","text":"struct模块主要二进制和结构体之间的互相转化。在业务场景中，socket数据的处理会使用到。纯文本是无法进行传输到，因为不同系统硬件的存储方式是不一样的。这个时候使用struct可以按照某种规则进行pack处理成二进制数据，另一端接收到时按照约定进行unpack成相应数据。 常用API 函数 return explain pack(fmt,v1,v2…) string 按照给定的格式(fmt),把数据转换成字符串(字节流),并将该字符串返回. pack_into(fmt,buffer,offset,v1,v2…) None 按照给定的格式(fmt),将数据转换成字符串(字节流),并将字节流写入以offset开始的buffer中.(buffer为可写的缓冲区,可用array模块) unpack(fmt,v1,v2…..) tuple 按照给定的格式(fmt)解析字节流,并返回解析结果 pack_from(fmt,buffer,offset) tuple 按照给定的格式(fmt)解析以offset开始的缓冲区,并返回解析结果 calcsize(fmt) size of fmt 计算给定的格式(fmt)占用多少字节的内存，注意对齐方式 Hello Worldvalues = (1, b&#39;abc&#39;, 2.5) s = struct.Struct(&#39;I3sf&#39;) # 声明每个值的类型，I表示整型、3s表示长度为3的字符串、f表示浮点型 packed_data = s.pack(*values) print(packed_data) unpacked_data = s.unpack(packed_data) print(type(unpacked_data), unpacked_data) 字节顺序，大小，对齐默认情况下，C语言类型以机器的本地格式和字节顺序表示。 Character（字符） Byte order（字节顺序） Size Alignment @(默认) 本机 本机 本机,凑够4字节 = 本机 标准 none,按原字节数 &lt; 小端 标准 none,按原字节数 &gt; 大端 标准 none,按原字节数 ! network(大端) 标准 none,按原字节数 格式字符 文件格式 C 类型 Python数据类型 Standard size 注释 x pad byte no value c char bytes of length 1 1 b signed char integer 1 (1),(3) B unsigned char integer 1 (3) ? _Bool bool 1 (1) h short integer 2 (3) H unsigned short integer 2 (3) i int integer 4 (3) I unsigned int integer 4 (3) l long integer 4 (3) L unsigned long integer 4 (3) q long long integer 8 (2), (3) Q unsigned long long integer 8 (2), (3) n ssize_t integer (4) N size_t integer (4) e (7) float 2 (5) f float float 4 (5) d double float 8 (5) s char[] bytes p char[] bytes P void * integer (6) 实例：12 参考 https://docs.python.org/zh-cn/3.7/library/struct.html https://docs.python.org/3/library/struct.html","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"tornado","slug":"Python/tornado","date":"2021-06-07T01:45:07.553Z","updated":"2021-06-07T01:45:07.553Z","comments":true,"path":"wiki/Python/tornado/","link":"","permalink":"http://shjlone.github.io/wiki/Python/tornado/","excerpt":"","text":"基本API使用Application RequestHandler 参考https://tornado-zh.readthedocs.io/zh/latest/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"Python虚拟环境配置","slug":"Python/Python虚拟环境配置","date":"2021-06-07T01:45:07.552Z","updated":"2021-06-10T10:10:09.623Z","comments":true,"path":"wiki/Python/Python虚拟环境配置/","link":"","permalink":"http://shjlone.github.io/wiki/Python/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"虚拟环境的用途不需要完整的安装一遍依赖库，类似gradle的版本管理。比如你需要同时使用Rx1.6和Rx3.1，要么整两份Python环境，要么使用Virtualenv。 PyCharm中使用 选择File-&gt;New Project 选择Pure Python，点击Project Interpreter：New Virtualenv environment 选择依赖的解释器，勾选Inherit global site-packages，这样会继承原来的第三方库，勾选Make available to all projects，所有的项目都可用。 使用Python命令12345678910111213安装virtualenvpip install virtualenv安装虚拟环境，同时将原有依赖添加到虚拟环境中virtualenv --system-site-packages venv安装虚拟环境，不添加任务依赖，默认值virtualenv --no-site-packages venv在Scripts目录中activate命令可进行交互模式deactivate退出交互模式 参考 https://www.jianshu.com/p/dcb281ee564e https://virtualenv.pypa.io/en/latest/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"RxPY学习笔记","slug":"Python/RxPy学习笔记","date":"2021-06-07T01:45:07.552Z","updated":"2021-06-07T01:45:07.552Z","comments":true,"path":"wiki/Python/RxPy学习笔记/","link":"","permalink":"http://shjlone.github.io/wiki/Python/RxPy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"基本概念参考这里，Python的版本也是根据这些概念，通过使用自己的特性实现。但由于种种原因，Python的不同版本间变化很大。可以参考这里。 基本的用法可以参考文档和源码中的test，这里只记录一些自己遇到的问题和解决方案 官方使用文档翻译 安装如果使用V3.x版本： 1pip install rx 如果使用1.6的版本 1pip install rx==1.6.1 基本概念RXPY，使用可观察序列，查询操作符组合，可异步化，基于事件的一套Python库。使用Rx，开发者可以使用Observables来表示异步数据流，使用operators查询异步数据流，使用Schedulers对数据/事件流进行异步参数化。 使用Rx，你可以表示多个异步数据流，使用观察者（Observer）对象来订阅（subscribe）事件流。当事件发生时可观察者（Observable）通知订阅者。你可以在Observable和Observer之间放置各种转换。 因为Observable队列是数据流，你可以使用相关操作符进行链式操作。你可以filter，map，reduce，compose，基于时间的操作，等等。除此之外，还有许多其他特定于响应流的操作符允许编写功能强大的查询。取消、异常和同步也可以通过专用的操作符处理。 开始Observable是ReactiveX的核心类型。它串行的添加元素，像排放系统一样，通过一系列的操作直到最后传递到Observer，在那里它们被消费。 基于推(而不是基于拉)的迭代为表达代码和并发提供了强大的新可能性。因为一个Observable将事件当作数据，也将数据当作事件。 有很多种方式创建Obserable，你可以使用create（）工厂方法，传递一个函数给他。 - on_next在Observable发射一个元素时被调用 - on_completed在Obserable完成时被调用 - on_error在Obserable发生错误时被调用 这三个回调是可选的。 让我们看一个例子： 123456789101112131415161718from rx import createdef push_five_strings(observer, scheduler): observer.on_next(&quot;Alpha&quot;) observer.on_next(&quot;Beta&quot;) observer.on_next(&quot;Gamma&quot;) observer.on_next(&quot;Delta&quot;) observer.on_next(&quot;Epsilon&quot;) observer.on_completed()source = create(push_five_strings)source.subscribe( on_next = lambda i: print(&quot;Received &#123;0&#125;&quot;.format(i)), on_error = lambda e: print(&quot;Error Occurred: &#123;0&#125;&quot;.format(e)), on_completed = lambda: print(&quot;Done!&quot;),) Observable通过create创建，push_five_strings被调用。这个函数发射了五个元素。subscribe中实现了三个回调函数。输出结果为： 123456Received AlphaReceived BetaReceived GammaReceived DeltaReceived EpsilonDone! of工厂函数，接收list参数，会依此发射它们，如果忽略completion和error，subscribe可以支传一个参数 12345678910111213141516from rx import ofsource = of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;)source.subscribe( on_next = lambda i: print(&quot;Received &#123;0&#125;&quot;.format(i)), on_error = lambda e: print(&quot;Error Occurred: &#123;0&#125;&quot;.format(e)), on_completed = lambda: print(&quot;Done!&quot;),)输出结果：Received AlphaReceived BetaReceived GammaReceived DeltaReceived Epsilon 操作符和链接你可以使用超过130个操作符来导出新的Observables，每个操作符会生产一个Observable，它会以管道的形式改变原来的Observable。比如，我们使用map()处理每个字符串的长度，然后filter()来过滤长度超过5的元素。 123456789101112131415from rx import of, operators as opsource = of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;)composed = source.pipe( op.map(lambda s: len(s)), op.filter(lambda i: i &gt;= 5))composed.subscribe(lambda value: print(&quot;Received &#123;0&#125;&quot;.format(value)))Received 5Received 5Received 5Received 7 还可以使用以下方式将整个操作链接起来，还能减少临时变量的产生 123456from rx import of, operators as opof(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;).pipe( op.map(lambda s: len(s)), op.filter(lambda i: i &gt;= 5)).subscribe(lambda value: print(&quot;Received &#123;0&#125;&quot;.format(value))) 自定义操作符随着操作符链的发展，为了提高代码的可读性，须对链进行拆分。新的操作符被实现为函数，可以直接在管道操作符中使用。当一个操作符被实现为其他操作符的组合时，由于管道函数的存在，实现非常简单 123456789101112import rxfrom rx import operators as opsdef length_more_than_5(): return rx.pipe( ops.map(lambda s: len(s)), ops.filter(lambda i: i &gt;= 5), )rx.of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;).pipe( length_more_than_5()).subscribe(lambda value: print(&quot;Received &#123;0&#125;&quot;.format(value))) 也可以自己创建一个操作符，以下操作符实现了将字符串转换为小写的功能 12345678910111213141516171819import rxdef lowercase(): def _lowercase(source): def subscribe(observer, scheduler = None): def on_next(value): observer.on_next(value.lower()) return source.subscribe( on_next, observer.on_error, observer.on_completed, scheduler) return rx.create(subscribe) return _lowercaserx.of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;).pipe( lowercase() ).subscribe(lambda value: print(&quot;Received &#123;0&#125;&quot;.format(value))) 并发控制为了实现并发，你要使用两个操作符：subscribe_on和observe_on。两者都需要Scheduler来提供线程给订阅者工作。ThreadPoolScheduler是一个重用线程的好选择。 GIL可能会破坏并发性能，因为它阻止多个线程同时访问同一行代码。像NumPy这样的库可以在释放GIL时减轻这种并行密集计算的负担。RxPy还可以在某种程度上减少线程重叠。一定要用并发性测试您的应用程序，并确保有性能增益. subscribe_on()指示链开始处的源Observable序使用哪个调度器(不管您将该操作符放在哪里)。不过，observe_on()会在这个时候切换到不同的调度程序，有效地将发射从一个线程转移到另一个线程。一些工厂函数和操作符，如interval()和delay()，已经有了默认的调度程序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import multiprocessingimport randomimport timefrom threading import current_threadimport rxfrom rx.scheduler import ThreadPoolSchedulerfrom rx import operators as opsdef intense_calculation(value): # sleep for a random short duration between 0.5 to 2.0 seconds to simulate a long-running calculation time.sleep(random.randint(5, 20) * 0.1) return value# calculate number of CPUs, then create a ThreadPoolScheduler with that number of threadsoptimal_thread_count = multiprocessing.cpu_count()pool_scheduler = ThreadPoolScheduler(optimal_thread_count)# Create Process 1rx.of(&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;).pipe( ops.map(lambda s: intense_calculation(s)), ops.subscribe_on(pool_scheduler)).subscribe( on_next=lambda s: print(&quot;PROCESS 1: &#123;0&#125; &#123;1&#125;&quot;.format(current_thread().name, s)), on_error=lambda e: print(e), on_completed=lambda: print(&quot;PROCESS 1 done!&quot;),)# Create Process 2rx.range(1, 10).pipe( ops.map(lambda s: intense_calculation(s)), ops.subscribe_on(pool_scheduler)).subscribe( on_next=lambda i: print(&quot;PROCESS 2: &#123;0&#125; &#123;1&#125;&quot;.format(current_thread().name, i)), on_error=lambda e: print(e), on_completed=lambda: print(&quot;PROCESS 2 done!&quot;),)# Create Process 3, which is infiniterx.interval(1).pipe( ops.map(lambda i: i * 100), ops.observe_on(pool_scheduler), ops.map(lambda s: intense_calculation(s)),).subscribe( on_next=lambda i: print(&quot;PROCESS 3: &#123;0&#125; &#123;1&#125;&quot;.format(current_thread().name, i)), on_error=lambda e: print(e),)input(&quot;Press any key to exit\\n&quot;) IO异步 许多异步框架都支持IO异步，RxPY中使用相关连的schedulers。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from collections import namedtupleimport asyncioimport rximport rx.operators as opsfrom rx.subject import Subjectfrom rx.scheduler.eventloop import AsyncIOSchedulerEchoItem = namedtuple(&#x27;EchoItem&#x27;, [&#x27;future&#x27;, &#x27;data&#x27;])def tcp_server(sink, loop): def on_subscribe(observer, scheduler): async def handle_echo(reader, writer): print(&quot;new client connected&quot;) while True: data = await reader.readline() data = data.decode(&quot;utf-8&quot;) if not data: break future = asyncio.Future() observer.on_next(EchoItem( future=future, data=data )) await future writer.write(future.result().encode(&quot;utf-8&quot;)) print(&quot;Close the client socket&quot;) writer.close() def on_next(i): i.future.set_result(i.data) print(&quot;starting server&quot;) server = asyncio.start_server(handle_echo, &#x27;127.0.0.1&#x27;, 8888, loop=loop) loop.create_task(server) sink.subscribe( on_next=on_next, on_error=observer.on_error, on_completed=observer.on_completed) return rx.create(on_subscribe)loop = asyncio.get_event_loop()proxy = Subject()source = tcp_server(proxy, loop)aio_scheduler = AsyncIOScheduler(loop=loop)source.pipe( ops.map(lambda i: i._replace(data=&quot;echo: &#123;&#125;&quot;.format(i.data))), ops.delay(5.0)).subscribe(proxy, scheduler=aio_scheduler)loop.run_forever()print(&quot;done&quot;)loop.close() 默认的Scheduler 有多种方式选额scheduler。第一种是给操作符提供scheduler。但当有多个操作符时，可能会被忽略。所以第二种方式时提供默认的scheduler。 123source.pipe( ...).subscribe(proxy, scheduler=my_default_scheduler) 操作符选择scheduler的方式如下： 如果给操作符提供了scheduler，选择它 如果默认scheduler有提供，选择它 否则选择自带的 迁移https://rxpy.readthedocs.io/en/latest/migration.html 从RxPY v1迁移到v3 操作符创建Observable 操作符 | 描述|— | —|create | 创建一个Observableempty | 创建空的Obserbale，发射空元素，马上结束never |throw | 创建一个立马抛出错误的Observablefrom_ | 转换其他数据或对象给Observableinterval | 创建一个间隔执行的Observablejust |range | 创建一个整数队列的Observablerepeat_value | 重复发送特殊元素或队列元素start |timer | 转换Observables 操作符 | 描述|— | —|buffer |flat_map |group_by |map |scan |window | 过滤Observables 操作符 描述 debounce distinct element_at filter first ignore_elements last sample skip skip_last take take_last 结合Observables 操作符 描述 combine_latest join merge start_with switch_latest zip 错误处理 操作符 描述 catch retry 实用操作符 操作符 描述 delay do materizlize dematerialize observe_on subscribe subscribe_on time_interval timeout timestamp 条件和布尔操作符 操作符 描述 all amb contains default_if_empty sequence_equal skip_until skip_while take_until take_while 数学相关操作符 操作符 描述 average concat count max min reduce sum 可连接Observable操作符 操作符 描述 connect publish ref_count replay 额外的阅读RxPY源码仓库包含实例notebooks ReactiveX官方地址和文档： Introduction Tutorials Operators 一些商业内容可以免费获得它们相关联的示例代码 Packt Reactive Programming in Python RxPY 3.0.0取消了对backpressure的支持，以下是已知的支持backpress的社区项目 rxbackpressure rxpy extension rxpy_backpressure observer decorators 商业资源 O’Reilly Video O’Reilly has published the video Reactive Python for Data Science which is available on both the O’Reilly Store as well as O’Reilly Safari. This video teaches RxPY from scratch with applications towards data science, but should be helpful for anyone seeking to learn RxPY and reactive programming. Packt Video Packt has published the video Reactive Programming in Python, available on Packt store. This video teaches how to write reactive GUI and network applications. 如何在PyQt5中使用scheduler，在非主线程中执行某个操作，然后回到UI线程执行另一个操作。12345rx.from_list([1, 2, 3, 4]).pipe(operators.map(add), operators.subscribe_on(pool_scheduler), operators.observe_on(QtThreadSafeScheduler(QtCore))).subscribe( on_next=lambda i: print(&quot;PROCESS 3: &#123;0&#125; &#123;1&#125;&quot;.format(threading.current_thread().name, i)), on_error=lambda e: print(e), on_completed=lambda: print(&quot;Done!&quot;) ) 其中的QtThreadScheduler来自于https://github.com/jcafhe/RxPY 参考 Github官方地址 文档 https://rxmarbles.com","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"CFFI笔记","slug":"Python/cffi笔记","date":"2021-06-07T01:45:07.552Z","updated":"2021-06-07T01:45:07.552Z","comments":true,"path":"wiki/Python/cffi笔记/","link":"","permalink":"http://shjlone.github.io/wiki/Python/cffi%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"ctypes模块","slug":"Python/ctypes","date":"2021-06-07T01:45:07.552Z","updated":"2021-06-07T01:45:07.552Z","comments":true,"path":"wiki/Python/ctypes/","link":"","permalink":"http://shjlone.github.io/wiki/Python/ctypes/","excerpt":"","text":"ctypes 是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。 Hello World 编写C文件 编译C文件 编写Python文件、测试 1. 编写C文件1234567#include &lt;stdio.h&gt;int hello(const char* name) &#123; printf(&quot;~~~hello %s ! \\n&quot;, name); return 0;&#125; 2. 编译C文件不同平台生成不同格式的动态库，windows下为dll，linux下为so gcc -fPIC -shared hello_module.c -o hello_module.dylib 3. 编写Python文件123456import ctypesfrom ctypes import c_char_plib = ctypes.cdll.LoadLibrary(&quot;hello_module.dylib&quot;)lib.hello(c_char_p(bytes(&quot;world&quot;, &quot;utf-8&quot;))) 类型映射关系 ctypes C 类型 Python类型 c_bool _Bool bool (1) c_char char 单字符字节对象 c_wchar wchar_t 单字符字符串 c_byte char int c_ubyte unsigned char int c_short short int c_ushort unsigned short int c_int int int c_uint unsigned int int c_long long int c_ulong unsigned long int c_longlong __int64 或 long long int c_ulonglong unsigned __int64 或 unsigned long long int c_size_t size_t int c_ssize_t ssize_t 或 Py_ssize_t int c_float float float c_double double float c_longdouble long double float c_char_p char * (NUL terminated) 字节串对象或 None c_wchar_p wchar_t * (NUL terminated) 字符串或 None c_void_p void * int 或 None 回调函数1234567891011121314151617181920212223242526272829############## main.c ###############include &lt;stdint.h&gt;#include &lt;stdio.h&gt;struct mes_t&#123; uint32_t field1; uint32_t field2; void* data;&#125;;typedef int function_callback(struct mes_t* message );function_callback* my_callback;int function_one(function_callback fcb)&#123; //Set to a global variable for later use my_callback = fcb; //Declare object in stack struct mes_t mes; mes.field1 = 132; mes.field2 = 264; mes.data = NULL; //Pass pointer of object in stack, and print the return value printf(&quot;Got from python: %d\\n&quot;, my_callback( &amp;mes ) );&#125; 123456789101112131415161718192021222324252627282930313233############ main.py ################import ctypestestlib = ctypes.CDLL(&#x27;./testlib.so&#x27;)#Declare the data structureclass mes_t(ctypes.Structure): _fields_ = ( (&#x27;field1&#x27;, ctypes.c_uint32), (&#x27;field2&#x27;, ctypes.c_uint32), (&#x27;data&#x27;, ctypes.c_void_p))#Declare the callback type, since that is not stored in the librarycallback_type = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.POINTER(mes_t) )def the_callback(mes_p): #dereference the pointer my_mes = mes_p[0] print &quot;I got a mes_t object! mes.field1=%r, mes.field2=%r, mes.data=%r&quot; \\ % (my_mes.field1, my_mes.field2, my_mes.data) #Return some random value return 999#Let the library know about the callback function by calling &quot;function_one&quot;result = testlib.function_one(callback_type(the_callback) )#########################gcc -shared -o testlib.so -fPIC main.cpython main.py 参考：http://blog.sina.com.cn/s/blog_6e22d8fb0102y462.html 线程状态和GILPython解释器不是完全线程安全的。为了支持多线程Python程序，有一个全局锁，称为global interpreter lock或GIL，它必须由当前线程持有才能安全访问Python对象。没有锁，即使最简单的操作也可能导致多线程程序中的问题：例如，当两个线程同时增加同一对象的引用计数时，引用计数可能最终只增加一次而不是两次。 释放GIL123Py_BEGIN_ALLOW_THREADS... Do some blocking I/O operation ...Py_END_ALLOW_THREADS 非Python创建的线程当使用专用的Python API（例如threading模块）创建线程时，线程状态会自动关联到它们，因此上面显示的代码是正确的。但是，当从C创建线程时（例如由具有自己的线程管理的第三方库），它们不持有GIL，也没有线程状态结构。 如果你需要从这些线程调用Python代码（通常这将是上述第三方库提供的回调API的一部分），你必须首先通过创建线程状态数据结构来注册这些线程和解释器，然后获取GIL，最后存储他们的线程状态指针，然后才能开始使用Python / C API。当你完成后，你应该重置线程状态指针，释放GIL，最后释放线程状态数据结构。 123456789PyGILState_STATE gstate;gstate = PyGILState_Ensure();/* Perform Python actions here. */result = CallSomeFunction();/* evaluate result or handle exception *//* Release the thread. No Python API allowed beyond this point. */PyGILState_Release(gstate); 释放GIL和非python创建的线程中调用python函数都没有测试成功… 参考 http://icejoywoo.github.io/2018/12/10/intro-python-ctyps.html https://anribras.github.io/tech/2019/01/03/python-ctypes%E6%80%BB%E7%BB%93/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"json解析库选择和使用","slug":"Python/json解析库选择和使用","date":"2021-06-07T01:45:07.552Z","updated":"2021-06-07T01:45:07.552Z","comments":true,"path":"wiki/Python/json解析库选择和使用/","link":"","permalink":"http://shjlone.github.io/wiki/Python/json%E8%A7%A3%E6%9E%90%E5%BA%93%E9%80%89%E6%8B%A9%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"比较 simplejson：django的内置模块，如果没有C扩展加速，效率极其低下。 rapidjson： ujson：使用C语言实现 orjson：使用Rust语言实现 测试代码 12345678910111213141516171819202122232425262728from time import timeimport sysimport string num = int(sys.argv[1])lib = sys.argv[2] items = []for i in range(num): items.append(&#123;c:c for c in string.ascii_letters&#125;) start = time()if lib == &#x27;ujson&#x27;: import ujson ujson.dumps(items)elif lib == &#x27;rapidjson&#x27;: import rapidjson rapidjson.dumps(items)elif lib == &#x27;orjson&#x27;: import orjson orjson.dumps(items)else: import json json.dumps(items) print(time() - start)&gt;&gt;python 1000|10000|100000|1000000 json|ujson|rapidjson|orjson orjsongithub地址 安装 首先安装rust，从rust官网下载rustup-init.exe安装程序。选择安装nightly类型。参考。 安装orjson，pip install orjson 注意 orjson is tested for amd64 and aarch64 on Linux, macOS, and Windows. It may not work on 32-bit targets. ujson安装需要依赖C&amp;C++编译环境，参考https://github.com/statsmodels/statsmodels/issues/4160 参考 https://yanbin.blog/python-json-choose-ujson-if-necessary/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"pandas","slug":"Python/pandas","date":"2021-06-07T01:45:07.552Z","updated":"2021-06-07T01:45:07.552Z","comments":true,"path":"wiki/Python/pandas/","link":"","permalink":"http://shjlone.github.io/wiki/Python/pandas/","excerpt":"","text":"数据分析清洗使用pandas，numpy。 http://pandas.pydata.org/ https://www.pypandas.cn/ Series 是带标签的一维数组，可存储整数、浮点数、字符串、Python 对象等类型的数据。轴标签统称为索引。调用 pd.Series 函数即可创建 Series 1s = pd.Series(data, index=index) 上述代码中，data 支持以下数据类型： Python 字典 多维数组 标量值（如，5） index 是轴标签列表。不同数据可分为以下几种情况： 多维数组 data 是多维数组时，index 长度必须与 data 长度一致。没有指定 index 参数时，创建数值型索引，即 [0, …, len(data) - 1]。 12345678910111213141516171819202122In [3]: s = pd.Series(np.random.randn(5), index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;])In [4]: sOut[4]: a 0.469112b -0.282863c -1.509059d -1.135632e 1.212112dtype: float64In [5]: s.indexOut[5]: Index([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], dtype=&#x27;object&#x27;)In [6]: pd.Series(np.random.randn(5))Out[6]: 0 -0.1732151 0.1192092 -1.0442363 -0.8618494 -2.104569dtype: float64 字典 12345678In [7]: d = &#123;&#x27;b&#x27;: 1, &#x27;a&#x27;: 0, &#x27;c&#x27;: 2&#125;In [8]: pd.Series(d)Out[8]: b 1a 0c 2dtype: int64 标量值 data 是标量值时，必须提供索引。Series 按索引长度重复该标量值。 12345678In [12]: pd.Series(5., index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;])Out[12]: a 5.0b 5.0c 5.0d 5.0e 5.0dtype: float64 Series类似多维数组 1234567891011121314151617181920212223242526272829303132In [13]: s[0]Out[13]: 0.4691122999071863In [14]: s[:3]Out[14]: a 0.469112b -0.282863c -1.509059dtype: float64In [15]: s[s &gt; s.median()]Out[15]: a 0.469112e 1.212112dtype: float64In [16]: s[[4, 3, 1]]Out[16]: e 1.212112d -1.135632b -0.282863dtype: float64In [17]: np.exp(s)Out[17]: a 1.598575b 0.753623c 0.221118d 0.321219e 3.360575dtype: float64 矢量操作与对齐 Series 标签 名称属性 12345678910111213In [32]: s = pd.Series(np.random.randn(5), name=&#x27;something&#x27;)In [33]: sOut[33]: 0 -0.4949291 1.0718042 0.7215553 -0.7067714 -1.039575Name: something, dtype: float64In [34]: s.nameOut[34]: &#x27;something&#x27; DataFrame 是由多种类型的列构成的二维标签数据结构，类似于 Excel 、SQL 表，或 Series 对象构成的字典。DataFrame 是最常用的 Pandas 对象，与 Series 一样，DataFrame 支持多种类型的输入数据： 一维 ndarray、列表、字典、Series 字典 二维 numpy.ndarray 结构多维数组或记录多维数组 Series DataFrame 除了数据，还可以有选择地传递 index（行标签）和 columns（列标签）参数。传递了索引或列，就可以确保生成的 DataFrame 里包含索引或列。Series 字典加上指定索引时，会丢弃与传递的索引不匹配的所有数据。 没有传递轴标签时，按常规依据输入数据进行构建。","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"资源处理","slug":"PyQt/资源处理","date":"2021-06-07T01:45:07.551Z","updated":"2021-06-07T01:45:07.551Z","comments":true,"path":"wiki/PyQt/资源处理/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://shjlone.github.io/tags/Qt/"}]},{"title":"Pillow","slug":"Python/Pillow","date":"2021-06-07T01:45:07.551Z","updated":"2021-06-07T01:45:07.551Z","comments":true,"path":"wiki/Python/Pillow/","link":"","permalink":"http://shjlone.github.io/wiki/Python/Pillow/","excerpt":"","text":"Pillow是用于图像处理的库，可用于图像存储、图像显示、图像处理（改变大小、旋转等）。 基本使用123456789from PIL import Imageim = Image.open(&quot;test.png&quot;)print(im.format, im.size, im.mode)# format 这个属性标识了图像来源。如果图像不是从文件读取它的值就是None。# size属性是一个二元tuple，包含width和height（宽度和高度，单位都是px）。 # mode 属性定义了图像bands的数量和名称，以及像素类型和深度。常见的modes 有 “L” (luminance) 表示灰度图像, “RGB” 表示真彩色图像, and “CMYK” 表示出版图像。im.show() # 显示图像 转换文件格式到JPEG12345678910111213from __future__ import print_functionimport os, sysfrom PIL import Imagefor infile in sys.argv[1:]: f, e = os.path.splitext(infile) outfile = f + &quot;.jpg&quot; if infile != outfile: try: Image.open(infile).save(outfile) # save方法第二个参数可以指定文件格式 except IOError: print(&quot;cannot convert&quot;, infile) 创建 JPEG 缩略图12345678910111213141516from __future__ import print_functionimport os, sysfrom PIL import Imagesize = (128, 128)for infile in sys.argv[1:]: outfile = os.path.splitext(infile)[0] + &quot;.thumbnail&quot; if infile != outfile: try: im = Image.open(infile) im.thumbnail(size) im.save(outfile, &quot;JPEG&quot;) except IOError: print(&quot;cannot create thumbnail for&quot;, infile) 重要的一点是这个库不会直接解码或者加载图像栅格数据。当你打开一个文件，只会读取文件头信息用来确定格式，颜色模式，大小等等，文件的剩余部分不会主动处理。这意味着打开一个图像文件的操作十分快速，跟图片大小和压缩方式无关。 剪切，粘贴，合并图像1234567891011121314151617181920212223242526272829303132# 从图像中复制出一个矩形选区¶box = (100, 100, 400, 400)region = im.crop(box)# 矩形选区有一个4元元组定义，分别表示左、上、右、下的坐标。这个库以左上角为坐标原点，单位是px，所以上诉代码复制了一个 300x300 pixels 的矩形选区。这个选区现在可以被处理并且粘贴到原图。# 处理复制的矩形选区并粘贴到原图region = region.transpose(Image.ROTATE_180)im.paste(region, box)# 分离和合并颜色通道r, g, b = im.split()im = Image.merge(&quot;RGB&quot;, (b, g, r))out = im.resize((128, 128)) # 缩放out = im.rotate(45) # 旋转# 过滤器from PIL import ImageFilterout = im.filter(ImageFilter.DETAIL)# 读取多帧im = Image.open(&quot;animation.gif&quot;)im.seek(1) # skip to the second frametry: while 1: im.seek(im.tell()+1) # 这里seek后，可显示当前帧，可转换成Qt中的QPixmap或者QIamge # do something to imexcept EOFError: pass # end of sequence 概念Bands（通道）每张图像都是由一个或者多个数据通道构成，PIL可以在单张图片中合成相同维数和深度的多个通道，如RGB有三个通道，而灰度图像则只有一个通道。getbands方法返回通道名字。 Mode（模式）图像的模式定义了图像中像素的类型和深度，它在图像中定义mode模式的概念，如： 1:1位像素，表示黑和白，占8bit，在图像表示中称为位图 L：表示黑白之间的灰度，占8bit像素 p：8位像素，使用调色版映射 RGB：为真彩色，占用3x8位像素，其中R为red红色，G为green绿色，B为blue蓝色，三原色叠加形成的色彩变化，如三通道都为0则代表黑色，都为255则代表白色 RGBA：为带透明蒙版的真彩色，其中的A为alpha透明度，占用4x8位像 CMYK (4x8-bit 像素, color separation) YCbCr (3x8-bit 像素, color video format) I (32-bit signed integer 像素) F (32-bit floating point 像素) Size（大小）size属性表达大小，返回一个元祖，分别为高、宽值。 Coordinates System（坐标系统）PIL使用笛卡尔像素坐标系统，图像的坐标从左上角开始（0,0），坐标值表示像素的角，它实际上位于（0.5,0.5）；python中坐标通常以2元组(X,Y)的形式传递，矩形表示为4元组（l_x,t_y,r_x,b_y），X轴从左到右，Y轴从上到下，顺序是从左上右下表示，从左上角开始，如一个800X600像素的图像矩形表示为（0,0,800,600），它实际上时左上角锁定，向右下延伸的。 Palatte（调色板）定义每一个像素的真实颜色 Info（信息）info属性包含了图片的一些信息，是一个字典对象。如果是一个动画类型的图片，则里面可包含duration，表示一帧画面的现实时间。 Filters（过滤器）提供不同类型的过滤器 NEAREST Pick the nearest pixel from the input image. Ignore all other input pixels. 最近滤波。从输入图像中选取最近的像素作为输出像素。它忽略了所有其他的像素。 BILINEAR Use linear interpolation over a 2x2 environment in the input image. Note that in the current version of PIL, this filter uses a fixed input environment when downsampling. 双线性滤波。在输入图像的2x2矩阵上进行线性插值，，做下采样时该滤波器使用了固定输入模板 BICUBIC Use cubic interpolation over a 4x4 environment in the input image. Note that in the current version of PIL, this filter uses a fixed input environment when downsampling. 双立方滤波。在输入图像的4x4矩阵上进行立方插值，做下采样时该滤波器使用了固定输入模板 ANTIALIAS Calculate the output pixel value using a high-quality resampling filter (a truncated sinc) on all pixels that may contribute to the output value. In the current version of PIL, this filter can only be used with the resize and thumbnail methods. 平滑滤波，对所有可以影响输出像素的输入像素进行高质量的重采样滤波，以计算输出像素值，这个滤波器只用于改变尺寸和缩略图方法。ANTIALIAS滤波器是下采样，将大图转换为小图或左缩略图时唯一正确的滤波器，BILIEAR和BICUBIC滤波器使用固定的输入模板，用于固定比例的几何变换和上采样是最好的 解析动画Gif、Webp12345678910image = Image.open(path)while image.tell() &lt; image.n_frames: image.seek(image.tell() + 1) # image.toqpixmap() 获取当前画面 # duration 表示一帧的显示时间 if &#x27;duration&#x27; in image.info.keys(): duration = image.info[&#x27;duration&#x27;] else: duration = 100 time.sleep(duration/1000) 参考 https://github.com/python-pillow/Pillow https://www.osgeo.cn/pillow/handbook/tutorial.html","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"Python扩展","slug":"Python/Python Extending","date":"2021-06-07T01:45:07.551Z","updated":"2021-06-07T01:45:07.551Z","comments":true,"path":"wiki/Python/Python Extending/","link":"","permalink":"http://shjlone.github.io/wiki/Python/Python%20Extending/","excerpt":"","text":"官方文档：https://docs.python.org/zh-cn/3/extending/extending.html ** 什么时候要用扩展 性能瓶颈：比如某些计算在Python中很慢，比如GIL导致CPU只能使用单核。 代码保护：将核心代码放到更低层，增加反编译难度。 ** Hello World 步骤 编写C文件 编写包装文件 编写setup文件 编译、测试 1. 编写C文件12345678910//fib.c文件long long _fib(long long n)&#123; if(n &lt; 2) return n; else return _fib(n-1) + _fib(n-2);&#125;; 2. 编写包装文件12345678910111213141516171819202122232425262728293031323334353637383940414243//speedup_fib.c#include &lt;Python.h&gt; //导入基础的头文件//封装函数static PyObject *fib(PyObject *self, PyObject *args) &#123; // Arguments long long n; long long res; if (!PyArg_ParseTuple(args, &quot;l&quot;, &amp;n)) //转换输入参数类型给C return NULL; res = _fib(n);//调用函数 return Py_BuildValue(&quot;l&quot;, res);//结果转换成Python类型&#125;;//模块方法表static PyMethodDef SpeedupFibMethods[] = &#123; &#123;&quot;speedup_fib&quot;, (PyCFunction) fib, METH_VARARGS, &quot;fast fib&quot;&#125;, &#123;NULL, NULL, 0, NULL&#125;&#125;;static struct PyModuleDef speedup_fib_module = &#123; PyModuleDef_HEAD_INIT, &quot;speedup_fib&quot;,//模块名字 &quot;A module containing methods with faster fib.&quot;, -1, SpeedupFibMethods&#125;;//创建模块PyMODINIT_FUNC PyInit_speedup_fib() &#123; return PyModule_Create(&amp;speedup_fib_module);&#125; 3. 编写setup.py文件12345678910from distutils.core import setup, Extensionspeedup_fib_module = Extension(&#x27;speedup_fib&#x27;, sources=[&#x27;speedup_fib.c&#x27;])setup( name=&#x27;SpeedupFoo&#x27;, description=&#x27;A package containing modules for speeding up fib.&#x27;, ext_modules=[speedup_fib_module],) 4. 编译、测试 python setup.py build 编译成功后会在build文件夹生成动态库，windows下为pyd，linux下为so 编写测试脚本 123456789101112131415161718import timedef fib_recursive(n): if n &lt;= 1: return n return fib_recursive(n - 1) + fib_recursive(n - 2)start_ts = time.time()print(fib_recursive(35))print(time.time() - start_ts)from speedup_fib import speedup_fibstart_ts = time.time()print(speedup_fib(35))print(time.time() - start_ts) 基本概念实例代码","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"Pyhon2跟Python3的区别","slug":"Python/Python2跟Python3的区别","date":"2021-06-07T01:45:07.551Z","updated":"2021-06-07T01:45:07.551Z","comments":true,"path":"wiki/Python/Python2跟Python3的区别/","link":"","permalink":"http://shjlone.github.io/wiki/Python/Python2%E8%B7%9FPython3%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"str和bytes基本概念 字节（Byte ）：是计算机信息技术用于计量存储容量的一种计量单位，作为一个单位来处理的一个二进制数字串，是构成信息的一个小单位。最常用的字节是八位的字节，即它包含八位的二进制数; 位(bit)：是计算机 内部数据 储存的最小单位，11001100是一个八位二进制数; 字节(byte)：是计算机中 数据处理 的基本单位，习惯上用大写 B 来表示,1B(byte,字节)= 8bit(位); 字符：指计算机中使用的字母、数字、字和符号，包括：1、2、3、A、B、C、~！·#￥%……—*（）——+等等。 字符串：字符串是字符序列，它是一种抽象的概念，不能直接存储在硬盘 – 字节串是给计算机看的 ，给计算机传输或者保存的， 在Python中，程序中的文本都用字符串表示。 字节串：字节串是字节序列，它可以直接存储在硬盘， 字节串是给计算机看的 。它们之间的映射被称为编码/解码 – 字符串是给人看的，用来操作的。 字符集：为每一个字符分配一个唯一的ID（码位/码点/Code Point）。Unicode是字符集。 编码规则：将码位转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）。utf-8是编码规则。 12341 KB = 1024 B(字节)；1 MB = 1024 KB; (2^10 B)1 GB = 1024 MB; (2^20 B)1 TB = 1024 GB; (2^30 B) Python2中的str和unicode str:表示由bytes序列的字符串。 unicode:表示unicode码点序列的字符串。 12345678910111213141516171819202122&gt;&gt;&gt; a=&#x27;你好&#x27;&gt;&gt;&gt; a&#x27;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#x27;&gt;&gt;&gt; b=u&#x27;你好&#x27;&gt;&gt;&gt; bu&#x27;\\u4f60\\u597d&#x27;&gt;&gt;&gt; print(a)你好&gt;&gt;&gt; print(b)你好&gt;&gt;&gt; a.__class__&lt;type &#x27;str&#x27;&gt;&gt;&gt;&gt; b.__class__&lt;type &#x27;unicode&#x27;&gt;&gt;&gt;&gt; len(a)6&gt;&gt;&gt; len(b)2&gt;&gt;&gt; a.decode(&#x27;utf-8&#x27;)u&#x27;\\u4f60\\u597d&#x27;&gt;&gt;&gt; b.encode(&#x27;utf-8&#x27;)&#x27;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#x27; 总结： string直接用引号来表示，unicode在引号前加一个u。 直接输入的string常量会用系统缺省编码方式来编码。 len(string)返回string的字节数，len(unicode)返回的是字符数。 encode和decode使得str和unicode之间进行相互转换。 Python3中的str和byte str：str格式的定义变更为”Unicode类型的字符串“，也就是说在默认情况下，被引号框起来的字符串，是使用Unicode编码的。也就是说unicode类型在python3中没有了，python3中的str就相当于python2中的unicode。 bytes：bytes 函数返回一个新的 bytes 对象，该对象是一个 0 &lt;= x &lt; 256 区间内的整数不可变序列。它是 bytearray 的不可变版本。bytes 只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。 bytearray：可变的子节数组。 1234567891011121314&gt;&gt;&gt; a=&#x27;你好&#x27;&gt;&gt;&gt; a&#x27;你好&#x27;&gt;&gt;&gt; type(a)&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; b = bytes(a, encoding=&#x27;utf-8&#x27;)&gt;&gt;&gt; bb&#x27;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#x27;&gt;&gt;&gt; type(b)&lt;class &#x27;bytes&#x27;&gt;&gt;&gt;&gt; a.encode()b&#x27;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&#x27;&gt;&gt;&gt; b.decode()&#x27;你好&#x27;","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"Python多线程","slug":"Python/Python多线程编程","date":"2021-06-07T01:45:07.551Z","updated":"2021-06-07T01:45:07.552Z","comments":true,"path":"wiki/Python/Python多线程编程/","link":"","permalink":"http://shjlone.github.io/wiki/Python/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Python代码的执行由虚拟机来控制。Python再主循环中，同时只有一个线程再执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序再CPU中运行。 对Python虚拟机的访问由全局解释器锁（global interpreter lock）来控制，正是这个锁能保证同一时刻只有一个线程在运行。 参考 https://docs.python.org/zh-cn/3/library/threading.html","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://shjlone.github.io/tags/Python/"}]},{"title":"编译QtWebEngine","slug":"PyQt/编译QtWebEngine","date":"2021-06-07T01:45:07.547Z","updated":"2021-06-07T01:45:07.547Z","comments":true,"path":"wiki/PyQt/编译QtWebEngine/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/%E7%BC%96%E8%AF%91QtWebEngine/","excerpt":"","text":"由于QtWebEngine本身并不支持H.264编码的音视频，现自行编译，整个过程如下： 依赖准备VS2015 Update3 下载地址 安装Qt 5.10.1：安装的时候选择带源码 下载地址 安装Python 2.7.5以上版本 下载地址 Perl 下载地址 Bison和Flex 下载地址 Gperf 下载地址 Windows SDK 要求10.0.10586版本以上 环境准备如果出现以下问题，则将系统语言设置为英文 1ninja: build stopped: subcommand failed. NMAKE : fatal error U1077: &#x27;call&#x27; : return code &#x27;0x1&#x27; Stop. NMAKE : fatal error U1077: &#x27;&quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.14.26428\\bin\\HostX64\\x64\\nmake.exe&quot;&#x27; : return code &#x27;0x2&#x27; Stop. NMAKE : fatal error U1077: &#x27;(&#x27; : return code &#x27;0x2&#x27; Stop. NMAKE : fatal error U1077: &#x27;cd&#x27; : return code &#x27;0x2&#x27; Stop. NMAKE : fatal error U1077: &#x27;cd&#x27; : return code &#x27;0x2&#x27; Stop 编译rem 运行VC环境 &quot;D:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\vcvars32.bat&quot; set PYTHON_PATH=D:\\Python\\Python27-32 set PERL_PATH=E:\\Perl\\bin set Bison_Flex_PATH=D:\\Qt\\Qt5.10.1\\5.10.1\\build_depends\\win_flex_bison set Gperf_PATH=D:\\Qt\\Qt5.10.1\\5.10.1\\build_depends\\gperf-3.0.1-bin\\bin set PATH=%PYTHON_PATH%;%PERL_PATH%;%Bison_Flex_PATH%;%Gperf_PATH%;%PATH% rem 配置 &quot;D:\\Qt\\Qt5.10.1\\5.10.1\\msvc2015\\bin\\qmake.exe&quot; -- -webengine-proprietary-codecs rem 编译、安装 nmake &amp;&amp; namek install 参考 https://wiki.qt.io/Building_Qt_5_from_Git http://doc.qt.io/qt-5/build-sources.html http://doc.qt.io/qt-5/windows-requirements.html https://www.pressc.cn/1044.html https://blog.afach.de/?page_id=399","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"Qt QtWebEngine","slug":"Qt-QtWebEngine","permalink":"http://shjlone.github.io/tags/Qt-QtWebEngine/"}]},{"title":"编译PyQt5","slug":"PyQt/编译PyQt5","date":"2021-06-07T01:45:07.547Z","updated":"2021-06-07T01:45:07.547Z","comments":true,"path":"wiki/PyQt/编译PyQt5/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/%E7%BC%96%E8%AF%91PyQt5/","excerpt":"","text":"目录： 官方文档翻译 编译MinGW版本 编译VS版本 下载SIPSIP必现在编译和使用PyQt5之前安装。你可以从https://www.riverbankcomputing.com/software/sip/download使用最新的发布版本的源码。 SIP的安装说明请参阅http://pyqt.sourceforge.net/Docs/sip4/installation.html 当编译v5.11或以上的版本时，你必须配饰SIP来创建私有的备份。可以使用下面的命令： python configure.py –sip-module PyQt5.sip –no-tools 下载PyQt5你可以从https://www.riverbankcomputing.com/software/pyqt/download5下载最新的源码 如果你使用商业版的PyQt5，则需要购买商业授权，并下载属于你的pyqt-commercial.sip授权文件 配置PyQt5解压后，你应该阅读相应平台的README文件。 如果你使用商业版的PyQt5，你必须复制你的pyqt-commercial.sip授权文件到sip文件夹，或者使用–license-dir参数指定。 你需要确定你的环境变量是否正确。 为了配置构建PyQt5，你需要运行以下脚本： 1python3 configure.py 脚本完整的参数属性如下： -h, --help 展示帮助信息 --allow-sip-warnings 5.9.1版本的新特性。 Normally any warning message generated by sip is treated as an error. This option causes warning messages to be considered non-fatal. It is normally only required if a later version of sip is being used that has deprecated a feature used by this version of PyQt5. --assume-shared Normally Qt is checked to see if it has been built as shared libraries. Some Linux distributions configure their Qt builds to make this check unreliable. This option ignores the result of the check and assumes that Qt has been built as shared libraries. --bindir pyuic5, pyrcc5 and pylupdate5工具将会安装到的目录。 --concatenate The C++ source files for a Python module will be concatenated. This results in significantly reduced compilation times. Most, but not all, C++ compilers can handle the large files that result. See also the –concatenate-split option. --concatenate-split If the –concatenate option is used to concatenate the C++ source files then this option determines how many files are created. The default is 1. --configuration 指定配置文件 contains the configuration of the PyQt5 build to be used instead of dynamically introspecting the system and is typically used when cross-compiling. See Configuring with Configuration Files. --confirm-license 使用授权证书 Using this confirms that you accept the terms of the PyQt5 license. If it is omitted then you will be asked for confirmation during configuration. --dbus 根据/dbus目录找到dbus-python.h头文件 The dbus-python.h header file of the dbus-python package can be found in the directory/dbus. --debug The PyQt5 modules will be built with debugging symbols. On Windows configure.py must be run using a debug version of Python. --designer-plugindir 指定Qt Designer安装目录 --destdir 指定PyQt5安装目录。默认安装在Python的site-packages目录。如果你使用这个属性，则PYTHONPATH必须指定在 The PyQt5 Python package will be installed in the directory. The default is the Python installation’s site-packages directory. If you use this option then the PYTHONPATH environment variable must include. --disable 5.5.1新特性 Normally all PyQt5 modules are enabled and are built if the corresponding Qt library can be found. This option will suppress the check for &gt;. The option may be specified any number of times. --disable-feature 5.10.1新特性 A PyQt5 module may be configured differently depending on the corresponding Qt configuration. This takes the form of a set of features that may be disabled. Normally this is determined automatically. This option will explicitly disable the &gt; feature. The option may be specified any number of times. --enable Normally all PyQt5 modules are enabled and are built if the corresponding Qt library can be found. Using this option only those modules specifically enabled will be built. The option may be specified any number of times. Note that using this option suppresses the checks that are normally made to determine how the module should be configured, i.e. which features should be disabled. --license-dir 指定授权证书的目录 The license files needed by the commercial version of PyQt5 can be found in the directory. --link-full-dll 5.8版本新特性 On Windows the full Python API and the limited API (as used by PyQt) are implemented in different DLLs. Normally the limited DLL is linked (unless a debug version of the Python interpreter is being used to run configure.py). This option forces the full API DLL to be linked instead. --no-designer-plugin Qt Designer 插件将不会被编译 --no-dist-info 5.11新特性 This disables the creation of the PEP 376 .dist-info directory. Starting with this version a .dist-info directory is created. This contains meta-data about the installation including version information for dependent packages. It also means that pip can be used to uninstall the package. --no-docstrings PyQt5模块不会包含自动产生的文档字符串 The PyQt5 modules will not contain automatically generated docstrings. --no-python-dbus The Qt support for the standard Python DBus bindings is disabled. --no-qml-plugin qmlscene 插件不会被编译 --no-qsci-api The PyQt5.api QScintilla API file is not installed even if QScintilla does appear to be installed. --no-sip-files The .sip files for the PyQt5 modules will not be installed. --no-stubs New in version 5.6. The PEP 484 type hint stub files for the PyQt5 modules will not be installed. This option is ignored (and the stub files are not installed) for versions of Python earlier than v3.5. --no-tools New in version 5.3. The pyuic5, pyrcc5 and pylupdate5 tools will not be built. --no-timestamp Normally the header comments of each generated C/C++ source file includes a timestamp corresponding to when the file was generated. This option suppresses the inclusion of the timestamp. --protected-is-public On certain platforms the size of PyQt5 modules can be significantly reduced by redefining the C++ protected keyword as public during compilation. This option enables this behaviour and is the default on Linux and macOS. --protected-not-public The default redefinition of protected to public during compilation on Linux and macOS is disabled. --pyuic5-interpreter is the name of the Python interpreter used in the pyuic5 wrapper. The default is platform dependent. --qmake Qt’s qmake program is used to determine how your Qt installation is laid out. Normally qmake is found on your PATH. This option can be used to specify a particular instance of qmake to use. --qml-debug New in version 5.8. Enable the QML debugging infrastructure. This should not be enabled in a production environment. --qml-plugindir The Python plugin for qmlscene will be installed in the directory. --qsci-api The PyQt5.api QScintilla API file is installed even if QScintilla does not appear to be installed. This option is implied if the –qsci-api-destdir option is specified. --qsci-api-destdir The QScintilla API file will be installed in the python subdirectory of the api subdirectory of the directory. --qtconf-prefix New in version 5.6. A qt.conf file is embedded in the PyQt5.QtCore module with Prefix set to which is assumed to be relative to the directory that the PyQt5.QtCore module will be installed in. --sip The sip program is used to generate PyQt5’s C++ source code. Normally sip is found on your PATH. This option can be used to specify a particular instance of sip to use. --sip-incdir The sip.h header file can be found in the directory. --sipdir The .sip files for the PyQt5 modules will be installed in the directory. --spec The argument -spec SPEC will be passed to qmake. The default behaviour is platform specific. On Windows configure.py will choose the value that is correct for the version of Python that is being used. (However if you have built Python yourself then you may need to explicitly specify .) On macOS configure.py will try and avoid macx-xcode if possible.) --static The PyQt5 modules will be built as static libraries. This is useful when building a custom interpreter with the PyQt5 modules built in to the interpreter. --stubsdir New in version 5.6. The PEP 484 type hint stub files for the PyQt5 modules will be installed in the directory. By default they will be stored in the same directory where (by default) the corresponding extension modules would be installed. This option is ignored (and the stub files are not installed) for versions of Python earlier than v3.5. --sysroot New in version 5.3. is the name of an optional directory that replaces sys.prefix in the names of other directories (specifically those specifying where the various PyQt5 components will be installed and where the Python include and library directories can be found). It is typically used when cross-compiling or when building a static version of PyQt5. See Configuring with Configuration Files. --target-py-version New in version 5.3. is the major and minor version (e.g. 3.4) of the version of Python being targetted. By default the version of Python being used to run the configure.py script is used. It is typically used when cross-compiling. See Configuring with Configuration Files. --trace The generated PyQt5 modules contain additional tracing code that is enabled using SIP’s sip.settracemask() function. --verbose Compiler commands and any output issued during configuration is displayed instead of being suppressed. Use this if configure.py is having problems to see what exactly is going wrong. --version 显示版本号 编译PyQt5make make install 配置配置文件配置文件的格式如下： 使用[]来表示一部分的名字 配置的条目为单一的行，用=分开的键值对 在值中可以使用%(name)的方式来嵌套其他的值 注释需要以#开头 空白行被忽略 配置文件通过定义不同的[]部分来使用不同的版本。configure.py将会选择对应的Qt版本。比如，如果配置文件包含Qt v5.1和Qt v5.3，你使用Qt v5.2.1，则会选择Qt v5.1的版本。 configure.py提供了以下预制变量： py_major 对应Python安装最大的版本 py_minor 对应Python安装最小的版本 sysroot 系统根目录，可以使用–sysroot选项指定 下面是一个配置文件的实例： # The target Python installation. py_platform = linux py_inc_dir = %(sysroot)/usr/include/python%(py_major).%(py_minor) py_pylib_dir = %(sysroot)/usr/lib/python%(py_major).%(py_minor)/config py_pylib_lib = python%(py_major).%(py_minor)mu # The target PyQt installation. pyqt_module_dir = %(sysroot)/usr/lib/python%(py_major)/dist-packages pyqt_bin_dir = %(sysroot)/usr/bin pyqt_sip_dir = %(sysroot)/usr/share/sip/PyQt5 pyuic_interpreter = /usr/bin/python%(py_major).%(py_minor) pyqt_disabled_features = PyQt_Desktop_OpenGL PyQt_qreal_double # Qt configuration common to all versions. qt_shared = True [Qt 5.1] pyqt_modules = QtCore QtDBus QtDesigner QtGui QtHelp QtMultimedia QtMultimediaWidgets QtNetwork QtOpenGL QtPrintSupport QtQml QtQuick QtSensors QtSerialPort QtSql QtSvg QtTest QtWebKit QtWebKitWidgets QtWidgets QtXmlPatterns _QOpenGLFunctions_ES2 下面的值可以在配置文件中指定： qt_shared 设置Qt是否是动态共享文件，默认值为False py_platform Python目标平台 py_debug is set if a debug version of the target Python is being used. py_inc_dir is the target Python include directory, i.e. the directory containing the Python.h file. py_pylib_dir is the target Python library directory. py_pylib_lib is the target Python interpreter library. It should not include any platform-specific prefix or suffix. pyqt_disabled_features is the space separated list of features (as defined by SIP’s %Feature directive) that should be disabled. pyqt_module_dir is the target directory where the PyQt5 modules will be installed. It can be overridden by the –destdir option. pyqt_modules is the space separated list of PyQt5 modules that will be built. It can be overridden by the –enable option. pyqt_bin_dir is the name of the target directory where the PyQt5 related executables will be installed. It can be overridden by the –bindir option. pyqt_sip_dir is the name of the target directory where the PyQt5 .sip files will be installed. It can be overridden by the –sipdir option. pyuic_interpreter is the name of the Python interpreter (as it would be called from the target system) that will be used to run pyuic5. It can be overridden by the –pyuic5-interpreter option. 参考 http://pyqt.sourceforge.net/Docs/PyQt5/installation.html","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://shjlone.github.io/tags/PyQt5/"}]},{"title":"Qt视图模型","slug":"PyQt/视图模型","date":"2021-06-07T01:45:07.547Z","updated":"2021-06-07T01:45:07.547Z","comments":true,"path":"wiki/PyQt/视图模型/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"数据（Data）：是实际的数据，如数据库的一个数据表或SQL查询结果，内存中的一个 StringList，或磁盘文件结构等。 视图或视图组件（View）：是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引（model index），通过模型索引获取数据，然后为界面组件提供显示数据。Qt 提供一些现成的数据视图组件，如 QListView、QTreeView 和 QTableView 等。 模型或数据模型（Model）：与实际数据通信，并为视图组件提供数据接口。它从原始数据提取需要的内容，用于视图组件进行显示和编辑。Qt 中有一些预定义的数据模型，如 QStringListModel 可作为 StringList 的数据模型，QSqlTableModel 可以作为数据库中一个数据表的数据模型。 委托（Delegate）：根据数据绘制UI 模型、视图和代理之间使用信号和槽通信。当源数据发生变化时，数据模型发射信号通知视图组件；当用户在界面上操作数据时，视图组件发射信号表示这些操作信息；当编辑数据时，代理发射信号告知数据模型和视图组件编辑器的状态。 视图视图组件（View）就是显示数据模型的数据的界面组件，Qt 提供的视图组件如下： QListView：用于显示单列的列表数据，适用于一维数据的操作。 QTreeView：用于显示树状结构数据，适用于树状结构数据的操作。 QTableView：用于显示表格状数据，适用于二维表格型数据的操作。 QColumnView：用多个QListView显示树状层次结构，树状结构的一层用一个QListView显示。 QHeaderView：提供行表头或列表头的视图组件，如QTableView的行表头和列表头。 模型在 model/view架构中，model提供一种标准接口，供视图和委托访问数据。在Qt中，这个接口由QAbstractItemModel类进行定义。不管底层数据是如何存储的，只要是QAbstractItemModel的子类，都提供一种表格形式的层次结构。视图利用统一的转换来访问模型中的数据。 下面是各种model的组织示意图。我们利用此图来理解什么叫“一种表格形式的层次结构”。 List Model虽然是线性的列表，也有一个 Root Item（根节点），之下才是呈线性的一个个数据，而这些数据实际可以看作是一个只有一列的表格，但是它是有层次的，因为有一个根节点。Table Model 就比较容易理解，只是也存在一个根节点。Tree Model 主要面向层次数据，而每一层次都可以都很多列，因此也是一个带有层次的表格。 为了能够使得数据的显示同存储分离，我们引入模型索引（model index）的概念。通过索引，我们可以访问模型的特定元素的特定部分。视图和委托使用索引来请求所需要的数据。由此可以看出，只有模型自己需要知道如何获得数据，模型所管理的数据类型可以使用通用的方式进行定义。索引保存有创建的它的那个模型的指针，这使得同时操作多个模型成为可能。 1QAbstractItemModel *model = index.model(); 模型索引提供了所需要的信息的临时索引，可以用于通过模型取回或者修改数据。由于模型随时可能重新组织其内部的结构，因此模型索引很可能变成不可用的，此时，就不应该保存这些数据。如果你需要长期有效的数据片段，必须创建持久索引。持久索引保证其引用的数据及时更新。临时索引（也就是通常使用的索引）由QModelIndex类提供，持久索引则是QPersistentModelIndex类。 为了定位模型中的数据，我们需要三个属性：行号、列号以及父索引。 我们前面介绍过模型的基本形式：数据以二维表的形式进行存储。此时，一个数据可以由行号和列号进行定位。注意，我们仅仅是使用“二维表”这个名词，并不意味着模型内部真的是以二维数组的形式进行存储；所谓“行号”“列号”，也仅仅是为方便描述这种对应关系，并不真的是有行列之分。通过指定行号和列号，我们可以定位一个元素项，取出其信息。此时，我们获得的是一个索引对象： 123456QModelIndex index = model-&gt;index(row, column, ...);QModelIndex QAbstractItemModel::index(int row, int column, const QModelIndex &amp;parent=QModelIndex()) const 在一个简单的表格中，每一个项都可以由行号和列号确定。因此，我们只需提供两个参数即可获取到表格中的某一个数据项： 123QModelIndex indexA = model-&gt;index(0, 0, QModelIndex());QModelIndex indexB = model-&gt;index(1, 1, QModelIndex());QModelIndex indexC = model-&gt;index(2, 1, QModelIndex()); 函数的最后一个参数始终是 QModelIndex() 在类似表格的视图中，比如列表和表格，行号和列号足以定位一个数据项。但是，对于树型结构，仅有两个参数就不足够了。这是因为树型结构是一个层次结构，而层次结构中每一个节点都有可能是另外一个表格。所以，每一个项需要指明其父节点。前面说过，在模型外部只能用过索引访问内部数据，因此，index()函数还需要一个 parent 参数： 1QModelIndex index = model-&gt;index(row, column, parent); 图中，A 和 C 都是模型中的顶级项： 12QModelIndex indexA = model-&gt;index(0, 0, QModelIndex());QModelIndex indexC = model-&gt;index(2, 1, QModelIndex()); A 还有自己的子项。那么，我们就应该使用下面的代码获取 B 的索引： 1QModelIndex indexB = model-&gt;index(1, 0, indexA); 由此我们看到，如果只有行号和列号两个参数，B 的行号是 1，列号是 0，这同与 A 同级的行号是 1，列号是 0 的项相同，所以我们通过 parent 属性区别开来。 以上我们讨论了有关索引的定位。现在我们来看看模型的另外一个部分：数据角色。模型可以针对不同的组件（或者组件的不同部分，比如按钮的提示以及显示的文本等）提供不同的数据。例如，Qt::DisplayRole用于视图的文本显示。通常来说，数据项包含一系列不同的数据角色，这些角色定义在Qt::ItemDataRole枚举中。 我们可以通过指定索引以及角色来获得模型所提供的数据： 1QVariant value = model-&gt;data(index, role); 通过为每一个角色提供恰当的数据，模型可以告诉视图和委托如何向用户显示内容。不同类型的视图可以选择忽略自己不需要的数据。当然，我们也可以添加我们所需要的额外数据。 总结一下： 模型使用索引来提供给视图和委托有关数据项的位置的信息，这样做的好处是，模型之外的对象无需知道底层的数据存储方式； 数据项通过行号、列号以及父项三个坐标进行定位； 模型索引由模型在其它组件（视图和委托）请求时才会被创建； 如果使用index()函数请求获得一个父项的可用索引，该索引会指向模型中这个父项下面的数据项。这个索引指向该项的一个子项；如果使用index()函数请求获得一个父项的不可用索引，该索引指向模型的最顶级项； 角色用于区分数据项的不同类型的数据。 下面回到前面我们曾经见过的模型QFileSystemModel，看看如何从模型获取数据。 123QFileSystemModel *model = new QFileSystemModel;QModelIndex parentIndex = model-&gt;index(QDir::currentPath());int numRows = model-&gt;rowCount(parentIndex); 在这个例子中，我们创建了QFileSystemModel的实例，使用QFileSystemModel重载的index()获取索引，然后使用rowCount()函数计算当前目录下有多少数据项（也就是行数）。前面一章中迷迷糊糊的代码，现在已经相当清楚了。 为简单起见，下面我们只关心模型第一列。我们遍历所有数据，取得第一列索引： 12for (int row = 0; row &lt; numRows; ++row) &#123; QModelIndex index = model-&gt;index(row, 0, parentIndex); 我们使用index()函数，第一个参数是每一行行号，第二个参数是 0，也就是第一列，第三个参数是parentIndex，也就是当前目录作为父项。我们可以使用模型的data()函数获取每一项的数据。注意，该函数返回值是QVariant，实际是一个字符串，因此我们直接转换成QString： 1QString text = model-&gt;data(index, Qt::DisplayRole).toString();// 使用 text 数据 上面的代码片段显示了从模型获取数据的一些有用的函数： 模型的数目信息可以通过rowCount()和columnCount()获得。这些函数需要制定父项； 索引用于访问模型中的数据。我们需要利用行号、列号以及父项三个参数来获得该索引； 当我们使用QModelIndex()创建一个空索引使用时，我们获得的就是模型中最顶级项； 数据项包含了不同角色的数据。为获取特定角色的数据，必须指定这个角色。 QStringListModel、QDirModel、QFileSystemModel等预定义model QStandardItemModel 可当作列表模型、表格模型、树模型来使用的通用模型 QAbstractItemModel自定义模型 QStandardItemModel常用API flags(const QModelIndex &amp;index):返回被给模型索引index的标志 data(const QModelIndex &amp;index, int role = Qt::DisplayRole):返回模型索引index的底层数据（一个模型索引包括某一元素的信息，包括行，列，以及数据），用于视图和委托访问数据 headerData(int selection, Qt::Orientation orientation, int role =Qt::DisplayRole):返回某部分对应方向上的表头 ，为Views提供显示在Views顶部（即最上方和最左边）的标识 rowCount(const QModelIndex &amp;parent=QModelIndex()):返回被给的模型索引下有多少行，返回的是parent的孩子数。而不是整个行数。如果没有子元素，则返回0。 columnCount(const QModelIndex &amp;parent=QModelIndex()):这个函数通常与给定的parent无关，所涉及的类有几列就返回几 setData(const QModelIndex &amp;index, const QVariant &amp;value, int role=Qt::EditRole):用来设置模型索引index中存储的数据 setHeaderData(int section, Qt::Orientation orientation, const QVariant &amp;value, int role = Qt::EditRole): insertRows(int position, int rows, const QModelIndex &amp;index = QModelIndex()):进行插入操作时，前后分别需要调用beginInsertRows()和endInsertRows()函数 委托（Delegate）代理就是在视图组件上为编辑数据提供编辑器，如在表格组件中编辑一个单元格的数据时，缺省是使用一个 QLineEdit 编辑框。代理负责从数据模型获取相应的数据，然后显示在编辑器里，修改数据后，又将其保存到数据模型中。 QAbstractltemDelegate 是所有代理类的基类，作为抽象类，它不能直接使用。它的一个子类 QStyledltemDelegate，是 Qt 的视图组件缺省使用的代理类。 QStyledItemDelegate常用API updateEditorGeometry：设置编辑器editor的尺寸和位置 painter： 绘制给定模型索引index所对应的项 setEditorData： 使用给定模型索引index所对应的模型项的数据来填充编辑器editor setModelData：从编辑器editor中获取数据并设置为给定模型索引index所对应的模型项的数据 setHint： 返回委托需要的、显示或编辑给定模型索引index所代表的项的尺寸 updateEditorGeometry： 设置编辑器editor的尺寸和位置 实例参考 https://doc.qt.io/qt-5/model-view-programming.html","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/tags/PyQt/"}]},{"title":"PyQt5开发心得","slug":"PyQt/PyQt5开发心得","date":"2021-06-07T01:45:07.546Z","updated":"2021-06-07T01:45:07.546Z","comments":true,"path":"wiki/PyQt/PyQt5开发心得/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/PyQt5%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/","excerpt":"","text":"其实大部分的客户端开发都有共通性。一套GUI API，Button、Text、Dialog等等，绘制机制，事件传递机制，都是根据不同平台的特性做了封装。但开发的时候，用法是类似的。而Python由于语法的简易性，开发效率比使用C++版的Qt高很多。所谓的性能损耗其实在大部分的应用中是可以忽略的。 基础结构的搭建不管是做一个项目还是多个项目，准备一套基础框架，对开发效率是非常有帮助的。这个基础框架通常包括： 基础结构 基础工具类、工具函数：字符串处理、时间处理、日期处理、线程处理、网络请求、拖拽工具、缩放工具、资源下载工具、 基础控件：弹窗提示、确认框、webview的封装和通讯模块、loading框、全局样式处理 日志工具： 数据模拟工具：mock 单元测试框架： 性能分析工具：分析代码质量 打包工具：分发安装包 更新工具 异常捕获分析工具：分析线上可能存在的问题 项目框架的搭建：分层、抽象、解耦、MVC思想的体现。随着业务的增长，在重构代码的时候要遵循高内聚、低耦合的思想。 关于线程的使用随着业务的增长，项目会越来越复杂，不可避免的会使用到多线程。使用的过程中，要注意以下几点： 线程要及时释放 比如有一个场景，用户点击某个按钮，需要向服务器请求数据，然后将数据更新到文本框中。你需要在非UI线程中请求http接口，收到服务器响应后，切换回UI线程更新。但有时候由于网络原因，响应的时间较长，在收到响应结果时，UI已经被销毁了。所以要注意在UI销毁的同时，对应的线程都要进行释放。同样的场景还有下载器，各种定时操作。都要进行及时的清理。 最好能封装几个工具类、工具函数，统一管理。 QTimer初始化时带上parent，创建和start在同一个线程 Model初始化的时候需要传入parent 关于性能虽然前面说性能问题可以忽略，但如果你很随意的在主线程中做一些频繁的复杂的运算，UI也是会卡顿的。这里介绍一点自己的经验。 非UI操作尽量全部放到非UI线程处理。 对于非常频繁的操作使用间隔，比如1秒中调用一次。直白说就是降低UI刷新的频率。 由于python GIL的存在，当某些计算需要消耗较多CPU时，需要考虑是否将其移到C/C++中处理。 使用更优秀的json处理库 关于程序崩溃http://enki-editor.org/2014/08/23/Pyqt_mem_mgmt.html https://stackoverflow.com/questions/11945183/what-are-good-practices-for-avoiding-crashes-hangs-in-pyqt http://python-camelot.s3.amazonaws.com/gpl/release/pyqt/doc/advanced/development.html 常见问题汇总libpng warning: iCCP: known incorrect sRGB profile UpdateLayeredWindowIndirect failed for ptDst= 程序使用一段时间后，关闭某个窗口，会造成整个程序崩溃。crashrpt捕获到的dump指向的是Qt的某个函数。可无法定位到业务层的代码。后打包成debug模式，在崩溃的时候控制台输出了以上信息，google进行搜索，看到了这里，想起来边框阴影的实现就是使用了QGraphicsDropShadowEffect滤镜。去掉后，果然没有再出现了。 如何彻底销毁QWidget close() 在Qt中，每个 QObject 内部都有一个list，用来保存所有的 children，还有一个指针，保存自己的parent。当它自己析构时，它会将自己从parent的列表中删除，并且析构掉所有的children。 调用close()方法后首先它会向widget发送一个关闭事件（QCloseEvent）。如果widget接受了关闭事件（QCloseEvent），窗口将会隐藏（实际上调用hide()）。如果widget不接受关闭事件，那么窗口将什么也不做。默认情况下widget会接受关闭事件,我们可以重写QCloseEvent事件，可以选择接受或者不接受。 如果widget设置了Qt::WA_DeleteOnClose属性，widget将会被释放。不管widget是否可见，关闭事件都会传递给widget。即接收到QCloseEvent事件后，除了调用hide()方法将窗口隐藏，同时会调用deleteLater()方法将窗口释放掉，不会再占用资源。 所以说调用close()并不一定就会将窗口对象销毁。而只有设置了 Qt::WA_DeleteOnClose属性才会删除销毁。如果这个属性没有设置，close()的作用和hide（），setvisible（false）一样，只会隐藏窗口对象而已，并不会销毁该对象。 deleteLater() 走Qt的事件循环，延迟删除。 sip.delete(widget) 调用了Qt的delete来删除对象 QWidget的Qt.WA_TranslucentBackground默认值是False。 123456789101112131415class FooWidget(QWidget): def __init__(self): super(FooWidget, self).__init__() self.setAttribute(Qt.WA_TranslucentBackground, True) def closeEvent(self, event): # accept退出，ingore取消退出，默认值为accept print(&#x27;closeEvent&#x27;)self.foo = FooWidget()self.foo.close()self.foo = None 参考 https://blog.csdn.net/GoForwardToStep/article/details/53647146 https://doc.qt.io http://c.biancheng.net/view/1864.html","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://shjlone.github.io/tags/Qt/"}]},{"title":"QListWidget","slug":"PyQt/QListWidget","date":"2021-06-07T01:45:07.546Z","updated":"2021-06-07T01:45:07.546Z","comments":true,"path":"wiki/PyQt/QListWidget/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/QListWidget/","excerpt":"","text":"一些技巧让QListWidget的高度跟着内容的高度变化12345678910111213141516from PySide import QtGui, QtCoreapp = QtGui.QApplication([])window = QtGui.QWidget()layout = QtGui.QVBoxLayout(window)list = QtGui.QListWidget()list.addItems([&#x27;Winnie Puh&#x27;, &#x27;Monday&#x27;, &#x27;Tuesday&#x27;, &#x27;Minnesota&#x27;, &#x27;Dracula Calista Flockhart Meningitis&#x27;, &#x27;Once&#x27;, &#x27;123345&#x27;, &#x27;Fin&#x27;])list.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)list.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)list.setFixedSize(list.sizeHintForColumn(0) + 2 * list.frameWidth(), list.sizeHintForRow(0) * list.count() + 2 * list.frameWidth())layout.addWidget(list)window.show()app.exec_() 参考 https://stackoverflow.com/questions/6337589/qlistwidget-adjust-size-to-content","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://shjlone.github.io/tags/Qt/"}]},{"title":"emoji表情处理","slug":"PyQt/emoji表情处理","date":"2021-06-07T01:45:07.546Z","updated":"2021-06-07T01:45:07.546Z","comments":true,"path":"wiki/PyQt/emoji表情处理/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/emoji%E8%A1%A8%E6%83%85%E5%A4%84%E7%90%86/","excerpt":"","text":"在QLabel上显示emoji表情，win10和win7显示的效果不一样，win10能显示出彩色的，但win7只能显示黑白色，且有些表情甚至不能显示。 不同系统的实现效果都是不一样的，所以要实现统一，最好的方式就是自己实现，通过其unicode值建立一套对应的图片，显示的时候，直接绘制本地的图片。而不走系统渲染。 参考 https://appuals.com/how-to-get-windows-10-emojis-on-windows-7-8/ 这篇文章说明win7是不支持的系统显示彩色emoji的 https://github.com/carpedm20/emoji unicode值和对应表情的字符串之间的互相转换，有一些非标准的emoji表情，比如**:thumbs_up:**表示 👍 https://github.com/googlefonts/noto-emoji google 彩色字体库 https://github.com/DeeDeeG/noto-color-emoji-font","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/tags/PyQt/"}]},{"title":"Qt中圆形头像","slug":"PyQt/圆形头像","date":"2021-06-07T01:45:07.546Z","updated":"2021-06-07T01:45:07.546Z","comments":true,"path":"wiki/PyQt/圆形头像/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F/","excerpt":"","text":"业务需求中经常需要头像是圆形的，一些数字底部有圆形背景，于是将其整理出来，以便以后方便的使用。 123456789101112131415161718192021class CircleThumbWiget(QWidget): def __init__(self, parent=None, radius=40): &quot;&quot;&quot; radius 表示这个圆形控件的大小 &quot;&quot;&quot; super(CircleThumbWiget, self).__init__(parent) self.imageLabel = QLabel(self) self.imageLabel.setScaledContents(True) self.imageLabel.setGeometry(0, 0, radius, radius) defaultPixmap = QPixmap(&quot;resources/icon/default_user.png&quot;) self.imageLabel.setPixmap(defaultPixmap) # 这里使用一张周边透明的圆形的png图片 img = QImage(&quot;resources/icon/default_user_mask.png&quot;) bg = QPixmap.fromImage(img.scaled(QSize(radius, radius), Qt.IgnoreAspectRatio)) palette = self.palette() palette.setBrush(QPalette.Background, QBrush(bg)) self.setPalette(palette) self.setMask(bg.mask()) def setPixmap(self, pixmap): self.imageLabel.setPixmap(pixmap) 平滑的圆形头像1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from PyQt5.QtCore import Qt, QRectfrom PyQt5.QtGui import QBrush, QImage, QPainter, QPixmap, QWindowfrom PyQt5.QtWidgets import QLabel, QVBoxLayout, QWidgetdef mask_image(imgdata, imgtype=&#x27;png&#x27;, size=64): &quot;&quot;&quot;Return a ``QPixmap`` from *imgdata* masked with a smooth circle. *imgdata* are the raw image bytes, *imgtype* denotes the image type. The returned image will have a size of *size* × *size* pixels. &quot;&quot;&quot; # Load image and convert to 32-bit ARGB (adds an alpha channel): image = QImage.fromData(imgdata, imgtype) image.convertToFormat(QImage.Format_ARGB32) # Crop image to a square: imgsize = min(image.width(), image.height()) rect = QRect( (image.width() - imgsize) / 2, (image.height() - imgsize) / 2, imgsize, imgsize, ) image = image.copy(rect) # Create the output image with the same dimensions and an alpha channel # and make it completely transparent: out_img = QImage(imgsize, imgsize, QImage.Format_ARGB32) out_img.fill(Qt.transparent) # Create a texture brush and paint a circle with the original image onto # the output image: brush = QBrush(image) # Create texture brush painter = QPainter(out_img) # Paint the output image painter.setBrush(brush) # Use the image texture brush painter.setPen(Qt.NoPen) # Don&#x27;t draw an outline painter.setRenderHint(QPainter.Antialiasing, True) # Use AA painter.drawEllipse(0, 0, imgsize, imgsize) # Actually draw the circle painter.end() # We are done (segfault if you forget this) # Convert the image to a pixmap and rescale it. Take pixel ratio into # account to get a sharp image on retina displays: pr = QWindow().devicePixelRatio() pm = QPixmap.fromImage(out_img) pm.setDevicePixelRatio(pr) size *= pr pm = pm.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation) return pmclass Window(QWidget): &quot;&quot;&quot;Simple window that shows our masked image and text label.&quot;&quot;&quot; def __init__(self): super().__init__() imgpath = &quot;U:/xxx/logo.png&quot; imgdata = open(imgpath, &#x27;rb&#x27;).read() ext = imgpath.split(&quot;.&quot;)[-1] pixmap = mask_image(imgdata, ext) ilabel = QLabel() ilabel.setScaledContents(True) ilabel.setFixedWidth(26) ilabel.setFixedHeight(26) ilabel.setPixmap(pixmap) layout = QVBoxLayout() layout.addWidget(ilabel, 0, Qt.AlignCenter) self.setLayout(layout)if __name__ == &#x27;__main__&#x27;: import sys from PyQt5.QtWidgets import QApplication app = QApplication(sys.argv) w = Window() w.show() sys.exit(app.exec_()) 参考 https://stefan.sofa-rockers.org/2018/05/04/how-to-mask-an-image-with-a-smooth-circle-in-pyqt5/","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://shjlone.github.io/tags/Qt/"}]},{"title":"快捷键处理","slug":"PyQt/快捷键处理","date":"2021-06-07T01:45:07.546Z","updated":"2021-06-07T01:45:07.546Z","comments":true,"path":"wiki/PyQt/快捷键处理/","link":"","permalink":"http://shjlone.github.io/wiki/PyQt/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%84%E7%90%86/","excerpt":"","text":"屏蔽alt+F4等快捷键12345678910111213141516171819202122232425262728class GlobalEventFilter(QAbstractNativeEventFilter): def __init__(self): super(GlobalEventFilter, self).__init__() def nativeEventFilter(self, event_type, sip_voidptr): if event_type == &quot;windows_generic_MSG&quot; or event_type == &quot;windows_dispatcher_MSG&quot;: msg = MSG.from_address(sip_voidptr.__init__()) if msg.message in [WM_KEYDOWN, WM_SYSKEYDOWN]: if VK_F4 == msg.wParam and win32api.GetKeyState(VK_MENU) &amp; 0xF000: return True, 1 # True 代表我处理了消息，不需要Qt处理 elif VK_ESCAPE == msg.wParam: return True, 1 # 屏蔽esc键 return False, 1class App(QApplication): def __init__(self, *args): super(App, self).__init__(*args) self.global_event_filter = GlobalEventFilter() self.intallNativeEventFilter(self.global_event_filter) def exit_app(self): self.removeNativeEventFilter(self.global_event_filter)","raw":null,"content":null,"categories":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/categories/PyQt/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"http://shjlone.github.io/tags/PyQt/"}]},{"title":"Android逆向之脱壳","slug":"Android/逆向/Android逆向之脱壳","date":"2021-06-07T01:45:07.545Z","updated":"2021-06-07T01:45:07.545Z","comments":true,"path":"wiki/Android/逆向/Android逆向之脱壳/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E9%80%86%E5%90%91/Android%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3/","excerpt":"","text":"有些App为了安全，会使用相关加壳工具来提高破解难度。但其实意义不大，通过hook，应该是很容易获取内存dump出dex文件的。还记得以前进行flash游戏破解的时候，当时使用一个技巧，通过flash的运行机制，在swf启动的时候将自己写的swfload进来并运行，运行的代码就是将内存中的swf导出来。破解成功的概率非常高。而个人认为，通过代码混淆来增加阅读难度比加壳的作用更有用。 最近看到某款竟品，于是想学习学习，直接放到Jadx中，嗯哼，竟然使用了腾讯乐固。了解了大致破壳的原理，其实就算自己实现也是可行的。不过自己能想到的事情，可能有人早就想到了。搜一搜吧，果然有很多破解工具。有些文章可以参考参考、学习学习： https://crifan.github.io/android_app_security_crack/website/ 我们的目的是为了快速获取dex，阅读源码，所以就不折腾每个工具是怎么实现的了。找到文章说的工具，一个一个试吧。最终发现ReflectMaster可以dump出来dex。使用如下： 安装ReflectMaster，下载地址：https://www.lanzous.com/i6x1kaf 在xposed环境中，安装并激活。 启动对应带壳的App，点击”中间的图标”，点击”当前Activity”，点击”导出dex”。 确认使用腾讯乐固： 导出的dex如下： 参考 https://github.com/FormatFa/ReflectMaster https://www.kanxue.com/chm.htm?id=9948&amp;pid=node1000000 https://blog.csdn.net/qq_41855420/article/details/106276824 https://www.kanxue.com/chm.htm?id=9948&amp;pid=node1000000","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://shjlone.github.io/categories/Android/%E9%80%86%E5%90%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android逆向之Xposed","slug":"Android/逆向/Android逆向之Xposed","date":"2021-06-07T01:45:07.544Z","updated":"2021-06-07T01:45:07.544Z","comments":true,"path":"wiki/Android/逆向/Android逆向之Xposed/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E9%80%86%E5%90%91/Android%E9%80%86%E5%90%91%E4%B9%8BXposed/","excerpt":"","text":"Xposed的作用非常强大，以前虽然也大致了解，但没有自己实践过。最近在做其他App分析的时候，发现其限制了模拟器的使用，于是想着逆向破解一下，于是开启了Xposed之旅。 首先阅读下官网，嗯，版本很久没有更新了，后面又出现了”太极”之类的新的工具。就不折腾那么多了，先以快速解决问题为目标。下载雷电模拟器，其版本为Android7.1.2。进入”雷电游戏中心”搜索xposed，下载对应的App，打开后点击安装，重启。 Hello World下一步完成一个最简单的Hello World，网上搜有一大把。总结下： 添加依赖，目前最新的版本为82： 12compileOnly &#x27;de.robv.android.xposed:api:82&#x27;compileOnly &#x27;de.robv.android.xposed:api:82:sources&#x27; 修改AndroidManifest.xml文件，添加相应标识，用于Xposed识别。 1234567891011&lt;meta-data android:name=&quot;xposedmodule&quot; android:value=&quot;true&quot; /&gt;&lt;meta-data android:name=&quot;xposeddescription&quot; android:value=&quot;这是一个Xposed例程&quot; /&gt;&lt;meta-data android:name=&quot;xposedminversion&quot; android:value=&quot;53&quot; /&gt; 新建assets文件夹，添加xposed_init文件，添加hook启动入口，文件内容为你的hook类。 添加hook类，实现IXposedHookLoadPackage，实现handleLoadPackage方法。 熟悉API https://api.xposed.info/reference/packages.html 12345/**当App装载的时候会被调用，被调用的非常早，比Application.onCreate还早。*/public abstract void handleLoadPackage (XC_LoadPackage.LoadPackageParam lpparam) xposed工具开发者助手:下载地址：https://github.com/WrBug/DeveloperHelper 可以直接在界面上看到UI的名字，可以查看log Inspeckage：下载地址：https://repo.xposed.info/module/mobi.acpm.inspeckage 在网页上看相关信息：包信息，Shared Preferences，使用了Crypto、Hash的记录，抓包信息等 JustTrustMe：https://github.com/Fuzion24/JustTrustMe UCrack：https://gitee.com/virjar/ucrack 一个基于Xposed写的辅助工具，集成了自动网络抓包、网络堆栈爆破、文件日志、WebView调试环境、自动脱壳、Native函数注册监控、记录程序自杀堆栈等功能。 ReflectMaster（反射大师）：https://github.com/FormatFa/ReflectMaster 可以从当前页面提取dex，对于加壳的App很有用。","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://shjlone.github.io/categories/Android/%E9%80%86%E5%90%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"内存溢出分析","slug":"Android/性能优化/OOM专题/内存溢出分析","date":"2021-06-07T01:45:07.544Z","updated":"2021-06-10T09:22:08.442Z","comments":true,"path":"wiki/Android/性能优化/OOM专题/内存溢出分析/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/","excerpt":"","text":"概述OOM(Out of Memory)即内存溢出，是因为应用所需要分配的内存超过系统对应用内存的阈值，而抛出java.lang.OutOfMemoryError错误。 其根本原因是对象的生命周期不一致，导致内存泄漏。 内存泄漏和内存溢出的区别 内存溢出 是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。 内存泄漏 是指程序在申请内存后，无法释放已申请的内存空间。内存泄漏最终会导致内存溢出。 栈内存溢出和堆内存溢出堆內存溢出 抛出”StackOverflowError”的原因：线程请求的栈深度大于JVM所允许的最大深度。所以根本原因是，某个线程所需的栈内存超过了JVM的限制，而此时物理内存仍有足够的可用空间。出现的情况：方法中无限递归调用。 抛出”OutOfMemoryError”的原因：无法（向操作系统）申请到足够的内存空间用来拓展栈。根本原因是，（操作系统管理的）物理内存已没有足够的可用内存分配给JVM的栈使用。出现的情况：方法中不停的创建线程。 栈內存溢出 new出来的对象所需内存不够了 可能出现OOM的场景静态变量导致的内存泄漏描述比如某个静态变量持有Activity，则当Activity生命周期结束时不会被释放 解决办法：在生命周期结束时释放静态变量 单例模式导致的内存泄漏描述单例持有Activity 解决办法如果需要持有Context，则使用ApplicationContext 属性动画导致的内存泄漏for循环中不停的创建局部变量非静态内部类（包括匿名内部类）默认会持有外部类的引用当非静态内部类对象的生命周期，比外部类对象的生命周期长时，可能会导致内存泄漏。常出现于Handler、Thread、AsyncTask 解决方案：handler用static声明，使用软引用。 http://cashow.github.io/Android-Anonymous-Inner-Class-Leaks-Memory.html 未取消注册或回调导致的内存泄漏比如在Activity中注册广播，如果Activity销毁后不取消注册，那么这个广播就会一直存在系统中 一些处理方式在onDestroy中手动释放View上的资源，降低因为OOM而导致的内存消耗 参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"OOM专题","slug":"Android/性能优化/OOM专题","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"WindowManager","slug":"Android/基础/WindowManager","date":"2021-06-07T01:45:07.543Z","updated":"2021-06-10T10:16:23.270Z","comments":true,"path":"wiki/Android/基础/WindowManager/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/WindowManager/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"XML解析过程和原理","slug":"Android/基础/XML解析过程和原理","date":"2021-06-07T01:45:07.543Z","updated":"2021-06-10T10:16:32.953Z","comments":true,"path":"wiki/Android/基础/XML解析过程和原理/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/XML%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"native crash 分析","slug":"Android/性能优化/native crash分析","date":"2021-06-07T01:45:07.543Z","updated":"2021-06-07T01:45:07.543Z","comments":true,"path":"wiki/Android/性能优化/native crash分析/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/native%20crash%E5%88%86%E6%9E%90/","excerpt":"","text":"Crash类型： Framework/App Crash：Java层崩溃 Native Crash：C/C++层崩溃 Kernel Crash：内核崩溃 tombstone文件的组成部分： Build fingerprint Crashed process and PIDS Terminated signal and fault address CPU registers Call stack Stack content of each call 12345678910111213--logversion:utraceaProcess Name: &#x27;com.feiteng.lieyou&#x27;Thread Name: &#x27;RenderThread&#x27;pid: 25031, tid: 25237 &gt;&gt;&gt; com.feiteng.lieyou &lt;&lt;&lt;killed by pid: 25031, comm: .feiteng.lieyou, uid: 10125.signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------r0 00000000 r1 00006295 r2 00000006 r3 00000008r4 c587c978 r5 00000006 r6 c587c920 r7 0000010cr8 bf249bc8 r9 00000000 10 bf249bbc fp bf249bb8ip 00000004 sp c587c3b0 lr eba21907 pc eba24188 cpsr 20070010d0 0000000000000000 d1 0000000000000000d2 0000000000000000 d3 0000000000000000 signal指定异常类型。如果pid等于tid，则说明程序是在主线程中崩溃。 信号类型: 软中断信号（signal，又简称为信号）用来通知进程发生了事件。进程之间可以通过调用kill库函数发送软中断信号。Linux内核也可能给进程发送信号，通知进程发生了某个事件（例如内存越界）。 信号只是用来通知某进程发生了什么事件，无法给进程传递任何数据，进程对信号的处理方法有三种： 第一种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。 第二种是设置中断的处理函数，收到信号后，由该函数来处理。 第三种方法是，对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//信号监听sighandler_t signal(int signum, sighandler_t handler);/*参数signum表示信号的编号。参数handler表示信号的处理方式，有三种情况：1）SIG_IGN：忽略参数signum所指的信号。2）一个自定义的处理信号的函数，信号的编号为这个自定义函数的参数。3）SIG_DFL：恢复参数signum所指信号的处理方法为默认值。*///发送信号int kill(pid_t pid, int sig);/*kill函数将参数sig指定的信号给参数pid 指定的进程。参数pid 有几种情况：1）pid&gt;0 将信号传给进程号为pid 的进程。2）pid=0 将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号。3）pid=-1 将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。返回值说明： 成功执行时，返回0；失败返回-1，errno被设为以下的某个值。EINVAL：指定的信号码无效（参数 sig 不合法）。EPERM：权限不够无法传送信号给指定进程。ESRCH：参数 pid 所指定的进程或进程组不存在。*/#define SIGHUP 1 // 终端连接结束时发出(不管正常或非正常)#define SIGINT 2 // 程序终止(例如Ctrl-C)#define SIGQUIT 3 // 程序退出(Ctrl-\\)#define SIGILL 4 // 执行了非法指令，或者试图执行数据段，堆栈溢出#define SIGTRAP 5 // 断点时产生，由debugger使用#define SIGABRT 6 // 调用abort函数生成的信号，表示程序异常#define SIGIOT 6 // 同上，更全，IO异常也会发出#define SIGBUS 7 // 非法地址，包括内存地址对齐出错，比如访问一个4字节的整数, 但其地址不是4的倍数#define SIGFPE 8 // 计算错误，比如除0、溢出#define SIGKILL 9 // 强制结束程序，具有最高优先级，本信号不能被阻塞、处理和忽略#define SIGUSR1 10 // 未使用，保留#define SIGSEGV 11 // 非法内存操作，与SIGBUS不同，他是对合法地址的非法访问，比如访问没有读权限的内存，向没有写权限的地址写数据#define SIGUSR2 12 // 未使用，保留#define SIGPIPE 13 // 管道破裂，通常在进程间通信产生#define SIGALRM 14 // 定时信号,#define SIGTERM 15 // 结束程序，类似温和的SIGKILL，可被阻塞和处理。通常程序如果终止不了，才会尝试SIGKILL#define SIGSTKFLT 16 // 协处理器堆栈错误#define SIGCHLD 17 // 子进程结束时, 父进程会收到这个信号。#define SIGCONT 18 // 让一个停止的进程继续执行#define SIGSTOP 19 // 停止进程,本信号不能被阻塞,处理或忽略#define SIGTSTP 20 // 停止进程,但该信号可以被处理和忽略#define SIGTTIN 21 // 当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号#define SIGTTOU 22 // 类似于SIGTTIN, 但在写终端时收到#define SIGURG 23 // 有紧急数据或out-of-band数据到达socket时产生#define SIGXCPU 24 // 超过CPU时间资源限制时发出#define SIGXFSZ 25 // 当进程企图扩大文件以至于超过文件大小资源限制#define SIGVTALRM 26 // 虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.#define SIGPROF 27 // 类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间#define SIGWINCH 28 // 窗口大小改变时发出#define SIGIO 29 // 文件描述符准备就绪, 可以开始进行输入/输出操作#define SIGPOLL SIGIO // 同上，别称#define SIGPWR 30 // 电源异常#define SIGSYS 31 // 非法的系统调用 tombstone 文件位于路径 /data/tombstones/下 调用栈信息 调用栈信息是分析程序崩溃的非常重要的一个信息，它主要记录了程序在 Crash 前的函数调用关系以及当前正在执行函数的信息，它对应的是我们 tombstone 文件中 backtrace 符号开始的信息，上面例子中的 backtrace 的信息如下所示 12345678910backtrace: #00 pc 00006639 /system/lib/libui.so (android::Fence::waitForever(char const*)+41) #01 pc 00034b86 /system/lib/libsurfaceflinger.so #02 pc 0003229e /system/lib/libsurfaceflinger.so #03 pc 0002cb9c /system/lib/libgui.so (android::BufferQueue::ProxyConsumerListener::onFrameAvailable(android::BufferItem const&amp;)+652) #04 pc 000342f4 /system/lib/libgui.so (android::BufferQueueProducer::queueBuffer(int, android::IGraphicBufferProducer::QueueBufferInput const&amp;, android::IGraphicBufferProducer::QueueBufferOutput*)+2580) ##00 等表示函数调用栈中栈帧的编号 pc 后面的16进制数表示当前函数正在执行语句在共享链接库或可执行文件的位置 最后一行表示当前指令在哪个文件 如何定位崩溃位置常用工具nm 12查看动态库的符号表nm -D libName.so | grep symbel symbolName addr2line 12345678910111213141516171819Usage: /Users/loneqd/Android/sdk/ndk-bundle/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line [option(s)] [addr(s)] Convert addresses into line number/file name pairs. If no addresses are specified on the command line, they will be read from stdin The options are: @&lt;file&gt; Read options from &lt;file&gt; -a --addresses Show addresses -b --target=&lt;bfdname&gt; Set the binary file format -e --exe=&lt;executable&gt; Set the input file name (default is a.out) -i --inlines Unwind inlined functions -j --section=&lt;name&gt; Read section-relative offsets instead of addresses -p --pretty-print Make the output easier to read for humans -s --basenames Strip directory names -f --functions Show function names -C --demangle[=style] Demangle function names -h --help Display this information -v --version Display the program&#x27;s version实例：(需使用带symbol的动态库)addr2line -f -e libui.so 00006639 _ZN7android5Fence11waitForeverE ndk-stack 将崩溃时的调用内存地址和C++代码对应起来 123456789101112131415usage: ndk-stack.py [-h] -sym SYMBOL_DIR [-i INPUT]Symbolizes Android crashes.optional arguments: -h, --help show this help message and exit -sym SYMBOL_DIR, --sym SYMBOL_DIR directory containing unstripped .so files -i INPUT, -dump INPUT, --dump INPUT input filenameSee &lt;https://developer.android.com/ndk/guides/ndk-stack&gt;.sym指项目编译成功之后，obj目录dump指崩溃文件 xCrash的使用 https://github.com/iqiyi/xCrash native异常日志文件的格式 12345678910111213日志分为： 头部信息（为应用的基本信息） 异常信号部分。（哪个异常信号导致异常，信号参见Linux信号） backtrace so库的编译信息，build id 堆栈信息 内存信息 内存映射 logcat日志输出部分，包括main,system,event app应用进程打开的文件描述符 内存信息 app应用进程信息 异常回调填充信息 一般根据backtrace，再使用addr2line命令定位具体的错误代码位置。 参考 http://gityuan.com/2016/06/25/android-native-crash/ https://toutiao.io/posts/jflx6c/preview https://source.android.google.cn/devices/tech/debug/native-crash?hl=zh-cn http://www.droidsec.cn/%E5%B8%B8%E8%A7%81android-native%E5%B4%A9%E6%BA%83%E5%8F%8A%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A0/ https://github.com/iqiyi/xCrash https://source.android.com/devices/tech/debug xCrash日志文件格式","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"Apk打包流程","slug":"Android/性能优化/APK打包流程","date":"2021-06-07T01:45:07.543Z","updated":"2021-06-07T01:45:07.543Z","comments":true,"path":"wiki/Android/性能优化/APK打包流程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/APK%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android的消息机制","slug":"Android/基础/Android的消息机制","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-07T01:45:07.542Z","comments":true,"path":"wiki/Android/基础/Android的消息机制/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"BroadcastReceiver工作过程","slug":"Android/基础/BroadcastReceiver工作过程","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-10T10:15:12.515Z","comments":true,"path":"wiki/Android/基础/BroadcastReceiver工作过程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/BroadcastReceiver%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"ContentProvider工作过程","slug":"Android/基础/ContentProvider工作过程","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-10T10:15:58.417Z","comments":true,"path":"wiki/Android/基础/ContentProvider工作过程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/ContentProvider%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Service工作过程","slug":"Android/基础/Service工作过程","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-10T10:15:58.415Z","comments":true,"path":"wiki/Android/基础/Service工作过程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Service%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"View的事件分发机制","slug":"Android/基础/View的事件分发机制","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-08T07:57:51.089Z","comments":true,"path":"wiki/Android/基础/View的事件分发机制/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/","excerpt":"","text":"分发过程事件分发过程由三个方法共同完成： dispatchTouchEvent：方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件，返回为false表示交给父类的onTouchEvent处理。 onInterceptTouchEvent：方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图。如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 如果该View存在子View且点击到了该子View, 则不拦截, 继续分发 给子View 处理, 此时相当于return false。 如果该View没有子View或者有子View但是没有点击中子View(此时ViewGroup 相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。 注意：一般的LinearLayout、 RelativeLayout、FrameLayout等ViewGroup默认不拦截， 而 ScrollView、ListView等ViewGroup则可能拦截，得看具体情况。 onTouchEvent：方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况： 如果该View是clickable或者longclickable的,则会返回true, 表示消费 了该事件, 与返回true一样; 如果该View不是clickable或者longclickable的,则会返回false, 表示不 消费该事件,将会向上传递,与返回false一样。 注意：在Android系统中，拥有事件传递处理能力的类有以下三种： Activity：拥有分发和消费两个方法。 ViewGroup：拥有分发、拦截和消费三个方法。 View：拥有分发、消费两个方法。 三个方法的关系用伪代码表示如下： 12345678910public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; coonsume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 通过上面的伪代码，我们可以大致了解点击事件的传递规则：对应一个根ViewGroup来说，点击事件产生后，首先会传递给它，这是它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，这时如果它的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。在onTouchEvent中，如果设置了mOnCLickListener，则onClick会被调用。只要View的CLICKABLE和LONG_CLICKABLE有一个为true，onTouchEvent()就会返回true消耗这个事件。如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。一些重要的结论： 1、事件传递优先级：onTouchListener.onTouch &gt; onTouchEvent &gt; onClickListener.onClick。 2、正常情况下，一个时间序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_DOWN等事件直接交给它来处理）。特例：通过将重写View的onTouchEvent返回false可强行将事件转交给其他View处理。 3、如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。 4、ViewGroup默认不拦截任何事件（返回false）。 5、View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。 6、View的enable属性不影响onTouchEvent的默认返回值。 7、通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。 记住这个图的传递顺序,面试的时候能够画出来,就很详细了： imageACTION_CANCEL什么时候触发，触摸button然后滑动到外部抬起会触发点击事件吗，再滑动回去抬起会么？ 一般ACTION_CANCEL和ACTION_UP都作为View一段事件处理的结束。如果在父View中拦截ACTION_UP或ACTION_MOVE，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到ACTION_CANCEL事件。 如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现action_cancel。 点击事件被拦截，但是想传到下面的View，如何操作？ 重写子类的requestDisallowInterceptTouchEvent()方法返回true就不会执行父类的onInterceptTouchEvent()，即可将点击事件传到下面的View。如何解决View的事件冲突？举个开发中遇到的例子？ 常见开发中事件冲突的有ScrollView与RecyclerView的滑动冲突、RecyclerView内嵌同时滑动同一方向。 滑动冲突的处理规则： 对于由于外部滑动和内部滑动方向不一致导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件。 对于由于外部滑动方向和内部滑动方向一致导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件，何时由内部View拦截事件。 对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破点。 滑动冲突的实现方法： 外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。具体方法：需要重写父容器的onInterceptTouchEvent方法，在内部做出相应的拦截。 内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法：需要配合requestDisallowInterceptTouchEvent方法。 参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"View的基本概念","slug":"Android/基础/View的基本概念","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-07T01:45:07.542Z","comments":true,"path":"wiki/Android/基础/View的基本概念/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/View%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"View的工作原理","slug":"Android/基础/View的工作原理","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-07T01:45:07.542Z","comments":true,"path":"wiki/Android/基础/View的工作原理/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"目录 绘制的流程概要 measure MeasureSpec ViewGroup的measure View的measure layout View的layout流程 Layout的onLayout draw 常见问题 参考 DecorView是视图的顶级View，我们添加的布局文件是它的一个子布局，而ViewRootImpl则负责渲染视图，它调用了一个performTraveals方法使得ViewTree开始三大工作流程，然后使得View展现在我们面前。 绘制的流程概要 注意：这里的三个步骤是每次从根视图到最上层视图依次执行完，再进行下一步骤。 三个步骤： 测量（Measure）：测量视图大小。从顶层父View到子View递归调用measure方法，measure方法又回调OnMeasure。 布局（Layout）：确定View位置，进行页面布局。从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小和布局参数，将子View放在合适的位置上。 绘制（draw）：绘制视图。ViewRoot创建一个Canvas对象，然后调用OnDraw()。六个步骤：①、绘制视图的背景；②、保存画布的图层（Layer）；③、绘制View的内容；④、绘制View子视图，如果没有就不用；⑤、还原图层（Layer）；⑥、绘制滚动条 绘制从ViewRootImpl的performTraversals()方法开始，从上到下遍历整个视图树，每个View控件负责绘制自己，而ViewGroup还需要负责通知自己的子View进行绘制操作。 12345678910111213141516private void performTraversals() &#123; ... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ... //执行测量流程 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... //执行布局流程 performLayout(lp, desiredWindowWidth, desiredWindowHeight); ... //执行绘制流程 performDraw();&#125; measureMeasureSpecMeasureSpec表示的是一个32位的整形值，它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize。 mode的模式分为： EXACTLY：对应LayoutParams中的match_parent和具体数值这两种模式。检测到View所需要的精确大小，这时候View的最终大小就是SpecSize所指定的值， AT_MOST ：对应LayoutParams中的wrap_content。View的大小不能大于父容器的大小。 UNSPECIFIED ：不对View进行任何限制，要多大给多大，一般用于系统内部，如ListView，ScrollView 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** * UNSPECIFIED 模式： * 父View不对子View有任何限制，子View需要多大就多大 */ public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; /** * EXACTYLY 模式： * 父View已经测量出子Viwe所需要的精确大小，这时候View的最终大小 * 就是SpecSize所指定的值。对应于match_parent和精确数值这两种模式 */ public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; /** * AT_MOST 模式： * 子View的最终大小是父View指定的SpecSize值，并且子View的大小不能大于这个值， * 即对应wrap_content这种模式 */ public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; //将size和mode打包成一个32位的int型数值 //高2位表示SpecMode，测量模式，低30位表示SpecSize，某种测量模式下的规格大小 public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; //将32位的MeasureSpec解包，返回SpecMode,测量模式 public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; //将32位的MeasureSpec解包，返回SpecSize，某种测量模式下的规格大小 public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; //... &#125; ViewGroup的measure由于DecorView继承自FrameLayout，是PhoneWindow的一个内部类，而FrameLayout没有measure方法，因此调用的是父类View的measure方法。 View的measurelayoutView的layout流程123456789101112131415161718192021222324// ViewRootImpl.javaprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; ... host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ...&#125;// View.javapublic void layout(int l, int t, int r, int b) &#123; ... // 通过setFrame方法来设定View的四个顶点的位置，即View在父容器中的位置 boolean changed = isLayoutModeOptical(mParent) ? set OpticalFrame(l, t, r, b) : setFrame(l, t, r, b); ... onLayout(changed, l, t, r, b); ...&#125;// 空方法，子类如果是ViewGroup类型，则重写这个方法，实现ViewGroup// 中所有View控件布局流程protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; Layout的onLayout12345678910111213141516171819202122232425262728293031323334353637383940414243protected void onlayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l,) &#125;&#125;// layoutVertical核心源码void layoutVertical(int left, int top, int right, int bottom) &#123; ... final int count = getVirtualChildCount(); for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasureWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); ... if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; // 为子元素确定对应的位置 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); // childTop会逐渐增大，意味着后面的子元素会被 // 放置在靠下的位置 childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child,i) &#125; &#125;&#125;private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height);&#125; draw12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void performDraw() &#123; ... draw(fullRefrawNeeded); ...&#125;private void draw(boolean fullRedrawNeeded) &#123; ... if (!drawSoftware(surface, mAttachInfo, xOffest, yOffset, scalingRequired, dirty)) &#123; return; &#125; ...&#125;private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scallingRequired, Rect dirty) &#123; ... mView.draw(canvas); ...&#125;// 绘制基本上可以分为六个步骤public void draw(Canvas canvas) &#123; ... // 步骤一：绘制View的背景 drawBackground(canvas); ... // 步骤二：如果需要的话，保持canvas的图层，为fading做准备 saveCount = canvas.getSaveCount(); ... canvas.saveLayer(left, top, right, top + length, null, flags); ... // 步骤三：绘制View的内容 onDraw(canvas); ... // 步骤四：绘制View的子View dispatchDraw(canvas); ... // 步骤五：如果需要的话，绘制View的fading边缘并恢复图层 canvas.drawRect(left, top, right, top + length, p); ... canvas.restoreToCount(saveCount); ... // 步骤六：绘制View的装饰(例如滚动条等等) onDrawForeground(canvas)&#125; 常见问题如何在onCreate中获取View的高宽12345678910111213141516171819202122//方法1：view.post(new Runnable() &#123; @Override public void run() &#123; int width = view.getWidth(); int measuredWidth = view.getMeasuredWidth(); Log.i(TAG, &quot;width: &quot; + width); Log.i(TAG, &quot;measuredWidth: &quot; + measuredWidth); &#125; &#125;);//方法2：ViewTreeObserver vto = view.getViewTreeObserver(); vto.addOnGlobalLayoutListener(new OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; view.getViewTreeObserver().removeGlobalOnLayoutListener(this); Log.i(TAG, &quot;width: &quot; + view.getWidth()); Log.i(TAG, &quot;height: &quot; + view.getHeight()); &#125; &#125;); 参考 https://jsonchao.github.io/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Binder","slug":"Android/进阶知识/Binder","date":"2021-06-07T01:45:07.542Z","updated":"2021-06-07T01:45:07.542Z","comments":true,"path":"wiki/Android/进阶知识/Binder/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/Binder/","excerpt":"","text":"Android中IPC的不同方式比较 名称 优点 缺点 适用场景 Bundle 简单易用 只能传输Bundle支持的数据类型 四大组件间的进程间通信 文件共享 简单易用 不适合高并发场景，并且无法做到进程间的即时通信 无并发访问场景 AIDL 功能强大，支持一对多并发通信，支持实时通信 无 一对多通信且有RPC需求 Messager 功能一般，支持一对多并发通信，支持实时通信 不能很好处理高并发场景，不支持RPC 低并发的一对多通信，无RPC需求 ContentProvider 在数据源访问方面功能强大 Socket 功能强大","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"进阶知识","slug":"Android/进阶知识","permalink":"http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Activity工作过程","slug":"Android/基础/Activity工作过程","date":"2021-06-07T01:45:07.541Z","updated":"2021-06-10T05:54:25.088Z","comments":true,"path":"wiki/Android/基础/Activity工作过程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Activity%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/","excerpt":"","text":"概述流程分析流程图 Activity的启动从startActivity开始，代码会运行到Activity的startActivityForResult方法。 123456789101112131415161718192021222324252627282930313233343536373839Activity.javapublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125;&#125; mParent代表的是ActivityGroup，ActivityGroup最开始被用来在一个界面中嵌入多个子Activity，但是其在API 13中已经被废弃了，系统推荐采用Fragment来代替ActivityGroup。 mMainThread.getApplicationThread()这个参数，它的类型是ApplicationThread，ApplicationThread是ActivityThread的内部类，继承IApplicationThread.Stub，也是个Binder对象。 接下来看看execStartActivity方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899Instrumentation.java@UnsupportedAppUsagepublic ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) &#123; result = am.onStartActivity(intent); &#125; if (result != null) &#123; am.mHits++; return result; &#125; else if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityTaskManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //检查Activity启动的结果 //比如如果没有注册，则会抛出ActivityNotFoundException checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(&quot;Failure from system&quot;, e); &#125; return null;&#125;public static void checkStartActivityResult(int res, Object intent) &#123; if (!ActivityManager.isStartResultFatalError(res)) &#123; return; &#125; switch (res) &#123; case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) throw new ActivityNotFoundException( &quot;Unable to find explicit activity class &quot; + ((Intent)intent).getComponent().toShortString() + &quot;; have you declared this activity in your AndroidManifest.xml?&quot;); throw new ActivityNotFoundException( &quot;No Activity found to handle &quot; + intent); case ActivityManager.START_PERMISSION_DENIED: throw new SecurityException(&quot;Not allowed to start activity &quot; + intent); case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: throw new AndroidRuntimeException( &quot;FORWARD_RESULT_FLAG used while also requesting a result&quot;); case ActivityManager.START_NOT_ACTIVITY: throw new IllegalArgumentException( &quot;PendingIntent is not an activity&quot;); case ActivityManager.START_NOT_VOICE_COMPATIBLE: throw new SecurityException( &quot;Starting under voice control not allowed for: &quot; + intent); case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION: throw new IllegalStateException( &quot;Session calling startVoiceActivity does not match active session&quot;); case ActivityManager.START_VOICE_HIDDEN_SESSION: throw new IllegalStateException( &quot;Cannot start voice activity on a hidden session&quot;); case ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION: throw new IllegalStateException( &quot;Session calling startAssistantActivity does not match active session&quot;); case ActivityManager.START_ASSISTANT_HIDDEN_SESSION: throw new IllegalStateException( &quot;Cannot start assistant activity on a hidden session&quot;); case ActivityManager.START_CANCELED: throw new AndroidRuntimeException(&quot;Activity could not be started for &quot; + intent); default: throw new AndroidRuntimeException(&quot;Unknown error code &quot; + res + &quot; when starting &quot; + intent); &#125;&#125; 这里使用了ActivityTaskManager来启动Activity。ActivityTaskManager是一个Binder。ActivityTaskManager.getService()会返回Activity服务管理器ActivityManagerService(Android10返回ActivityTaskManagerService)。 ATMS是在Android10中新增的，分担了之前ActivityManagerService（AMS）的一部分功能（activity task相关）。在Android10 之前 ，这个地方获取的是服务是AMS。查看Android10的AMS，你会发现startActivity方法内也是调用了ATMS的startActivity方法。所以在理解上，ATMS就隶属于AMS。 接下来要去ActivityTaskManagerService看看了 Activity的管理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ActivityTaskManagerService.java@Overridepublic final int startActivities(IApplicationThread caller, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle bOptions, int userId) &#123; final String reason = &quot;startActivities&quot;; enforceNotIsolatedCaller(reason); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, reason); // TODO: Switch to user app stacks here. return getActivityStartController().startActivities(caller, -1, 0, -1, callingPackage, intents, resolvedTypes, resultTo, SafeActivityOptions.fromBundle(bOptions), userId, reason, null /* originatingPendingIntent */, false /* allowBackgroundActivityStart */);&#125;@Overridepublic int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true /*validateIncomingUser*/);&#125;int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) &#123; enforceNotIsolatedCaller(&quot;startActivityAsUser&quot;); userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), &quot;startActivityAsUser&quot;); // TODO: Switch to user app stacks here. return getActivityStartController().obtainStarter(intent, &quot;startActivityAsUser&quot;) .setCaller(caller) .setCallingPackage(callingPackage) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setMayWait(userId) .execute();&#125; getActivityStartController().obtainStarter方法获取ActivityStarter实例，进去看看execute。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596ActivityStarter.java/** * Starts an activity based on the request parameters provided earlier. * @return The starter result. */int execute() &#123; try &#123; // TODO(b/64750076): Look into passing request directly to these methods to allow // for transactional diffs and preprocessing. if (mRequest.mayWait) &#123; //也会执行到startActivity方法 return startActivityMayWait(mRequest.caller, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.intent, mRequest.resolvedType, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.startFlags, mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart); &#125; else &#123; return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent, mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.callingPid, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.componentSpecified, mRequest.outActivity, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart); &#125; &#125; finally &#123; onExecutionComplete(); &#125;&#125;private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity, boolean restrictedBgActivity) &#123; int result = START_CANCELED; final ActivityStack startedActivityStack; try &#123; mService.mWindowManager.deferSurfaceLayout(); result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity, restrictedBgActivity); ... &#125; private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity, boolean restrictedBgActivity) &#123;...if (mDoResume) &#123; final ActivityRecord topTaskActivity = mStartActivity.getTaskRecord().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; // If the activity is not focusable, we can&#x27;t resume it, but still would like to // make sure it becomes visible as it starts (this will also trigger entry // animation). An example of this are PIP activities. // Also, we don&#x27;t want to resume activities in a task that currently has an overlay // as the starting activity just needs to be in the visible paused state until the // over is removed. mTargetStack.ensureActivitiesVisibleLocked(mStartActivity, 0, !PRESERVE_WINDOWS); // Go ahead and tell window manager to execute app transition for this activity // since the app transition will not be triggered through the resume channel. mTargetStack.getDisplay().mDisplayContent.executeAppTransition(); &#125; else &#123; // If the target stack was not previously focusable (previous top running activity // on that stack was not visible) then any prior calls to move the stack to the // will not update the focused stack. If starting the new activity now allows the // task stack to be focusable, then ensure that we now update the focused stack // accordingly. if (mTargetStack.isFocusable() &amp;&amp; !mRootActivityContainer.isTopDisplayFocusedStack(mTargetStack)) &#123; mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;); &#125; mRootActivityContainer.resumeFocusedStacksTopActivities( mTargetStack, mStartActivity, mOptions); &#125;&#125; else if (mStartActivity != null) &#123; mSupervisor.mRecentTasks.add(mStartActivity.getTaskRecord());&#125;mRootActivityContainer.updateUserStack(mStartActivity.mUserId, mTargetStack);...&#125; startActivityMayWait最终也是会进入startActivity，startActivity调用了startActivityUnchecked，startActivityUnchecked调用了mRootActivityContainer.resumeFocusedStacksTopActivities(mTargetStack, mStartActivity, mOptions);。mRootActivityContainer是RootActivityContainer，Android10新增到API，分担了ActivityStackSupervisor部分功能。接着看看RootActivityContainer 12345678910111213141516RootActivityContainer.javaboolean resumeFocusedStacksTopActivities( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (!mStackSupervisor.readyToResume()) &#123; return false; &#125; boolean result = false; if (targetStack != null &amp;&amp; (targetStack.isTopStackOnDisplay() || getTopDisplayFocusedStack() == targetStack)) &#123; result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; ... &#125; 接着跳转到了ActivityStack的resumeTopActivityUncheckedLocked方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778ActivityStack.java@GuardedBy(&quot;mService&quot;)boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; if (mInResumeTopActivity) &#123; // Don&#x27;t even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mInResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); // When resuming the top activity, it may be necessary to pause the top activity (for // example, returning to the lock screen. We suppress the normal pause logic in // &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the // end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here // to ensure any necessary pause logic occurs. In the case where the Activity will be // shown regardless of the lock screen, the call to // &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped. final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */); if (next == null || !next.canTurnScreenOn()) &#123; checkReadyForSleep(); &#125; &#125; finally &#123; mInResumeTopActivity = false; &#125; return result;&#125;@GuardedBy(&quot;mService&quot;)private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;... boolean pausing = getDisplay().pauseBackStacks(userLeaving, next, false); if (mResumedActivity != null) &#123; if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity); // 暂停上一个Activity pausing |= startPausingLocked(userLeaving, false, next, false); &#125; ... //这里next.attachedToProcess()，只有启动了的Activity才会返回true if (next.attachedToProcess()) &#123; ... try &#123; final ClientTransaction transaction = ClientTransaction.obtain(next.app.getThread(), next.appToken); ... //启动了的Activity就发送ResumeActivityItem事务给客户端了，后面会讲到 transaction.setLifecycleStateRequest( ResumeActivityItem.obtain(next.app.getReportedProcState(), getDisplay().mDisplayContent.isNextTransitionForward())); mService.getLifecycleManager().scheduleTransaction(transaction); .... &#125; catch (Exception e) &#123; .... mStackSupervisor.startSpecificActivityLocked(next, true, false); return true; &#125; .... &#125; else &#123; .... if (SHOW_APP_STARTING_PREVIEW) &#123; //这里就是 冷启动时 出现白屏 的原因了：取根Activity的主题背景 展示StartingWindow next.showStartingWindow(null , false ,false); &#125; // 继续当前Activity，普通Activity的正常启动 关注这里即可 //ActivityStackSupervisor.java mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; return true;&#125; 接下来到了ActivityStackSupervisor的startSpecificActivityLocked方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677ActivityStackSupervisor.javavoid startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity&#x27;s application already running? final WindowProcessController wpc = mService.getProcessController(r.processName, r.info.applicationInfo.uid); boolean knownToBeDead = false; if (wpc != null &amp;&amp; wpc.hasThread()) &#123; try &#123; realStartActivityLocked(r, wpc, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); &#125; knownToBeDead = true; &#125; ... try &#123; if (Trace.isTagEnabled(TRACE_TAG_ACTIVITY_MANAGER)) &#123; Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;dispatchingStartProcess:&quot; + r.processName); &#125; // 上面的wpc != null &amp;&amp; wpc.hasThread()不满足的话，说明没有进程，就会去创建进程 final Message msg = PooledLambda.obtainMessage( ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName, r.info.applicationInfo, knownToBeDead, &quot;activity&quot;, r.intent.getComponent()); mService.mH.sendMessage(msg); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); &#125;&#125;boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc, boolean andResume, boolean checkConfig) throws RemoteException &#123; ... // Create activity launch transaction. final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.appToken); final DisplayContent dc = r.getDisplay().mDisplayContent; //添加了启动Activity的Item clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent), System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global // and override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(), r.icicle, r.persistentState, results, newIntents, dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(), r.assistToken)); // Set desired final state. final ActivityLifecycleItem lifecycleItem; if (andResume) &#123; lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward()); &#125; else &#123; lifecycleItem = PauseActivityItem.obtain(); &#125; clientTransaction.setLifecycleStateRequest(lifecycleItem); // Schedule transaction. //ActivityTaskManagerService获取ClientLifecycleManager mService.getLifecycleManager().scheduleTransaction(clientTransaction); ... return true;&#125; 由以上代码可知，ClientTransaction包含一系列的待客户端处理的事务的容器，客户端接收后取出事务并执行。其添加了LaunchActivityItem、ResumeActivityItem等。然后运行ClientLifecycleManager的scheduleTransaction 123456789101112131415161718192021ClientLifecycleManager.java/** * Schedule a transaction, which may consist of multiple callbacks and a lifecycle request. * @param transaction A sequence of client transaction items. * @throws RemoteException * * @see ClientTransaction */void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; final IApplicationThread client = transaction.getClient(); //ClientTransaction transaction.schedule(); if (!(client instanceof Binder)) &#123; // If client is not an instance of Binder - it&#x27;s a remote call and at this point it is // safe to recycle the object. All objects used for local calls will be recycled after // the transaction is executed on client in ActivityThread. transaction.recycle(); &#125;&#125; 123456ClientTransaction.javapublic void schedule() throws RemoteException &#123;//ApplicationThread mClient.scheduleTransaction(this);&#125; IApplicationThread是ApplicationThread在系统进程的代理，所以真正执行的地方是客户端的ApplicationThread。 现有流程如下：启动Activity的操作从客户端跨进程转移到ATMS，ATMS通过ActivityStarter、ActivityStack、ActivityStackSupervisor对Activity任务、Activity栈、Activity记录管理后，又用过跨进程把正在启动过程又转移到了客户端。 流程图如下： 线程切换及消息处理接下来看看ApplicationThread的scheduleTransaction scheduleTransaction会发送Message，ActivityThread内部类H处理此消息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//ApplicationThread.java@Overridepublic void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; ActivityThread.this.scheduleTransaction(transaction);&#125;//ActivityThread.java@Overridepublic void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;//会调用sendMessage ActivityThread.this.scheduleTransaction(transaction);&#125;private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);//对应mH会处理消息，H是ActivityThread的内部类&#125;//ClientTransactionHandler.java 是ActivityThread的父类void scheduleTransaction(ClientTransaction transaction) &#123; transaction.preExecute(this); sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);&#125;//class H extends Handler &#123; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; ... case EXECUTE_TRANSACTION: final ClientTransaction transaction = (ClientTransaction) msg.obj; //这里处理消息 //TransactionExecutor mTransactionExecutor.execute(transaction); if (isSystem()) &#123; // Client transactions inside system process are recycled on the client side // instead of ClientLifecycleManager to avoid being cleared before this // message is handled. transaction.recycle(); &#125; // TODO(lifecycler): Recycle locally scheduled transactions. break; case RELAUNCH_ACTIVITY: handleRelaunchActivityLocally((IBinder) msg.obj); break; &#125; &#125;&#125; 最终到了TransactionExecutor的execute方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//TransactionExecutor.javapublic void execute(ClientTransaction transaction) &#123; if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + &quot;Start resolving transaction&quot;); final IBinder token = transaction.getActivityToken(); if (token != null) &#123; final Map&lt;IBinder, ClientTransactionItem&gt; activitiesToBeDestroyed = mTransactionHandler.getActivitiesToBeDestroyed(); final ClientTransactionItem destroyItem = activitiesToBeDestroyed.get(token); if (destroyItem != null) &#123; if (transaction.getLifecycleStateRequest() == destroyItem) &#123; // It is going to execute the transaction that will destroy activity with the // token, so the corresponding to-be-destroyed record can be removed. activitiesToBeDestroyed.remove(token); &#125; if (mTransactionHandler.getActivityClient(token) == null) &#123; // The activity has not been created but has been requested to destroy, so all // transactions for the token are just like being cancelled. Slog.w(TAG, tId(transaction) + &quot;Skip pre-destroyed transaction:\\n&quot; + transactionToString(transaction, mTransactionHandler)); return; &#125; &#125; &#125; if (DEBUG_RESOLVER) Slog.d(TAG, transactionToString(transaction, mTransactionHandler)); executeCallbacks(transaction); executeLifecycleState(transaction); mPendingActions.clear(); if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + &quot;End resolving transaction&quot;);&#125;public void executeCallbacks(ClientTransaction transaction) &#123; final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks(); if (callbacks == null || callbacks.isEmpty()) &#123; // No callbacks to execute, return early. return; &#125; if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + &quot;Resolving callbacks in transaction&quot;); final IBinder token = transaction.getActivityToken(); ActivityClientRecord r = mTransactionHandler.getActivityClient(token); // In case when post-execution state of the last callback matches the final state requested // for the activity in this transaction, we won&#x27;t do the last transition here and do it when // moving to final state instead (because it may contain additional parameters from server). final ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest(); final int finalState = finalStateRequest != null ? finalStateRequest.getTargetState() : UNDEFINED; // Index of the last callback that requests some post-execution state. final int lastCallbackRequestingState = lastCallbackRequestingState(transaction);//遍历callbacks，调用ClientTransactionItem的execute方法//LaunchActivityItem会在这里调用execute final int size = callbacks.size(); for (int i = 0; i &lt; size; ++i) &#123; final ClientTransactionItem item = callbacks.get(i); ... item.execute(mTransactionHandler, token, mPendingActions); item.postExecute(mTransactionHandler, token, mPendingActions); ... &#125;&#125; 继续查看LaunchActivityItem的execute 1234567891011121314LaunchActivityItem.java@Overridepublic void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo, mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState, mPendingResults, mPendingNewIntents, mIsForward, mProfilerInfo, client, mAssistToken); client.handleLaunchActivity(r, pendingActions, null /* customIntent */); Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);&#125; 里面调用了client.handleLaunchActivity方法，client是ClientTransactionHandler的实例，是在TransactionExecutor构造方法传入的，TransactionExecutor创建是在ActivityThread中,所以，client.handleLaunchActivity方法就是ActivityThread的handleLaunchActivity方法。 流程图如下： Activity初始化及生命周期函数回调123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111ActivityThread.javapublic Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) &#123; ... final Activity a = performLaunchActivity(r, customIntent); ... return a;&#125;/** activity 启动的核心实现. */private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //1、从ActivityClientRecord获取待启动的Activity的组件信息 ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //创建ContextImpl对象 ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; //2、创建activity实例 java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; .. &#125; try &#123; //3、创建Application对象（如果没有的话） Application app = r.packageInfo.makeApplication(false, mInstrumentation); ... if (activity != null) &#123; CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; appContext.setOuterContext(activity); //4、attach方法为activity关联上下文环境 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //5、调用生命周期onCreate if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); &#125; r.activity = activity; &#125; r.setState(ON_CREATE); synchronized (mResourcesManager) &#123; mActivities.put(r.token, r); &#125; &#125; ... return activity;&#125; 由以上代码可知，performLaunchActivity主要完成以下事情： 从ActivityClientRecord获取待启动的Activity的组件信息 通过mInstrumentation.newActivity方法使用类加载器创建activity实例 通过LoadedApk的makeApplication方法创建Application对象，内部也是通过mInstrumentation使用类加载器，创建后就调用了instrumentation.callApplicationOnCreate方法，也就是Application的onCreate方法。 创建ContextImpl对象并通过activity.attach方法对重要数据初始化，关联了Context的具体实现ContextImpl，attach方法内部还完成了window创建，这样Window接收到外部事件后就能传递给Activity了。 调用Activity的onCreate方法，是通过 mInstrumentation.callActivityOnCreate方法完成。 其他生命周期处理也是类似的，先在ActivityStackSupervisor中添加对应的XXXActivityItem，然后在ActivityThread中的handleXXXActivity处理。 总结归纳整体流程图如下： 一些类的介绍： 类名 作用 ActivityThread 应用的入口类，系统通过调用main函数，开启消息循环队列。ActivityThread所在线程被称为应用的主线程（UI线程） ApplicationThread 是ActivityThread的内部类，继承IApplicationThread.Stub，是一个IBinder，是ActiivtyThread和AMS通信的桥梁，AMS则通过代理调用此App进程的本地方法，运行在Binder线程池 H 继承Handler，在ActivityThread中初始化，即主线程Handler，用于主线程所有消息的处理。本片中主要用于把消息从Binder线程池切换到主线程 Intrumentation 具有跟踪application及activity生命周期的功能，用于监控app和系统的交互 ActivityManagerService Android中最核心的服务之一，负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。 ActivityTaskManagerService 管理activity及其容器（task, stacks, displays）的系统服务（Android10中新增，分担了AMS的部分职责） ActivityStarter 用于解释如何启动活动。该类收集所有逻辑，用于确定Intent和flag应如何转换为活动以及相关的任务和堆栈 ActivityStack 用来管理系统所有的Activity，内部维护了Activity的所有状态和Activity相关的列表等数据 ActivityStackSupervisor 负责所有Activity栈的管理。AMS的stack管理主要有三个类，ActivityStackSupervisor，ActivityStack和TaskRecord ClientLifecycleManager 客户端生命周期执行请求管理 ClientTransaction 是包含一系列的 待客户端处理的事务 的容器，客户端接收后取出事务并执行 LaunchActivityItem、ResumeActivityItem 继承ClientTransactionItem，客户端要执行的事务信息，启动activity 参考 https://juejin.cn/post/6847902222294990862 《Android开发艺术探索》","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Activity","slug":"Android/基础/Activity基础","date":"2021-06-07T01:45:07.540Z","updated":"2021-06-07T01:45:07.540Z","comments":true,"path":"wiki/Android/基础/Activity基础/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Activity%E5%9F%BA%E7%A1%80/","excerpt":"","text":"由来我们在做带UI的软件时，一般的做法是先创建一个窗口，然后在窗口上添加各种Button、Text、List等其他UI控件。Android、iOS也是类似，但代码的设计上跟PC端有些差别，Android使用Activity来管理UI、iOS使用ViewController。一般软件的入口都是main函数开始，Android中则通过描述文件AndroidManifest.xml配置一个Activity的属性作为入口。用户操作手机的时候使得一个界面可能处于可视状态，也可能处理隐藏状态，对应着Activity会有自己的生命周期。不同UI的嵌套也是需要维护的，所以就有了Activity任务栈，对应着不同Activity有不同的启动模式。不同的Activity之间又可能需要数据传递，因而有了Intent。 生命周期 回调函数onCreate(@Nullable Bundle savedInstanceState)生命周期中的第一个函数，整个生命周期中只会调用一次。savedInstanceState参数如果不为空，表示Activity暂时销毁时有存储一些数据，此时可以恢复。 onRestart当前Activity从不可见重新变为可见状态时，会调用。 onStart此时准备进入前台了 onResume可见了 onPause表示Activity正在停止 onStop表示Activity即将停止 onDestroy表示Activity即将被销毁，一般在这个方法中进行资源释放。 savedInstanceState(Bundle bundle)界面销毁时可保存数据 onRestoreInstanceState恢复数据 不同场景的生命周期流程正常的开启和结束从Activity1中打开Activity2 12345672021-06-02 21:03:06.820 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onCreate2021-06-02 21:03:06.831 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onStart2021-06-02 21:03:06.835 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onResume2021-06-02 21:03:26.542 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onPause2021-06-02 21:03:26.649 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onCreate2021-06-02 21:03:26.659 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onStart2021-06-02 21:03:26.663 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onResume 在Activity2中点击返回键，当一个后台Activity会到前台时，会执行onRestart-&gt;onResume-&gt;onDestroy。当回到桌面，再次进入的应用的时候也是此流程 1234562021-06-02 21:06:54.500 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onPause2021-06-02 21:06:54.521 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onRestart2021-06-02 21:06:54.523 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onStart2021-06-02 21:06:54.526 30945-30945/com.lqd.androidpractice D/LaunchActivity1: onResume2021-06-02 21:06:54.762 30945-30945/com.lqd.androidpractice D/LaunchActivity2: onDestroy 屏幕旋转时12345672021-06-02 21:14:02.755 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onPause2021-06-02 21:14:02.763 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onSaveInstanceState2021-06-02 21:14:02.768 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onDestroy2021-06-02 21:14:02.997 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onCreate2021-06-02 21:14:03.011 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onStart2021-06-02 21:14:03.014 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onRestoreInstanceState2021-06-02 21:14:03.018 1351-1351/com.lqd.androidpractice D/LaunchActivity1: onResume 异常情况下的数据保存和恢复某些情况下，Activity会被销毁，此时系统会调用savedInstanceState(Bundle bundle)方法，我们可以在这个方法中存储一些数据，等到Activity恢复时，bundle对象会被传递给onCreate和onRestoreInstanceState方法，我们就可以恢复到原来的状态了。 启动模式和任务栈任务栈Task，是一种用来放置Activity实例的容器，他是以栈的形式进行盛放，也就是所谓的先进后出，主要有2个基本操作：压栈和出栈，其所存放的Activity是不支持重新排序的，只能根据压栈和出栈操作更改Activity的顺序。 启动一个Application的时候，系统会为它默认创建一个对应的Task，用来放置根Activity。默认启动Activity会放在同一个Task中，新启动的Activity会被压入启动它的那个Activity的栈中，并且显示它。当用户按下回退键时，这个Activity就会被弹出栈，按下Home键回到桌面，再启动另一个应用，这时候之前那个Task就被移到后台，成为后台任务栈，而刚启动的那个Task就被调到前台，成为前台任务栈，手机页面显示的就是前台任务栈中的栈顶元素。 启动模式则是用来管理Activity如何添加到任务栈里的。可以在描述文件中配置，也可以代码中设置。 启动模式launchModestandard默认模式，每次启动都会创建一个新的Activity实例。在这个模式中，谁启动了这个Activity，那么新的Activity会添加到启动的Activity所在的任务栈中。当使用非Activity的Context打开一个Activity时，则会创建一个新的任务栈，这个时候需要指定FLAG_ACTIVITY_NEW_TASK标识。 singleTop栈顶复用模式。在这种模式下，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，通过此方法的参数我们可以取出当前请求的信息。需要注意的是，这个Activity的onCreate、onStart不会被系统调用，因为它并没有发生改变。如果新Activity的实例已存在但不是位于栈顶，那么新Activity仍然会重新重建。举个例子，假设目前栈内的情况为ABCD，其中ABCD为四个Activity，A位于栈底，D位于栈顶，这个时候假设要再次启动D，如果D的启动模式为singleTop，那么栈内的情况仍然为ABCD;如果D的启动模式为standard，那么由于D 被重新创建，导致栈内的情况就变为ABCDD。 singleTask栈内复用模式。 这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewIntent。如果当前栈中启动，当前栈如果已经存在，则会将其上面的Activity全部出栈，自己排到栈顶。如果不存在，则创建新任务栈。 比如： 比如目前任务栈S1中的情况为ABC，这个时候Activity D以singleTask模式请求启动，其所需要的任务栈为S2，由于S2和D的实例均不存在，所以系统会先创建任务栈S2，然后再创建D的实例并将其入 栈到S2。 另外一种情况，假设D所需的任务栈为S1，其他情况如上面例子1所示，那么由于S1已经存在，所以系统会直接创建D的实例并将其入栈到S1。 如果D所需的任务栈为S1，并且当前任务栈S1的情况为ADBC，根据栈内复用的原则，此时D不会重新创建，系统会把D切换到栈顶并调用其onNewIntent方法，同时由于singleTask默认具有clearTop的效果，会导致栈内所有在D上面的Activity全部出栈，于是最终S1中的情况为AD。 singleInstance单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中，换句话说，比 如Activity A是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，由于栈内复用的特性，后续的请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁了。”来电显示”界面就可以使用该模式。 Activity中的Flags标记位的作用很多，有的标记位可以设定Activity的启动模式，比如FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_SINGLE_TOP等;还有的标记位可以影响Activity的运行状态，比如FLAG_ACTIVITY_CLEAR_TOP和FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS等。下面主要介绍几个比较常用的标记位，剩下的标记位读者可以查看官方文档去了解，大部分情况下，我们不需要为Activity指定标记位，因此，对于标记位理解即可。在使用标记位的时候，要注意有些标记位是系统内部使用的，应用程序不需要去手动设置这些标记位以防出现问题。 FLAG_ACTIVITY_NEW_TASK 这个标记位的作用是为Activity指定“singleTask”启动模式，其效果和在XML中指定该启动模式相同。 FLAG_ACTIVITY_SINGLE_TOP 这个标记位的作用是为Activity指定“singleTop”启动模式，其效果和在XML中指定该启动模式相同。 FLAG_ACTIVITY_CLEAR_TOP 具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用，在这种情况下，被启动Activity的实例如果已经存在，那么系统就会调用它的onNewIntent。如果被启动的Activity采用standard模式启动，那么它连同它之上的Activity都要出栈，系统会创建新的Activity实例并放入栈顶。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 具有这个标记的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性 android:excludeFromRecents=”true”。 Activity之间如何通信参考 https://developer.android.com/guide/components/activities/intro-activities?hl=zh-cn 《Android开发艺术探索》","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"volatile详解二","slug":"Java/并发编程/volatile详解二","date":"2021-06-03T07:09:12.139Z","updated":"2021-06-03T07:09:39.734Z","comments":true,"path":"wiki/Java/并发编程/volatile详解二/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volatile%E8%AF%A6%E8%A7%A3%E4%BA%8C/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"线程间通讯方式","slug":"Java/并发编程/线程间通讯方式","date":"2021-06-02T13:18:54.990Z","updated":"2021-06-04T02:35:31.884Z","comments":true,"path":"wiki/Java/并发编程/线程间通讯方式/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"multitype","slug":"Android/开源库/multitype","date":"2021-06-02T06:05:16.123Z","updated":"2021-06-02T06:05:27.305Z","comments":true,"path":"wiki/Android/开源库/multitype/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/multitype/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"RecyclerView","slug":"Android/UI/RecyclerView详解一","date":"2021-06-02T02:29:03.000Z","updated":"2021-06-02T02:29:03.602Z","comments":true,"path":"wiki/Android/UI/RecyclerView详解一/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/RecyclerView%E8%AF%A6%E8%A7%A3%E4%B8%80/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[]},{"title":"adb工具","slug":"Android/adb工具","date":"2021-05-31T16:00:00.000Z","updated":"2021-06-04T09:27:06.652Z","comments":true,"path":"wiki/Android/adb工具/","link":"","permalink":"http://shjlone.github.io/wiki/Android/adb%E5%B7%A5%E5%85%B7/","excerpt":"","text":"查询设备 adb devices List of devices attached emulator-5554 device emulator-5556 device emulator-5558 device 将命令发送至特定设备 adb -s serial_number command adb -s emulator-5556 install helloWorld.apk 拉取/推送文件 adb pull remote local adb push local remote adb push foo.txt /sdcard/foo.txt 开启/停止adb服务器 adb start-server adb kill-server 将日志输出到屏幕 adb logcat [option] [filter-specs] 获取实例序列号 adb get-serialno 查看应用版本号 adb shell dumpsys package 包名 | findstr version 调用Activity Manager adb shell am start -a android.intent.action.VIEW 命令 说明 start [options] intent 启动 intent 指定的 Activity。 startservice [options] intent 启动 intent 指定的 Service force-stop package 强行停止与 package（应用的包名称）关联的所有应用。 kill [options] package 终止与 package（应用的包名称）关联的所有进程。此命令仅终止可安全终止且不会影响用户体验的进程。 kill-all 终止所有后台进程。 instrument [options] component 使用 Instrumentation 实例启动监控。通常，目标 component 是表单 test_package/runner_class。 profile start process file 启动 process 的分析器，将结果写入 file。 set-debug-app [options] package 将应用 package 设为调试。 clear-debug-app 使用 set-debug-app 清除以前针对调试用途设置的软件包。 monitor [options] 启动对崩溃或 ANR 的监控。 screen-compat {on| off} package 控制 package 的屏幕兼容性模式 display-size [reset|widthxheight] 替换模拟器/设备显示尺寸。此命令对于在不同尺寸的屏幕上测试您的应用非常有用，它支持使用大屏设备模仿小屏幕分辨率（反之亦然）。示例：am display-size 1280x800 display-density dpi 替换模拟器/设备显示密度。此命令对于在不同密度的屏幕上测试您的应用非常有用，它支持使用低密度屏幕在高密度环境环境上进行测试（反之亦然）。示例：am display-density 480 软件包管理器 adb shell pm uninstall com.example.MyApp 命令 说明 list packages [options] filter 输出所有软件包，或者，仅输出包名称包含 filter 中的文本的软件包。 list permission-groups 输出所有已知的权限组。 list features 输出系统的所有功能。 list libraries 输出当前设备支持的所有库。 install [options] path 将软件包（通过 path 指定）安装到系统。 clear package 删除与软件包关联的所有数据。 set-install-location location 更改默认安装位置。 屏幕截图 adb shell screencap /sdcard/screen.png 录制视频 adb shell screenrecord /sdcard/demo.mp4 其他Shell命令 adb shell ls /sdcard Shell命令 | 说明dumpsys | 将系统数据转储到屏幕dumpstate | 将状态转储到文件dmesg | 将内核调试消息输出到屏幕。start |启动（重启）模拟器/设备实例。stop |停止执行模拟器/设备实例。 adb shell dumpsys activity log anr 2 可以打开anr的messagequeue adb shell dumpsys activity a 查看activity详细信息，如显示大小，布局等等 adb shell dumpsys activity | grep mFocusedActivity adb shell &quot;dumpsys activity top | grep ACTIVITY&quot; 显示当前的Activity adb shell dumpsys activity processes 进程信息 trimmemory adb shell &quot;ps | grep 包名&quot; 查看应用的进程id adb shell dumpsys activity recents adb shell dumpsys activity broadcasts 可以查看前台和后台broadcast详细信息(发送时间， 所有应用处理时间，监听广播的所有列表) adb shell dumpsys activity intents adb shell dumpsys activity oom adb shell dumpsys input | grep Focus 查看焦点窗口 //查看当前activity名字 adb shell dumpsys activity activities | grep mFocusedActivity # 8.0以下 adb shell dumpsys activity activities | grep mResumedActivity # 8.0 adb shell ps | findstr com.xxxx.xxx 查看进程信息 adb shell kill -10 pid 触发垃圾回收 adb kill-server &amp;&amp; adb server &amp;&amp; adb shell 重制adb连接 adb shell dumpsys activity activities 查看当前任务栈 模拟用户行为1234567891011发送键盘事件adb shell input keyevent “value”发送鼠标事件(Touch)：adb shell sendevent [device] [type] [code] [value]input text input keyevent input tap input swipe 参考 官方文档 http://blog.hsujee.com/2017/09/25/Android/Framework/2017-09-25-Android%E6%A8%A1%E6%8B%9F%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8E%9F%E7%90%86/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"}],"tags":[]},{"title":"ViewPager2","slug":"Android/UI/ViewPager2","date":"2021-05-31T16:00:00.000Z","updated":"2021-06-02T02:15:32.270Z","comments":true,"path":"wiki/Android/UI/ViewPager2/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/ViewPager2/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[]},{"title":"自定义View","slug":"Android/UI/自定义View","date":"2021-05-31T16:00:00.000Z","updated":"2021-06-02T08:10:53.672Z","comments":true,"path":"wiki/Android/UI/自定义View/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/%E8%87%AA%E5%AE%9A%E4%B9%89View/","excerpt":"","text":"参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[]},{"title":"ANR问题分析和解决","slug":"Android/性能优化/ANR问题分析和解决","date":"2021-05-31T16:00:00.000Z","updated":"2021-06-10T10:13:27.756Z","comments":true,"path":"wiki/Android/性能优化/ANR问题分析和解决/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/ANR%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%A3%E5%86%B3/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"启动速度优化","slug":"Android/性能优化/启动速度优化","date":"2021-05-31T16:00:00.000Z","updated":"2021-06-10T10:14:18.421Z","comments":true,"path":"wiki/Android/性能优化/启动速度优化/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"Android APK打包流程","slug":"Android/Android APK文件打包流程","date":"2021-05-31T01:33:33.494Z","updated":"2021-05-31T06:02:20.976Z","comments":true,"path":"wiki/Android/Android APK文件打包流程/","link":"","permalink":"http://shjlone.github.io/wiki/Android/Android%20APK%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/","excerpt":"","text":"APK文件的结构 xxx.apk res：未编译的资源文件 anim color drawable layout menu lib assets META-INF CERT.RSA：保存了签名和公钥证书 CERT.SF：对每个文件的头3行进行SHA1 hash MANIFEST.MF：版本号以及每一个文件的哈希值（Base64），包括资源文件。 com classes.dex resources.arsc AndroidManifest.xml 一、资源打包使用aapt来打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样） res目录有9种目录 animator。这类资源以XML文件保存在res/animator目录下，用来描述属性动画。 anim。这类资源以XML文件保存在res/anim目录下，用来描述补间动画。 color。这类资源以XML文件保存在res/color目录下，用描述对象颜色状态选择子。 drawable。这类资源以XML或者Bitmap文件保存在res/drawable目录下，用来描述可绘制对象。例如，我们可以在里面放置一些图片（.png, .9.png, .jpg, .gif），来作为程序界面视图的背景图。注意，保存在这个目录中的Bitmap文件在打包的过程中，可能会被优化的。例如，一个不需要多于256色的真彩色PNG文件可能会被转换成一个只有8位调色板的PNG面板，这样就可以无损地压缩图片，以减少图片所占用的内存资源。 layout。这类资源以XML文件保存在res/layout目录下，用来描述应用程序界面布局。 menu。这类资源以XML文件保存在res/menu目录下，用来描述应用程序菜单。 raw。这类资源以任意格式的文件保存在res/raw目录下，它们和assets类资源一样，都是原装不动地打包在apk文件中的，不过它们会被赋予资源ID，这样我们就可以在程序中通过ID来访问它们。例如，假设在res/raw目录下有一个名称为filename的文件，并且它在编译的过程，被赋予的资源ID为R.raw.filename，那么就可以使用以下代码来访问它： 12Resources res = getResources(); InputStream is = res.openRawResource(R.raw.filename); values。这类资源以XML文件保存在res/values目录下，用来描述一些简单值，例如，数组、颜色、尺寸、字符串和样式值等，一般来说，这六种不同的值分别保存在名称为arrays.xml、colors.xml、dimens.xml、strings.xml和styles.xml文件中。 xml。这类资源以XML文件保存在res/xml目录下，一般就是用来描述应用程序的配置信息。toc R.java public final class R { public static final class layout &#123; public static int xxx = 0xxxxxx; &#125; ... } resources.arsc记录了所有的应用程序资源目录的信息，包括每一个资源名称、类型、值、ID以及所配置的维度信息。 使用资源 程序中通过R.resource_type.resource_name来引用相关资源 xml文件中的使用格式：@[package:]type/name aapt命令 /e/Android/sdk/build-tools/28.0.2/aapt.exe package -f -M src/main/AndroidManifest.xml -I &quot;/e/Android/sdk/platforms/android-28/android.jar&quot; -S src/main/res -J gen -m -f 如果编译出来的文件已经存在，强制覆盖。 -m 使生成的包的目录放在-J参数指定的目录。 -J 指定生成的R.java的输出目录 -S res文件夹路径 -A assert文件夹的路径 -M AndroidManifest.xml的路径 -I 某个版本平台的android.jar的路径 -F 具体指定apk文件的输出 二、aidl阶段处理.aidl文件，生成对应的Java接口文件 aidl命令 三、Java编译阶段编译R.java、Java接口文件、Java源文件，生成.class文件 javac javac -encoding UTF-8 -bootclasspath -d gen/out src/main/java/com/test/MainActivity.java -classpath 四、dex阶段通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex dx命令 dx --dex --output=gen/classes.dex gen/out/java/com/test/ 五、apkbuilder阶段将classes.dex、resources.arsc、res文件夹(res/raw资源被原装不动地打包进APK之外，其它的资源都会被编译或者处理)、Other Resources(assets文件夹)、AndroidManifest.xml打包成apk文件。 注意： res/raw和assets的相同点： 两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。 res/raw和assets的不同点： res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。 res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹 aapt aapt add package/res.apk classes.dex 六、签名阶段对apk进行签名 apksigner 12345678910111213141516171819202122在Android Studio中点击菜单 Build-&gt;Generate signed apk... 打包签名过程中,可以看到两种签名选项 V1(Jar Signature) V2(Full APK Signature),刚开始升级AS看到这个懵了,既然是APK Signature,就放心偷懒选了V2,结果安装失败？？？无奈,只能查资料...从Android 7.0开始, 谷歌增加新签名方案 V2 Scheme (APK Signature);但Android 7.0以下版本, 只能用旧签名方案 V1 scheme (JAR signing)V1签名: 来自JDK(jarsigner), 对zip压缩包的每个文件进行验证, 签名后还能对压缩包修改(移动/重新压缩文件) 对V1签名的apk/jar解压,在META-INF存放签名文件(MANIFEST.MF, CERT.SF, CERT.RSA), 其中MANIFEST.MF文件保存所有文件的SHA1指纹(除了META-INF文件), 由此可知: V1签名是对压缩包中单个文件签名验证 V2签名: 来自Google(apksigner), 对zip压缩包的整个文件验证, 签名后不能修改压缩包(包括zipalign), 对V2签名的apk解压,没有发现签名文件,重新压缩后V2签名就失效, 由此可知: V2签名是对整个APK签名验证 V2签名优点很明显: 签名更安全(不能修改压缩包) 签名验证时间更短(不需要解压验证),因而安装速度加快注意: apksigner工具默认同时使用V1和V2签名,以兼容Android 7.0以下版本 apksigner sign --ks key.jks --out package/app-release.apk package/app-unsigned-aligned.apk //检查签名 apksigner verify app.apk 七、zipalign阶段对apk中未压缩的数据进行4字节对齐，对齐后就可以使用mmap函数读取文件，可以像读取内存一样对普通文件进行操作。如果没有4字节对齐，就必须显式的读取，这样比较缓慢并且会耗费额外的内存。 zipalign zipalign 4 package/res.apk package/app-unsigned-aligned.apk","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"}],"tags":[]},{"title":"对于服务端开发的理解","slug":"技术开发/服务端/对于服务端开发的理解","date":"2021-05-29T06:50:55.134Z","updated":"2021-05-29T06:50:55.134Z","comments":true,"path":"wiki/技术开发/服务端/对于服务端开发的理解/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%AF%B9%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"最近一段时间，开始了解并完成了一些后端需求。大致的过程如下： 熟悉PHP，看了《PHP核心技术与最佳实践》、《PHP内核剖析》、《深入理解PHP内核》； 熟悉MySQL，看了《MySQL必知必会》，接下来会看《高性能MySQL》； 熟悉Redis，看了《Redis实战》； 阅读Symfony官网文档，了解其基本原理； 由于本地使用docker开发环境，所以对docker相关知识点也进行了一轮复习； 整体来看，想使用PHP相关技术栈进行后端开发，经过上面的学习后，写写业务代码，一点问题都没有。公司使用PHP这一套技术栈，也是基于人力成本、开发效率各方面因素综合考虑而定的。在现有体量下也确实是比较好的选择。因为自己本身有其他语言的底子在，学习的过程中还是蛮顺利的。现在回过头看看，后端的整体架构设计也是根据体量的大小一步步进化来的。 当一个（小）项目刚开始时，使用Nginx+Symfony+MySQL，当业务量有所增长，这个时候需要加上缓存Redis；当业务继续增长，这个时候需要多台机器部署了，需要使用负载均衡，Nginx进行反向代理，将流量分发到不同的机器；当业务继续增长，这个时候需要考虑部署多个数据库，进行主从同步；当业务继续增长，这个时候Redis也要考虑使用集群。随着业务继续增长，数据库表的设计，如何分表。如何分库，业务代码如何写效率高，等等问题都要进行考虑了。当业务还在继续增长，可能有些事情用PHP来干已经不是最优解了！ 除了上面所说的一些技术选择外，为了保证服务器的稳定，还有很多事情要做的，比如要对服务器相关数据进行监控，比如请求数、慢请求数、服务器流量消耗情况等；要有一套完善的日志系统；对数据库的监控；容灾机制等等。 这些知识的获取途径无外乎两种，一是业务增长喜人，给了你机会把这些坑都踩一遍；二是在大公司，现成的解决方案供你学习。所以，刚毕业的小菜鸟们，还是建议能去大公司就尽量去大公司，做大做强的小公司太少了，不一定能被你撞上。 服务端需要用到的技术或软件： 开发框架：Symfony、ThinkPHP等 消息队列：RabbitMQ等 服务器：Nginx、Apache等 缓存：Redis、MemCached等 数据存储：MySQL、PostgreSQL等 代码部署：Walle等 数据监控：Zabbix等 日志分析系统：elk等","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"http://shjlone.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"火车票黄牛","slug":"随笔/火车票黄牛","date":"2021-05-29T06:50:55.133Z","updated":"2021-06-08T08:12:52.520Z","comments":true,"path":"wiki/随笔/火车票黄牛/","link":"","permalink":"http://shjlone.github.io/wiki/%E9%9A%8F%E7%AC%94/%E7%81%AB%E8%BD%A6%E7%A5%A8%E9%BB%84%E7%89%9B/","excerpt":"","text":"今天“长见识”了。 开始以为回广州的高铁票应该很容易买到，所以，并没有提前买票。然而，在家用某行火车票刷票到7点也没买到票。明天可还要上班呢。想着要不去人工售票处碰碰运气。然后来到了高铁站。先去了人工售票窗口，售票的这个小姐姐用非常冷淡的表情回答说没有，然后我就再次问了一次，请问今晚往广州方向的车的票有没有，只要能上车的都行？结果是她再次肯定的说了一句没有！哎，既然这样说了… 然后，我想去售票机上碰碰运气。当我到了一台售票机前，打算查询的时候，旁边来了一位小哥，跟我说：兄Dai，需要票吗？一个小时以内的都可以搞定。我当时就有点懵逼了，黄牛难道可以变出票来？想着还是要回去的，于是说：我需要的。他说：你跟我来这边吧，这边的机器快一些。然后我们来到了旁边的一台机器旁，只见他迅速的在售票机前点击。操作也就是查询是否有余票，然后一下子就出现了，请刷身份证的提示。然后跟我说：快把身份证放上来。我一下子看傻了，然后迅速冷静下来，问他需要给他多少钱。结果，等了十几秒吧，票就没了。他表现的有点懊恼。想想还是要回去的，于是跟他谈价钱，然后又看他操作了一遍，太神奇了。不到一分钟，他又刷出来一张，然后我拿出身份证支付了。 事后想想，难道这是售票机的漏洞吗？难道售票机上的查询接口跟人工售票厅里的不一样？黄牛的这个钱也太好赚了吧。","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"http://shjlone.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"《大明王朝1566》经典语录","slug":"随笔/《大明王朝1566》经典语录","date":"2021-05-29T06:50:55.133Z","updated":"2021-05-29T06:50:55.134Z","comments":true,"path":"wiki/随笔/《大明王朝1566》经典语录/","link":"","permalink":"http://shjlone.github.io/wiki/%E9%9A%8F%E7%AC%94/%E3%80%8A%E5%A4%A7%E6%98%8E%E7%8E%8B%E6%9C%9D1566%E3%80%8B%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/","excerpt":"","text":"朝野都知道，我是严阁老提携的人。千秋万代以后，史书上我胡宗宪还会是严阁老的人。可你谭纶，还有朝里那些清流为什么还会看重我？就是我胡某在大事上从来上不误国，下不误民。 孔子说的“知不可为而为之”是什么本意！孔子是告诉世人，做事时不问可不可能，但问应不应该！ 你中有我，我中有你，天下事坏就坏在这里。 事未经历不知难。 官场之中无朋友。 凡事都当作两面想。 你是个刚正的人，敢说话，敢抗上。可真要抗上，你这个七品能抗得过谁？在浙江你能做些事情撼动朝廷，那是因为你背后有人要撼动朝廷。到了江西分宜，凭你一个人又能震动谁？皇上要用的人谁也推不倒，皇上不用的人谁也保不了。 两句话你要记住，一句是文官们说的‘做官要三思’，什么叫三思，三思就是思危、思退、思变。知道了危险就能躲开危险，这就叫思危；躲到人家都不注意到你的地方，这就叫思退；退了下来就有了机会，再慢慢看、慢慢想，自己以前哪儿错了，往后该怎么做，这就叫思变。我再教你武官们说的那一句‘置之死地而后生’，看我大明朝的气数，这皇位迟早有一天是裕王的，到了那一天你才真是个死呢。 文官的衣服上绣的是禽，武官的衣服上绣的是兽。披上了这身皮，我们哪一个不是衣冠禽兽。 任何人答应你的事都不算数，只有自己能做主的才算数。 这个世上，真靠得住的就两种人，一种是笨人，一种是直人。笨人没有心眼，直人不使心眼。 世间万事万物都只有一个理，各人站的位置不同，看法不同而已。 历来造反的都是种田的人，没听说商人能闹翻了天。 裕王: 大明朝谁是贤臣? 嘉靖: 没有谁是真正的贤臣,贤时用之,不贤黜之。","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"http://shjlone.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"《深入理解计算机》读书笔记8：异常流控制","slug":"读书笔记/深入理解计算机/读书笔记8-异常流控制","date":"2021-05-29T06:50:55.133Z","updated":"2021-05-29T06:50:55.133Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记8-异常流控制/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B08-%E5%BC%82%E5%B8%B8%E6%B5%81%E6%8E%A7%E5%88%B6/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《深入理解计算机》读书笔记9：虚拟内存","slug":"读书笔记/深入理解计算机/读书笔记9-虚拟内存","date":"2021-05-29T06:50:55.133Z","updated":"2021-05-29T06:50:55.133Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记9-虚拟内存/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B09-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《深入理解计算机》读书笔记3：程序的机器级表示","slug":"读书笔记/深入理解计算机/读书笔记3-程序的机器级表示","date":"2021-05-29T06:50:55.132Z","updated":"2021-05-29T06:50:55.132Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记3-程序的机器级表示/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《深入理解计算机》读书笔记3：处理器体系结构","slug":"读书笔记/深入理解计算机/读书笔记4-处理器体系结构","date":"2021-05-29T06:50:55.132Z","updated":"2021-05-29T06:50:55.132Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记4-处理器体系结构/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B04-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《深入理解计算机》读书笔记5：优化程序性能","slug":"读书笔记/深入理解计算机/读书笔记5-优化程序层次结构","date":"2021-05-29T06:50:55.132Z","updated":"2021-05-29T06:50:55.132Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记5-优化程序层次结构/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B05-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《深入理解计算机》读书笔记7：链接","slug":"读书笔记/深入理解计算机/读书笔记7-链接","date":"2021-05-29T06:50:55.132Z","updated":"2021-05-29T06:50:55.133Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记7-链接/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B07-%E9%93%BE%E6%8E%A5/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《深入理解计算机》读书笔记6：存储器层次结构","slug":"读书笔记/深入理解计算机/读书笔记6-存储器层次结构","date":"2021-05-29T06:50:55.132Z","updated":"2021-05-29T06:50:55.132Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记6-存储器层次结构/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B06-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《深入理解计算机》读书笔记1：计算机系统漫游","slug":"读书笔记/深入理解计算机/读书笔记1-计算机系统漫游","date":"2021-05-29T06:50:55.131Z","updated":"2021-05-29T09:13:03.242Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记1-计算机系统漫游/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程 计算机系统漫游本章只是对整个计算机体系进行概要的介绍，很多主题扩展开来又可以写一本很厚的书了。在阅读此章时，有个大概了解即可。 hello world源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。系统中所有的信息–包括磁盘文件、内存中的程序、内存中存放用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方式是我们读到这些数据对象时的上下文。 下图描述了一个c程序是如何被编译运行的。 关于计算机的构成 关于存储器 分层，高层提供给低层高速缓存，越高层性能越好，价格越贵。 计算机抽象的表示 关于shellshell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。 操作系统的两个基本功能： 防止硬件被失控的应用程序滥用； 向应用程序提成简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。 操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。 Posix的由来20世纪80年代中期，Unix厂商试图通过加入新的、往往不兼容的特性来使他们的程序与众不同，为了阻止这种趋势，IEEE开始标准化Unix的开发，后来由Richard Stallman命名为“Posix”。结果就得到了一些列的标准，称作Posix标准。 并发运行一个进程的指令和另一个进程的指令是交错执行的。 操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文。 进程间切换的交错执行的机制称为上下文切换。 Amdahl定律 a表示可以提升部分的比例 k表示可提升部分性能提升的比例","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《深入理解计算机》读书笔记10：系统级I/O","slug":"读书笔记/深入理解计算机/读书笔记10-系统级IO","date":"2021-05-29T06:50:55.131Z","updated":"2021-05-29T06:50:55.131Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记10-系统级IO/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B010-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《深入理解计算机》读书笔记11：网络编程","slug":"读书笔记/深入理解计算机/读书笔记11-网络编程","date":"2021-05-29T06:50:55.131Z","updated":"2021-05-29T06:50:55.131Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记11-网络编程/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B011-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《深入理解计算机》读书笔记12：并发编程","slug":"读书笔记/深入理解计算机/读书笔记12-并发编程","date":"2021-05-29T06:50:55.131Z","updated":"2021-06-01T09:58:25.227Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记12-并发编程/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B012-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程 现代操作系统提供三种基本的构造并发程序的方法： 进程 I/O多路复用 线程 基于进程的并发编程基于I/O多路复用的并发编程基于线程的并发编程多线程程序中的共享变量用信号量同步线程","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《深入理解计算机》读书笔记2：信息的表示和处理","slug":"读书笔记/深入理解计算机/读书笔记2-信息的表示和处理","date":"2021-05-29T06:50:55.131Z","updated":"2021-05-29T06:50:55.132Z","comments":true,"path":"wiki/读书笔记/深入理解计算机/读书笔记2-信息的表示和处理/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","excerpt":"","text":"目录 计算机系统漫游 信息的表示和处理 程序的机器级表示 处理器体系结构 优化程序性能 存储器层次结构 链接 异常流控制 虚拟内存 系统级I/O 网络编程 并发编程 原码、反码、补码","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"深入理解计算机","slug":"读书笔记/深入理解计算机","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"深入理解计算机","slug":"深入理解计算机","permalink":"http://shjlone.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}]},{"title":"《Kotlin实战》读书笔记","slug":"读书笔记/《Kotlin实战》读书笔记","date":"2021-05-29T06:50:55.130Z","updated":"2021-05-29T06:50:55.130Z","comments":true,"path":"wiki/读书笔记/《Kotlin实战》读书笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AKotlin%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"基本规则 不需要分号 函数 fun声明函数 函数可以定义在文件的最外层 123fun max(a: Int, b: Int): Int &#123; return if(a&gt;b) a else b&#125; 表达式函数体 fun max(a: Int, b: Int): Int = if(a&gt;b) a else b 表达式函数体可以省略返回类型，Kotlin会进行类型推导 fun max(a: Int, b: Int)= if(a&gt;b) a else b 数组就是类 变量 var表示可写属性 val表示只读属性 1234567val answer = 42 //这个变量永不为nullvar answer1:Int? = 40 // 这个变量可以为nullval answer:Int = 42val表示不可变引用，使用val声明的变量不能在初始化之后再次赋值。var可变引用，可以改变值，但不能改变类型。var answer = 13answer = &quot;no &quot; 这样是错误的 字符串模板 $name $&#123;name&#125; 类 class Person(val name:String) class Person(val name:String, var isMarried:Boolean) 自定义访问器 class Rectangle(val height:Int, val width:Int) &#123; val isSquare:Boolean get() &#123; return height == width &#125; //或者 get() = height == width &#125; 包层级结构不需要遵守目录层级结构 枚举 enum class Color(val r:Int, val g:Int, val b:Int) &#123; RED(255,0,0),GREEN(0,255,0); fun rgb() = (r*256 + g)*256 + b &#125; println(Color.GREEN.rgb()) fun getMnumonic(color: Color) = when(color) &#123; Color.RED -&gt; &quot;Richard&quot; Color.GREEN -&gt; &quot;Gave&quot; &#125; @JvmOverloads， 会生成Java重载函数 顶层属性和函数 扩展函数不能被重写 扩展属性vararg 修饰符 可变参数 中缀调用局部函数 kotlin类声明默认是final和public，要想声明不是final的，将其标记为open open、final、abstract lateinit object 定义一个类并同事创建一个实例，使用场景： 对象声明是定义单例的一种方式 伴生对象可以持有工厂方法和其他与整个类相关，但在调用时并不依赖类实例的方法。 对象表达式用来替代Java的匿名内部类 1234567object DataProviderManager &#123; fun registarDataProvider(provider: DataProvider) &#123; ... &#125;&#125;DataProviderManager.registarDataProvider(...) 伴生对象companion 1234567891011121314class MyClaa &#123; companion object Factory&#123; fun create():MyClass = MyClass() &#125;&#125;//该伴生对象的成员可通过只使用类名作为限定符来调用val instance = MyClass.create()//可以省略伴生对象的名称，在这种情况下将使用名称 Companionclass MyClass &#123; companion object &#123; &#125;&#125;val x = MyClass.Companion 在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段 直接通过容器类名来访问整个对象的方法和属性的能力 匿名对象可以实现多个接口或者不实现接口 lamdba表达式始终用花括号包围 val sum = &#123;x: Int, y: Int -&gt; x+y&#125; println(sum(1,2)) 允许lamdba内部访问非final变量甚至修改它们 成员引用 val getAge = Person::age all any count find 对集合应用判断式 with函数apply 类型系统 可空性 fun strLen(s:String) = s.length fun strLen(s:String?) = s.length 安全调用运算符 ?.，只要链式中一个值为null，则整个表达式都返回null s?.toUpperCase() val testStr : String? = null val result = testStr?.length?.plus(5)?.minus(10) println(result) ?: 当一个函数有返回值时，如果方法中的代码使用?.去返回一个值，那么方法的返回值的类型后面也要加上?符号 fun funNullMethod() : Int? &#123; val str : String? = &quot;123456&quot; return str?.length &#125; as? 非空断言 “!!” 显示地抛出异常 let函数作用：使用符号?.验证的时候忽略掉null 用法：变量?.let{…} val arrTest : Array&lt;Int?&gt; = arrayOf(1,2,null,3,null,5,6,null) // 传统写法 for (index in arrTest) &#123; if (index == null)&#123; continue &#125; println(&quot;index =&gt; $index&quot;) &#125; // let写法 for (index in arrTest) &#123; index?.let &#123; println(&quot;index =&gt; $it&quot;) &#125; &#125; Evils操作符?: 判断一个可空类型时，会返回一个我们自己设定好的默认值 val testStr : String? = null var length = 0 // ?: 写法 length = testStr?.length ?: -1 println(length) !! 判断一个可空类型时，会显示的抛出空引用异常 val testStr : String? = null println(testStr!!.length) as? 安全的类型转换 val num2 : Int? = &quot;Koltin&quot; as? Int println(&quot;nun2 = $num2) 基本类型、包装类型的转换需要通过API Any kotlin基类Unit kotlin中的voidNothing 这个函数永不返回 List listOf mutableListOf、arrayListOfSet setOf mutableSetOf、hashSetOf、linkedSetOf、sortedSetOfMap mapOf mutableMapOf、hashMapOf、linkedMapOf、sortedMapOf 重载二元算术运算operator 委托属性 by lazy() kotlin允许使用对应名称的函数来重载一些标准的数学运算，但不能定义自己的运算符。 函数类型 内联函数 注解@JvmName@JvmStatic@JvmOverloads@JvmField 注解类：用来定义关联到声明和表达式的元数据的结构，它们不能包含任何代码 元注解@Retention 说明你声明的注解是否会存储到.class文件，以及在运行时是否可以通过反射来访问它。 kotlin反射API invoke","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"收集的电子书","slug":"读书笔记/收集的电子书","date":"2021-05-29T06:50:55.130Z","updated":"2021-05-29T06:50:55.130Z","comments":true,"path":"wiki/读书笔记/收集的电子书/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%94%B6%E9%9B%86%E7%9A%84%E7%94%B5%E5%AD%90%E4%B9%A6/","excerpt":"","text":"如何阅读一本书 ActionScript、Flex Actionscript 3 image effects ActionScript 3 ActionScript Graphing Cookbook ActionScript ActionScript大型网页游戏开发 AdvancED ActionScript Animation动画高级编程 AdvancED Game Design with Flash air_buildingapps Flash Cinematic Techniques Flash Game Development by Example Flex4权威指南 FLEX企业应用开发实战 Foundation Game Design with Flash FriendsofED The Essential Guide to Flash Games(flash游戏编程指南) 优化Flash性能 AIR_Android应用开发实战 Developing Android Applications with Flex 4 Flash+Flex+Air移动开发入门经典 mobile-encoding-android-v2_7 Packt Publishing Flash Development for Android Cookbook (2011) 使用Flex4 ABCStructure amf0_spec_121207 amf3_spec_121207 avm2overview swf_file_format_spec_v10 video_file_format_spec_v10_1 Android Android 4高级编程(第3版) Android Developer Tools Essentials Android Native Development Kit Cookbook Android内核剖析(完整版) Android多媒体开发高级编程 Android应用开发详解 Android开发精要 ANDROID框架揭秘 Android系统源代码情景分析 Android软件安全与逆向分析 Dalvik-Bytecode embedded_android Fragments for All Presentation Google Android SDK开发范例大全(第3版) Groovy in Action Groovy中文教程 Kotlin in Action kotlin-for-android-developers-zh Kotlin官方参考文档中文版 Practical practical_android_4_games_development Smashing_Android_UI The Busy Coder’s Guide to Android Development, Version 4 [Gradle [www 深入理解Android(卷2) 深入理解android 疯狂Android讲义 精通Android3 C# C#入门经典第5版中文高清版 C#高级编程(中文第七版) C、C++ Accelerated C++中文版 Andrew Koenig：C 陷阱与缺陷@2002 (扫描版) An_Introduction_to_GCC_中文 c++ Primer 第5版 C+++GUI+QT3编程_11774607 C++STL标准程序库开发指南 PDF电子书下载 带书签目录 C++标准程序库 C++模板元编程 C++沉思录(Ruminations on C++)中文第2版 C++程序设计原理与实践(中文完整版) C++编程规范-101条规则准则与最佳实践 C++语言的设计和演化 C专家编程 C和指针(第二版)高清全版469页 C程序设计(第四版)谭浩强 C程序设计语言(第2版_新版) C程序设计语言(第2版_新版)习题解答 C程序设计语言(第2版_新版)非扫描版&amp;详细书签版 C语言入门经典(第四版) C语言范例开发大全 Effective C 中文版第三版 高清PDF Effective STL 中文版 Essential C++中文版 Head STL源码剖析简体中文完整版(清晰扫描带目录) 你必须知道的495个C语言问题 像计算机科学家一样思考C++ 嗨翻C语言_13421426(jb51 易学C++ English 无敌初中必考语法 新编英语语法教程+学生用书+第5版_PDF 无敌英语语法：全范围 History 乔治·奥威尔：一九八四 何清涟：现代化的陷阱 吴思：潜规则——中国历史中的真实游戏 吴思：血酬定律——中国历史中的生存游戏 威廉·夏伊勒：第三帝国的兴亡 (上) 威廉·夏伊勒：第三帝国的兴亡 (下) 威廉·夏伊勒：第三帝国的兴亡 (中) 学会提问-批判性思维指南 弗洛伊德：梦的解析 弗洛伊德：精神分析引论 徐中约《中国近代史》（PDF-港版完整无删减）上 徐中约《中国近代史》（PDF-港版完整无删减）下 斯科特·派克：少有人走的路 罗伯特·西奥迪尼：影响力 金观涛 &amp; 刘青峰：兴盛与危机——论中国社会超稳定结构 阿利安：亚历山大远征记 高华：在历史的风陵渡口 黄仁宇：中国大历史 剑桥中国历史 中华人民共和国史 (上卷 扫描版) 明史 (扫描版) 晚清史 (上卷 扫描版) 晚清史 (下卷 扫描版) 民国史 (上卷 扫描版) 民国史 (下卷 扫描版) 秦汉史 (扫描版) 辽西夏金元史 (扫描版) 隋唐史 (扫描版) iOS AppDistributionGuide Effective Objective-C 2 iOS应用逆向工程 分析与实战 iOS编程+第4版 Objective C 编程之道 Objective C程序设计 Objective-C编程全解 第3版 Objective-C高级编程 iOS与OS X多线程和内存管理 OSX与iOS内核编程 Java advancedservletsjsp Effective Enterprise Java(Chinese) Head First Servlets and JSP 中文版 第2版 Head First Servlets and JSP 2nd Head First Web设计 (中文版) JAVA并发编程实践（中文） Java并发编程实践（英文版） Java本地接口(JNI)编程指南和规范2 JAVA案例开发集锦 Java编程思想_第4版_中文完整版 Java虚拟机规范中文版 Java迷题 JAVA面试题解惑系列 servlet-2_5-mrel2-spec Think In Java 4完美高清中文版 《Java网络编程(第4版)》 深入浅出数据分析（美）米尔顿著 Effective Java（第2版） Javascript HTML5高级程序设计 javascript dom 编程艺术 JavaScript权威指南(第6版)(中文版) JavaScript高级程序设计(中文)-第3版 kinect 51CTO下载-kinect应用开发实战（全书） Kinect人机交互开发实践 Linux bash Cookbook Solutions and Examples for bash Users Linux Shell Scripting Cookbook 2nd Edition May 2013 Linux 与 UNIX Shell 编程指南 Linux linux内核源代码情景分析(上) linux内核源代码情景分析(下) Linux命令行与Shell脚本编程大全 第2版 Understanding The Linux Kernel UNIX操作系统基础使用手册 精通UNIXShell脚本编程 高级Bash脚本编程指南(Advanced Bash-Scripting 鸟哥的Linux私房菜服务器架设篇(第三版) Music 五线谱入门 基本乐理 PHP PHP和MySQL PHP开发实战1200例 symfony权威指南 深入PHP面向对象模式与实践 白帽子讲 Web 安全 高性能mysql第三版 PHP核心技术与最佳实践 PHP内核剖析 深入理解PHP内核 Python Beginning Game Development with Python and Pygame Dive into Python Effective Expert Python Programming(2nd) make game with python &amp; pyGame Python 3 Python Cookbook Python参考手册(第4版) Python基础教程(第2版) python标准库中文版PDF(带章节书签) Python核心编程第二版-习题答案 Python源码剖析 Python灰帽子 黑客与逆向工程师的Python编程之道 Python灰帽子：黑客与逆向工程师的Python编程之道(英文版) The Django Book 2 The Python Standard Library by Example 深入学习Python 3 编写高质量代码 改善Python程序的91个建议 Qt C++ Qt设计模式（第2版） QmlBook-In-Chinese Qt Creator快速入门 Qt Quick核心编程 13678855 Qt5开发及实例 Qt及Qt Quick开发实战精解 QT学习之路(全) QT高级编程_chs the_art_of_building_qt_applications 《C++设计模式–基于Qt4开源跨平台开发框架》 PyQt pyqt-book PyQt5 tutorial pyqt5__pythonGui入门教程 PyQt5入门 Rapid GUI Programming with Python and Qt Temp 51CTO下载-ffmpeg教程 CMake Practice design-patterns FFMPEG教程完美排版 GarageBand使用指南 growth全栈增长工程师指南 InstallationGuide kotlin-in-action-in-chinese OpenSL_ES_Specification_1 SDL+GUIDE+中文译本 SWIGDocumentation TCP-IP详解(卷一、二、三) Wireshark 数据包分析实战(第2版)最新中文版 Wireshark 数据包分析实战详解 《图解TCP IP(第5版)》 图解设计模式 程序是怎样跑起来的_PDF电子书下载 带书签目录 高清完整版 网络是怎样连接的 计算机是怎样跑起来的 设计模式 设计模式之禅(完整高清版) Java加密与解密的艺术 一个证券分析师的醒悟 张化桥的股市真话 游戏之旅-我的编程感悟 游戏设计-原理与实践 荣辱二十年-我的股市人生 计算机程序的构造和解释 产品、设计、思想 A Pattern Language Head First 设计模式 Java与模式 Java夜未眠 java设计模式 人件（原书第3版） 人月神话 代码之美 你的灯亮着吗 启示录：打造用户喜爱的产品（英文） 大话设计模式 学会提问-批判性思维指南 建筑的永恒之道 数据结构经典问题和算法分析 浪潮之巅 漫谈设计模式 编码的奥秘 设计心理学 设计模式-可复用面向对象软件的基础 设计模式精解 设计模式：Java语言中的应用 高效程序的奥秘 黑客与画家 硅谷创业之父Paul Graham文集 产品经理 互联网产品经理改变世界 产品经理手册 第3版 产品经理方法论 区块链将如何改变世界 用户体验要素 用户体验面面观-方法、工具与实践 德州扑克 let there be range(中文) 加注的优势：当今锦标赛激进策略 哈灵顿在现金上2中文版 扑克蓝图 摄影 数码单反摄影从入门到精通第一卷 美国纽约摄影学院摄影教材 服务端 docker_practice Docker从入门到实践 PHP-Debug-Manual-public Redis开发运维实践指南 Redis源代码分析 云计算架构技术与实践 亿级流量网站架构核心技术 伊甸园之河 大型网站技术架构核心原理与案例分析 实用负载均衡技术网站性能优化攻略 极客与团队 深入分布式缓存从原理到实践 精通正则表达式 软件架构设计 高扩展性网站的50条原则 算法、数据结构 《大话数据结构》 程杰 程序员实用算法 算法之道 算法导论(第二版)习题答案(英文版) 算法导论 管理 MBA教不了的创富课 股票 与庄共舞（股票实战操作） 从零开始学炒股 价值投资系列之25《上市公司财报解读》 你不知道的中国股事那些事(高清) 投资正途 日本蜡烛图技术 江恩投资几何学原理 江恩测市法则（经典之作） 海龟交易法则 看盘细节(精选) 看盘细节 短线炒股就这几招（操盘必读） 短线点金：揭开市场的底牌 短线点金：破解股价的运行轨迹 短线点金：道破股价涨跌之玄机 缠中说禅《教你炒股票》1-108课图文全版 缠论解析 缠中说禅技术理论图解(清晰版) 聪明的投资者（高质量） 胡立阳股票投资100招（清晰） 证券市场基础知识 【投资艺术】作者：查尔斯 艾里斯 巴菲特教你读财报 股票作手回忆录 超越金融 索罗斯的哲学 (美)乔治·索罗斯 2 金融炼金术(高质量） 高胜算操盘 股市操练大全12345 计算机基础 深入理解计算机系统(原书第2版) 编译、链接、装载 程序员的自我修养—链接、装载与库 linker and loader 现代编译原理：Ｃ语言描述 编译原理及实践 编译原理基础 编译原理（龙书）中文版 编译原理及实践 音视频相关 FFmpeg Tutorial FFmpegBasics ffmpeg基础库编程开发 OpenCV 2 计算机视觉编程手册_中文版 学习OpenCV 项目管理 Project 2016项目管理自学经典_王菁_清华大学_2016","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《网络是如何连接的》读书笔记","slug":"读书笔记/《网络是如何连接的》读书笔记","date":"2021-05-29T06:50:55.129Z","updated":"2021-05-29T06:50:55.129Z","comments":true,"path":"wiki/读书笔记/《网络是如何连接的》读书笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E7%BD%91%E7%BB%9C%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《计算机是怎么跑起来的》读书笔记","slug":"读书笔记/计算机是怎样跑起来的》读书笔记","date":"2021-05-29T06:50:55.129Z","updated":"2021-05-29T06:50:55.129Z","comments":true,"path":"wiki/读书笔记/计算机是怎样跑起来的》读书笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"计算机三个根本性基础： 计算机是执行输入、运算、输出的机器； 程序是指令和数据的集合； 计算机的处理方式有时与人们的思维习惯不同。 计算机的硬件由大量集成电路组成。每块集成电路上都带有许多引脚。这些引脚有些用于输入，有些用于输出。 时钟发生器 操作数：操作数笔试是已存储在CPU寄存器中的数字。操作码 机器语言是唯一一种cpu能直接理解的编程语言。 CPU内部存储数据的地方也具备对数据进行计算的能力。有些寄存器中存储着接下来要执行的指令的地址。程序就是依靠着不断变花的寄存器的值运行起来的。 cpu信息cpu的种类：不同的CPU对于二进制的理解是不一样的。时钟信号的频率：时钟发生器发送给cpu的电信号的频率。表示时钟信号频率的单位是MHz（兆赫兹=100万回/秒）。时钟信号是在0和1之间反复变换的电信号。通常把发出一次滴答的时间称作一个时钟周期。 内存信息地址空间每个地址中可以存储多少比特的信息 I/O信息I/O的种类地址空间连接着何种周边设备 最低限度所需的流程图符号 网卡地址前半部分表示生产商，后半部分表示编号。 子网掩码的作用是标识出在32比特的IP地址中，从哪一位到哪一位是网络地址，从哪一位到哪一位是主机地址。255.255.255.240用二进制表示：11111111.11111111.11111111.11110000值为1的那些位对应着IP地址中的网络地址，后面为0的那些则对应着主机地址。 DHCP：Dynamic Host Configuration Protocol 动态主机设置协议 tracert ARP：Address Resolution Protocol，地址解析协议，用于实现由IP地址到MAC地址的转换arp -a 查询apr缓存表 硬件商发送数据的是网卡，网卡之上是设备驱动程序，之上是实现了IP协议的程序，之上是实现了TCP协议的程序，再之上才是应用程序。TCP协议使用“TCP端口号”的数字识别上层的应用程序。TCP端口中有一些是预先定义好的，比如Web使用80端口，电子邮件使用25端口（用于发送）","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《Java编程思想》读书笔记","slug":"读书笔记/《Java编程思想》读书笔记","date":"2021-05-29T06:50:55.128Z","updated":"2021-05-29T06:50:55.129Z","comments":true,"path":"wiki/读书笔记/《Java编程思想》读书笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"final finally finalize","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"单例模式","slug":"设计模式/创建型模式/单例模式","date":"2021-05-29T06:50:55.128Z","updated":"2021-05-29T06:50:55.128Z","comments":true,"path":"wiki/设计模式/创建型模式/单例模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式应该是最常见的设计模式了 目录 定义 Java实现 Kotlin实现 如何处理反序列化 总结 参考 定义定义：单例对象的类必须保证只有一个实例存在。 为了实现一个健壮的单例，我们应该思考需要做哪些事情？ 不能随意的让用户new出对象，所以构造函数应该是私有的 既然不能直接new，就应该有一个方法专门用来返回实例对象 不能clone 不能被反序列化 多线程使用时，如何保证线程安装 Java的实现方式根据上面的思考，我们可以一步步的来实现单例模式。 懒汉式12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 使用的时候才进行初始化，但此种写法是线程不安全的。那么是否把getInstance方法加一个锁就可以了呢？ 线程安全的懒汉式12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 嗯，这种写法确实安全了，可是效率低，因为有更好的方式啊 饿汉式12345678910111213public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125;public class Singleton &#123; private static Singleton instance = null; static &#123; instance = new Singleton(); &#125; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 为什么叫饿汉呢？因为在类加载的时候对象就被创建了啊！这也是该方式不太好的地方，需要的实例应该要在需要用到的时候才初始化呢!所以应该想想怎样才能延迟加载呢？ 静态内部类实现方式123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。完美！！ 枚举123456789101112131415161718192021222324//方式一public enum Singleton &#123; INSTANCE; public void whoAmI() &#123; System.out.println(this.toString()); &#125; &#125;//方式二public class Singleton &#123; private Singleton()&#123; &#125; public void whoAmI() &#123; System.out.println(this.toString()); &#125; public static enum SingletonEnum &#123; SINGLETON; private Singleton instance = null; private SingletonEnum()&#123; instance = new Singleton(); &#125; public Singleton getInstance()&#123; return instance; &#125; &#125;&#125; Java虚拟机会保证枚举类型不能被反射并且构造函数只被执行一次 双重检查锁模式12345678910111213141516public class Singleton &#123; private Singleton()&#123;&#125; private volatile static Singleton instance = null; public static Singleton getInstance() &#123; if(instance == null) &#123; synchronized (Singleton.class) &#123; if(instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 为什么要这样写呢？ 其实这是懒汉式的升级版。懒汉式中所有线程在访问getInstance都会锁住，但实际情况中，很多时候只是读操作，我们没有必要让每个线程都锁住才调用它。 为什么要加volatile呢？ 因为JVM指令可重排，具体可以看看volatile这篇文档 Kotlin的实现方式由于kotlin的语言特性，有些写法还是有别于Java的。 饿汉式1object Singleton &#123;&#125; 对！就是这么简单。以上代码转换成Java后，就是在静态代码块中初始化了Singleton。 懒汉式1234567891011121314151617class Singleton private constructor() &#123; companion object &#123; private var instance: Singleton? = null get() &#123; if (field == null) &#123; field = Singleton() &#125; return field &#125; fun get(): Singleton &#123; //这里不用getInstance作为为方法名，是因为在伴生对象声明时，内部已有getInstance方法，所以只能取其他名字 return instance!! &#125; &#125;&#125; 线程安全的懒汉式123456789101112131415class Singleton private constructor() &#123; companion object &#123; private var instance: Singleton? = null get() &#123; if (field == null) field = Singleton() return field &#125; @Synchronized fun instance(): Singleton &#123; return instance!! &#125; &#125;&#125; 双重锁校验12345class Singleton private constructor() &#123; companion object &#123; val instance by lazy &#123; Singleton() &#125; &#125;&#125; 静态内部类的实现123456789101112131415class Singleton private constructor() &#123; companion object &#123; @JvmStatic //方便Java中使用 fun getInstance() &#123; return Holder.instance &#125; &#125; private object Holder &#123; val instance = Singleton() &#125;&#125; 1234enum class Singleton &#123; INSTANCE;&#125; 如何处理反序列化最开始的分析指出，为了不让别人直接new，构造函数需要设置成私有的。除此之外，还可能被反序列化。那么怎么解决这个问题呢？ 1234567public class Singleton implements Serializable &#123; private final static Singleton instance; private Object readResolve() &#123; return instance; &#125;&#125; 这样就行了？可以参考https://www.jianshu.com/p/ea1d9bc40341这篇文章了解原理。 总结在实际项目开发过程中，使用的最多还是双重锁校验和内部类的实现方式。其实也可以考虑使用枚举方式，毕竟是大佬推荐的！ 参考 https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F https://www.jianshu.com/p/ea1d9bc40341 https://blog.csdn.net/c10WTiybQ1Ye3/article/details/108806203","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"动态规划","slug":"算法/动态规划","date":"2021-05-29T06:50:55.127Z","updated":"2021-05-29T06:50:55.127Z","comments":true,"path":"wiki/算法/动态规划/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"回溯算法","slug":"算法/回溯算法","date":"2021-05-29T06:50:55.127Z","updated":"2021-05-29T06:50:55.127Z","comments":true,"path":"wiki/算法/回溯算法/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","excerpt":"","text":"回溯法（Back Tracking Method）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 12345678910result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 参考 https://my.oschina.net/u/3024426/blog/4689026","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"开始学习iOS","slug":"程序语言/iOS/开始学习iOS","date":"2021-05-29T06:50:55.126Z","updated":"2021-05-29T06:50:55.126Z","comments":true,"path":"wiki/程序语言/iOS/开始学习iOS/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/iOS/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0iOS/","excerpt":"","text":"由于种种原因，有机会全面接触iOS、Mac、OS X了。这里记录下自己的学习过程。 首先是了解下苹果操作系统的历史，推荐看深入解析Mac OS X &amp; iOS操作系统。要想开发iOS应用，ObjectiveC是一定要学的，Objective-C基础教程、Objective-C编程全解、Objective-C高级编程。对OC有了一定的了解后，就需要开始熟悉iOS系统和开发了，iOS编程（第4版）。 入门之后，就需要掌握更具体的知识点了。 Block绘制机制GCD","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"iOS","slug":"程序语言/iOS","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://shjlone.github.io/tags/iOS/"}]},{"title":"理解打包流程","slug":"程序语言/iOS/理解打包流程","date":"2021-05-29T06:50:55.126Z","updated":"2021-05-29T06:50:55.126Z","comments":true,"path":"wiki/程序语言/iOS/理解打包流程/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/iOS/%E7%90%86%E8%A7%A3%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/","excerpt":"","text":"首先理解一下基本的概念 https://help.apple.com/developer-account CertificatesIdentifiersDevicesProfilesKeys编译脚本 1234567891011121314151617181920MWProjectName=&quot;Loneqd&quot;#scheme名字MWScheme=&quot;Loneqd_appstore&quot;#Release还是DebugMWConfiguration=&quot;Release&quot;#日期MWDate=`date +%Y%m%d_%H%M`#工程路径MWWorkspace=&quot;$&#123;WORKSPACE&#125;/src&quot;#build路径MWBuildDir=&quot;/Users/loneqd/alone/Loneqd-for-iOS/build&quot;#导出ipa的配置文件MBPlistName=&quot;/Users/loneqd/alone/Loneqd-for-iOS/lieyou_appstore.plist&quot;xcodebuild archive -workspace &quot;$&#123;WORKSPACE&#125;/src/$MWProjectName.xcworkspace&quot; -scheme &quot;$MWScheme&quot; -configuration &quot;$MWConfiguration&quot; -archivePath &quot;$MWBuildDir/$MWProjectName$MWDate&quot; -quietxcodebuild -exportArchive -archivePath &quot;$MWBuildDir/$MWProjectName$MWDate.xcarchive&quot; -exportPath &quot;$MWBuildDir/$MWProjectName$MWDate&quot; -exportOptionsPlist &quot;$MBPlistName&quot; -quietecho &quot;结束了======&quot;","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"iOS","slug":"程序语言/iOS","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://shjlone.github.io/tags/iOS/"}]},{"title":"","slug":"程序语言/PHP/hyperf学习笔记","date":"2021-05-29T06:50:55.120Z","updated":"2021-05-29T06:50:55.120Z","comments":true,"path":"wiki/程序语言/PHP/hyperf学习笔记/","link":"","permalink":"http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/hyperf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"}],"tags":[]},{"title":"Windows下Charles支持HTTPS","slug":"技术开发/杂项/Charles SSL证书","date":"2021-05-29T06:50:55.113Z","updated":"2021-06-02T11:24:46.494Z","comments":true,"path":"wiki/技术开发/杂项/Charles SSL证书/","link":"","permalink":"http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/Charles%20SSL%E8%AF%81%E4%B9%A6/","excerpt":"","text":"Charles 设置SSL设置点击 Proxy -&gt; SSL Proxy Settings -&gt; SSLProxy -&gt; Add 添加SSL代理规则 Host:* Port:443 证书配置点击 Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate -&gt; 安装证书 选择将所有的证书都放入受信任的根证书颁发机构 Mac需要在钥匙链中将证书设置为永久信任 手机配置连接跟电脑一样的网络，配置代理连接charles。浏览器访问chls.pro/ssl，下载安装证书 注意事项Android7及以上无法抓取https，因为”Network Security Configuration”的新安全功能。这个功能运行开发人员在不修改应用程序的情况下自定义他们的网络安全设置。如果应用程序运行的系统版本高于或等于24，并且targetSdkVersion&gt;=24，则只有系统证书才被信任。 参考 https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/ https://juejin.im/post/5b4f005ae51d45191c7e534a","raw":null,"content":null,"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"杂项","slug":"技术开发/杂项","permalink":"http://shjlone.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"charles","slug":"charles","permalink":"http://shjlone.github.io/tags/charles/"}]},{"title":"Synchronized","slug":"Java/并发编程/Synchronized","date":"2021-05-29T06:50:55.105Z","updated":"2021-05-29T09:08:06.419Z","comments":true,"path":"wiki/Java/并发编程/Synchronized/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Synchronized/","excerpt":"","text":"前言在学习synchronized之前，应该先了解多线程的机制和锁的概念，请先阅读以下文章： Java锁 Java多线程 使用方式 同步普通方法，锁的是当前对象this。 1234567891011121314151617181920public class SynchronizedTest &#123; public synchronized void sayHello()&#123; &#125;&#125;//对应字节码 Compiled from &quot;SynchronizedTest.java&quot; public class com.myth.SynchronizedTest &#123; public com.myth.SynchronizedTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public synchronized void sayHello(); Code: 0: return &#125; 同步静态方法，锁的是当前 Class 对象。 12345678910111213141516171819public class SynchronizedTest &#123; public synchronized static void sayHello()&#123; &#125;&#125;//对应字节码public class com.myth.SynchronizedTest &#123;public com.myth.SynchronizedTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: returnpublic static synchronized void sayHello(); Code: 0: return&#125; 同步块，锁的是 () 中的对象。 12345678910111213141516171819202122232425262728293031323334353637383940public class SynchronizedTest &#123; private String words; public void sayHello()&#123; synchronized(words)&#123; &#125; &#125;&#125;//对应字节码 Compiled from &quot;SynchronizedTest.java&quot; public class com.myth.SynchronizedTest &#123; public com.myth.SynchronizedTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public void sayHello(); Code: 0: aload_0 1: getfield #2 // Field words:Ljava/lang/String; 4: dup 5: astore_1 6: monitorenter 7: aload_1 8: monitorexit 9: goto 17 12: astore_2 13: aload_1 14: monitorexit 15: aload_2 16: athrow 17: return Exception table: from to target type 7 9 12 any 12 15 12 any &#125; 通过查阅字节码（javap -c XXX.class）可知，synchronized修饰对象时，使用monitorenter、monitorexit来实现同步操作，修饰方法时网络上很多资源都说使用ACC_SYNCHRONIZED来实现同步，ACC_SYNCHRONIZED内部隐式的调用monitorenter、monitorexit，可自己查看的字节码却没有看到，不知道啥原因，🤷‍ 底层原理对象头我们编写一个Java类，编译后会生成.class文件，当类加载器将class文件加载到jvm时，会生成一个Klass类型的对象(c++)，称为类描述元数据，存储在方法区中，即jdk1.8之后的元数据区。当使用new创建对象时，就是根据类描述元数据Klass创建的对象oop，存储在堆中。每个java对象都有相同的组成部分，称为对象头。 对象头 Mark Word（标记字段）：默认存储对象的HashCode，分代年龄和锁标志位信息。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。 MarkWord在64位JVM中的结构： MarkWord在32位JVM中的结构： Klass Point（类型指针）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据 这部分主要是存放类的数据信息，父类的信息。 对其填充 由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐。 查看对象占用内存通过jol-core可以分析出内存占用情况和锁的情况 12345678910111213141516171819202122232425262728//添加依赖&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt;&lt;/dependency&gt;//使用public class App &#123; public static void main(String[] args) &#123; System.out.println(ClassLayout.parseInstance(new MyObject()).toPrintable()); &#125;&#125;class MyObject &#123; public int age;&#125;//结果 OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 41 c1 00 f8 (01000001 11000001 00000000 11111000) (-134168255) 12 4 (loss due to the next object alignment)Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total 锁升级JDK 1.6之前，synchronized 是一个重量级锁，是一个效率比较低下的锁，但是在JDK 1.6后，Jvm为了提高锁的获取与释放效率对（synchronized ）进行了优化，引入了”偏向锁”和”轻量级锁”，从此以后锁的状态就有了四种（无锁、偏向锁、轻量级锁、重量级锁），并且四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程。 关于锁的概念，参考Java锁 参考 https://juejin.cn/post/6844904069845221384","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"volatile","slug":"Java/并发编程/volatile","date":"2021-05-29T06:50:55.105Z","updated":"2021-06-04T01:42:32.210Z","comments":true,"path":"wiki/Java/并发编程/volatile/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volatile/","excerpt":"","text":"volatile作用在 Java 并发编程中，volatile 是经常用到的一个关键字，它可以用于保证不同的线程共享一个变量时每次都能获取最新的值。volatile具有锁的部分功能并且性能比锁更好，所以也被称为轻量级锁。 一个变量被volatile修饰，则： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 一些基本概念CPU缓存CPU的计算速度相比内存的读写是非常快的，为了能充分利用CPU的计算能力，这个时候缓存的概念出现了。CPU缓存是位于CPU与内存之间的临时存储器，它的容量比内存小得多但是交换速度却比内存快得多。而缓存中的数据是内存中的一小部分数据，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先从缓存中读取，从而加快读取速度。 按照读取顺序与CPU结合的紧密程度，CPU缓存可分为： 一级缓存：简称L1 Cache，位于CPU内核的旁边，是与CPU结合最为紧密的CPU缓存 二级缓存：简称L2 Cache，分内部和外部两种芯片，内部芯片二级缓存运行速度与主频相同，外部芯片二级缓存运行速度则只有主频的一半 三级缓存：简称L3 Cache，部分高端CPU才有 当系统运行时，CPU执行计算的过程如下： 程序以及数据被加载到主内存 指令和数据被加载到CPU缓存 CPU执行指令，把结果写到高速缓存 高速缓存中的数据写回主内存 原子性即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 可见性指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 volatile是如何实现可见性的呢？ 在线程和主内存之间添加了一条总线，当线程中的变量发生变化时，会将值复制到主内存，这个时候这个值会通过总线，总线就会通知其他线程做修改。 指令重排处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的 volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 比如： 12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 使用场景修饰boolean变量123456789volatile boolean flag = false; while(!flag)&#123; doSomething();&#125; public void setFlag() &#123; flag = true;&#125; 双重锁校验123456789101112131415class Singleton &#123; private static volatile Singleton instance; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 其实问题出在 instance = new Singleton(); 这一行，这里是创建 Singleton 对象的地方，其实这里可以看成三个步骤： 123memory = allocate(); //1: 分配对象的内存空间ctorInstance(memory); //2: 初始化对象instance = memory； //3: 设置 instance 指向刚分配的内存地址 上面的伪代码可能会被重排序。什么是重排序？编译器以及处理器有时候会为了执行的效率改变代码的执行顺序，这个被称为重排序。上面的三个步骤可能会被重排序为下面的步骤： 1234memory = allocate(); //1: 分配对象的内存空间instance = memory； //2: 设置 instance 指向刚分配的内存地址// 注意：此时对象还没有被初始化ctorInstance(memory); //3: 初始化对象 在这种情况下，当一个线程执行到 instance = memory; 的时候，对象还没有被初始化，另一个线程也调用了 getInstance 方法，发现 instance 引用不为 null，就会认为这个对象已经创建好了，从而使用了未初始化的对象。 为什么 volatile 可以避免上面的问题？其实是因为 volatile 会禁止重排序，方法是插入了内存屏障。 观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。 lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 它会强制将对缓存的修改操作立即写入主存； 如果是写操作，它会导致其他CPU中对应的缓存行无效。 参考 https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg https://www.cnblogs.com/dolphin0520/p/3920373.html https://github.com/AdoptOpenJDK/jitwatch volatile与lock前缀指令","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Java中的HashMap","slug":"Java/集合/HashMap","date":"2021-05-29T06:50:55.105Z","updated":"2021-06-07T03:06:08.230Z","comments":true,"path":"wiki/Java/集合/HashMap/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E9%9B%86%E5%90%88/HashMap/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://shjlone.github.io/categories/Java/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Java笔试题收集","slug":"Java/Java笔试题收集","date":"2021-05-29T06:50:55.104Z","updated":"2021-05-29T09:09:04.969Z","comments":true,"path":"wiki/Java/Java笔试题收集/","link":"","permalink":"http://shjlone.github.io/wiki/Java/Java%E7%AC%94%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86/","excerpt":"","text":"弱引用、强引用弱引用：不会影响其引用对象的释放。如果对象只存在弱引用，那么在下一次垃圾回收时必然被清理掉。 TCP、UDP区别 TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的,UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） TCP首部开销20字节;UDP的首部开销小，只有8个字节 TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 三次握手、四次挥手三次握手 第一次握手：客户端想跟服务器进行连接，所以状态变为主动打开，同时发送一个连接请求报文给服务器端SYN=1，并且会携带x个字节过去。发送完请求连接报文后，客户端的状态就变为SYN_SENT,这个状态等待发送确认。 第二次握手：服务端接收到连接请求报文后，从LISTEN状态变为被动打开状态，然后给客户端返回一个报文。这个报文有两层意思，一是确认报文，二是可以达到告诉客户端，我也打开连接了。发送完毕后，变为SYN_RCVD状态。 第三次握手：客户端得到服务端的确认和知道服务端已经准备好连接后，还会发一个确认报文到服务端，发送完后客户端进入ESTABLISHED状态，当服务端接收后，状态也变为ESTABLISHED。 四次挥手 第一次挥手：从ESTABLISHED变为主动关闭状态，客户端主动发送释放连接请求给服务器端，FIN=1。发送完之后就变为FIN_WAIT_1状态，这个状态可以说是等待确认状态。 第二次挥手：服务器接收到客户端发来的释放连接请求后，状态变为CLOSE_WAIT，然后发送确认报文给客户端，告诉他我接收到了你的请求。为什么变为CLOSE_WAIT，原因是客户端发送的释放连接请求，可能自己这端还有数据没有发送完呢，所以这个时候整个TCP连接的状态就变为了半关闭状态。服务器端还能发送数据，并且客户端也能接收数据，但是客户端不能在发送数据了，只能够发送确认报文。客户端接到服务器的确认报文后，就进入了FIN_WAIT_2状态。也可以说这是等待服务器释放连接状态。 第三次挥手：服务器端所有的数据度发送完了，认为可以关闭连接了，状态变为被动关闭，所以向客户端发送释放连接报文，发完之后自己变为LAST_WAIT状态，也就是等待客户端确认状态。 第四次挥手：客户端接到释放连接报文后，发送一个确认报文，然后自己变为TIME_WAIT,而不是立马关闭，因为客户端发送的确认报文可能会丢失，丢失的话服务器就会重传一个FIN，也就是释放连接报文，这个时候客户端必须还没关闭。 当服务器接受到确认报文后，服务器就进入CLOSE状态，也就是关闭了。但是由于上面说的这个原因，客户端必须等待一定的时间才能够进入CLOSE状态。 volatile执行控制：目的是控制代码执行（顺序）及是否可以并行执行。 内存可见：线程执行结果在内存中对其他线程的可见性。 volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Java锁","slug":"Java/并发编程/Java锁","date":"2021-05-29T06:50:55.104Z","updated":"2021-05-29T09:03:00.638Z","comments":true,"path":"wiki/Java/并发编程/Java锁/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E9%94%81/","excerpt":"","text":"锁的基本概念从广义上来定义： 悲观锁： 比如线程A对某个变量进行修改，在这个修改期间，它持悲观心理，认为其他线程在这个期间，也有可能去修改这个变量，所以它就给变量加个锁，保证在它修改期间，别的线程没法去访问这个变量。这个锁就是悲观锁。悲观锁是重量级锁，代表对象synchronized和Lock。悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。 乐观锁： 比如线程A对某个变量进行修改，在这个修改期间，它持乐观心理，认为其他线程在这个期间，不会去修改这个变量，所以不会加锁。 只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。乐观锁是轻量级锁，代表对象CAS。Java原子类中的递增操作就通过CAS自旋实现的。乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。 悲观锁和乐观锁的基本用法12345678910111213141516// ------------------------- 悲观锁的调用方式 -------------------------// synchronizedpublic synchronized void testMethod() &#123; // 操作同步资源&#125;// ReentrantLockprivate ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁public void modifyPublicResources() &#123; lock.lock(); // 操作同步资源 lock.unlock();&#125;// ------------------------- 乐观锁的调用方式 -------------------------private AtomicInteger atomicInteger = new AtomicInteger(); // 需要保证多个线程使用的是同一个AtomicIntegeratomicInteger.incrementAndGet(); //执行自增1 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。这四种锁是指锁的状态，专门针对synchronized的。 Java头对象synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？ 我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。 Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。 Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 MonitorMonitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。 Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。 如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。 所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。 无锁： 无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。 无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。 偏向锁： 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。 在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。 当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。 偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。 偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。 轻量级锁： 是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。 重量级锁 重量级锁是依赖对象内部的monitor锁来实现。当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cpu。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，需要从用户态转换到内核态，而转换状态是需要消耗很多时间。 综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。 CASCAS锁：（Compare And Swap） 乐观锁的一种实现方式。 CAS算法涉及到三个操作数： 需要读写的内存值 V。 进行比较的值 A。 要写入的新值 B。 当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。 123456789101112131415161718192021222324// ------------------------- JDK 8 -------------------------// AtomicInteger 自增方法public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;// Unsafe.classpublic final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125;// ------------------------- OpenJDK 8 -------------------------// Unsafe.javapublic final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125; 根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。 后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。 CAS虽然很高效，但是它也存在三大问题，这里也简单说一下： ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。 JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。 循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。 只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。 Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。 公平锁和非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。 直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。 如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。 但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示： ReentrantLock中公平锁和非公平锁的实现如下： 12345678910public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。 综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。 可重入锁 VS 非可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析： 12345678910public class Widget &#123; public synchronized void doSomething() &#123; System.out.println(&quot;方法1执行...&quot;); doOthers(); &#125; public synchronized void doOthers() &#123; System.out.println(&quot;方法2执行...&quot;); &#125;&#125; 在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。 如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。 而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。 还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。 但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。 之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。 首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。 当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。 释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。 独享锁 VS 共享锁独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。 独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。 共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。 我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。 在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。 那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。 在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示： 1234567891011121314151617181920protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); int c = getState(); // 取到当前锁的个数 int w = exclusiveCount(c); // 取写锁的个数w if (c != 0) &#123; // 如果已经有线程持有了锁(c!=0) // (Note: if c != 0 and w == 0 then shared count != 0) if (w == 0 || current != getExclusiveOwnerThread()) // 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败 return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) // 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。 throw new Error(&quot;Maximum lock count exceeded&quot;); // Reentrant acquire setState(c + acquires); return true; &#125; if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) // 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。 return false; setExclusiveOwnerThread(current); // 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者 return true;&#125; 这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。 在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。 如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。 如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！ tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。 因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。 接着是读锁的代码： 123456789101112131415161718192021222324252627protected final int tryAcquireShared(int unused) &#123; Thread current = Thread.currentThread(); int c = getState(); if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态 int r = sharedCount(c); if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current);&#125; 可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。 此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码： 我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。 参考 volatile和synchronized的区别 https://stackoverflow.com/questions/9851133/when-to-use-volatile-and-synchronized https://tech.meituan.com/2018/11/15/java-lock.html","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Java容器","slug":"Java/集合/Java_Collections","date":"2021-05-29T06:50:55.104Z","updated":"2021-05-29T09:01:05.293Z","comments":true,"path":"wiki/Java/集合/Java_Collections/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E9%9B%86%E5%90%88/Java_Collections/","excerpt":"","text":"容器类图 Java 中常用的存储容器就是数组和容器，二者有以下区别： 存储大小是否固定 数组的长度固定； 容器的长度可变。 数据类型 数组可以存储基本数据类型，也可以存储引用数据类型； 容器只能存储引用数据类型，基本数据类型的变量要转换成对应的包装类才能放入容器类中。 Java 容器框架主要分为 Collection 和 Map 两种。其中，Collection 又分为 List、Set 以及 Queue。 Collection - 一个独立元素的序列，这些元素都服从一条或者多条规则。 List - 必须按照插入的顺序保存元素。 Set - 不能有重复的元素。 Queue - 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。 Map - 一组成对的“键值对”对象，允许你使用键来查找值。 基础接口Iterator、IterableIterator：可迭代接口，迭代对象Iterable：Collection 接口扩展了 Iterable 接口 123456789101112131415public class IteratorDemo &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); Iterator it = list.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125; Comparable 和 ComparatorComparable：排序接口。若一个类实现了 Comparable 接口，表示该类的实例可以比较，也就意味着支持排序。实现了 Comparable 接口的类的对象的列表或数组可以通过 Collections.sort 或 Arrays.sort 进行自动排序。 Comparator：比较接口。在 Java 容器中，一些可以排序的容器，如 TreeMap、TreeSet，都可以通过传入 Comparator，来定义内部元素的排序规则。 CloneableJava 中 一个类要实现 clone 功能 必须实现 Cloneable 接口，否则在调用 clone() 时会报 CloneNotSupportedException 异常。Java 中所有类都默认继承 java.lang.Object 类，在 java.lang.Object 类中有一个方法 clone()，这个方法将返回 Object 对象的一个拷贝。Object 类里的 clone() 方法仅仅用于浅拷贝（拷贝基本成员属性，对于引用类型仅返回指向改地址的引用）。如果 Java 类需要深拷贝，需要覆写 clone() 方法。 fail-fast机制Java 容器的一种错误检测机制。例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历容器 A 中的元素，在某个时候线程 2 修改了容器 A 的结构（是结构上面的修改，而不是简单的修改容器元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。 List特征 元素可重复 常用List ArrayList：数组实现，随机访问速度快，插入删除较慢 LinkedList：链表实现，插入、删除较快，但查找需要遍历整个链表，速度较慢 Vector：和 ArrayList 类似，但它是线程安全的 Set特征 元素不能重复 常用Set HashSet：基于哈希实现，支持快速查找，但不支持有序性操作，例如根据一个范围查找元素的操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator遍历 HashSet 得到的结果是不确定的。 TreeSet：底层使用红黑树，支持有序性操作，但是查找效率不如 HashSet，HashSet 查找时间复杂度为 O(1)，TreeSet 则为 O(logn)； LinkedHashSet：具有 HashSet 的查找效率，且内部使用链表维护元素的插入顺序。 Map特征 使用键值对存储 键值对都可以为null 常用Map HashMap：在JDK1.8中，基于数组+链表+红黑树。需要自动装箱，有hash碰撞问题 HashTable：哈希表实现，本身是同步的，put操作直接锁住，不支持null键和值。 ConcurrentHashMap：线程安全的HashMap，使用synchronized锁住了链表，性能强于HashTable LinkedHashMap：使用链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 SortedMap： TreeMap：基于红黑树的一种提供顺序访问的Map SparseArray：Android平台专有，避免自动装箱，k、v都使用数组实现，k为整型。使用二分查找。删除时将v设置为DELETE。 Queue LinkedList：可以用它来支持双向队列； PriorityQueue 是基于堆结构实现，可以用它来实现优先级队列。 常见面试题ArrayList与LinkedList的实现和区别？ ArrayList由动态数组实现，LinkedList由链表实现 ArrayList随机访问快，LinkedList插入删除快","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"http://shjlone.github.io/categories/Java/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"ConstraintLayout","slug":"Android/UI/ConstraintLayout","date":"2021-05-29T06:50:55.103Z","updated":"2021-06-08T08:00:29.089Z","comments":true,"path":"wiki/Android/UI/ConstraintLayout/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/ConstraintLayout/","excerpt":"","text":"layout_constraintLeft_toRightOf的理解constraintXXX表示约束View自己，XXX分别表示上下左右等位置，toXXXOf表示约束依赖等对象，可以是同级的View，也可以是parent。 layout_constraintBaseline_toBaselineOf对于TextView，可以使用基线对齐，这样文字就能对齐了。 边距不同方位的边距 android:layout_marginStart android:layout_marginEnd android:layout_marginLeft android:layout_marginTop android:layout_marginRight android:layout_marginBottom 目标View隐藏时，以下属性生效 layout_goneMarginStart layout_goneMarginEnd layout_goneMarginLeft layout_goneMarginTop layout_goneMarginRight layout_goneMarginBottom 水平居中 layout_constraintLeft_toLeftOf &amp; layout_constraintRight_toRightOf垂直居中 layout_constraintTop_toTopOf &amp; layout_constraintBottom_toBottomOf layout_constraintHorizontal_bias 水平偏移layout_constraintVertical_bias 垂直偏移 两个属性的取值范围在0-1。在水平偏移中，0表示最左，1表示最右；在垂直偏移，0表示最上，1表示最下；0.5表示中间。 参考","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"ContentProvider","slug":"Android/基础/ContentProvider","date":"2021-05-29T06:50:55.103Z","updated":"2021-06-10T10:15:21.429Z","comments":true,"path":"wiki/Android/基础/ContentProvider/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/ContentProvider/","excerpt":"","text":"关于ContentProvider，用来提供其他地方（包括其他App）调用的一种全局（系统级）方式。有了ContentProvider，我们就能方便的调用相册的东西、进行文件选择，在我们自己的App中，也可以提供一个数据中心。 在Jetpack中，也运用了ContentProvider的特性来提升启动速度。 一些注意点 对于面向 Android 7.0 的应用，Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。 因为Android7的变化，所以在使用FileProvider时需要做一些处理，关于如何处理，网上一大把资料，总结出来需要以下步骤： 配置Manifest文件，添加provider 对于Android7以上，在FileProvider.getUriForFile时使用配置的authority 参考 官方使用手册 https://blog.csdn.net/lmj623565791/article/details/72859156 https://developer.android.com/topic/libraries/app-startup","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"ThreadLocal原理","slug":"Java/并发编程/ThreadLocal原理","date":"2021-05-29T06:50:55.103Z","updated":"2021-06-08T08:37:58.566Z","comments":true,"path":"wiki/Java/并发编程/ThreadLocal原理/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal%E5%8E%9F%E7%90%86/","excerpt":"","text":"ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。 源码分析Thread中有一个成员变量： 1ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal的set方法中，如果当前Thread的threadLocals有值，则设置，没有则创建一个新的ThreadLocalMap。 123456789101112131415161718/** * Sets the current thread&#x27;s copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread&#x27;s copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; ThreadLocal的get方法中，从当前线程的threadLocals拿map，如果有则返回，没有则初始化值。 12345678910111213141516171819202122/** * Returns the value in the current thread&#x27;s copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread&#x27;s value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 值的修改都是在自己线程中操作的，所以是线程安全的。 使用场景 每个线程需要有自己单独的实例 实例需要在多个方法中共享，但不希望被多线程共享 Android中Hander 1234567static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 参考 http://www.jasongj.com/java/threadlocal/ https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"并发编程","slug":"Java/并发编程","permalink":"http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/tags/Java/"}]},{"title":"Android测试实践","slug":"Android/Android测试实践","date":"2021-05-29T06:50:55.102Z","updated":"2021-06-04T02:37:27.134Z","comments":true,"path":"wiki/Android/Android测试实践/","link":"","permalink":"http://shjlone.github.io/wiki/Android/Android%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"为什么要做测试？很多公司为了节省成本，基本上是不会要求开发写单元测试的。自己做完的功能，动手点点看看基本流程是否通畅就丢给测试了。项目小的时候这样也不会有啥问题。随着项目的复杂度越来越高，人员越来越多，不同的人员改动到同一块代码，但彼此对原来的逻辑不是很清楚（因为代码量实在太多，想要一个人弄清楚所有细节已经不太可能）。这也是为什么大家宁肯写新的代码也不愿意改旧的代码的原因。而如果每个功能在开发的同时配置了单元测试，那么理论上新的功能 开发完之后，所有的单元测试应该都是可以跑通的。这样就能自动帮我们检查出来一些难以发现的bug。 Android如何进行单元测试 androidTest目录：应包含在实际或虚拟设备上运行的测试。此类测试包括集成测试，端到端测试以及仅JVM无法验证应用程序功能的其他测试。 test目录：应包含在本地计算机上运行的测试，例如单元测试 测试常用库 JUnit Mockito PowerMock Espresso JUnitTestCase TestResult TestSuite 测试套件 在实际项目中，随着项目进度的开展，单元测试类会越来越多，可是直到现在我们还只会一个一个的单独运行测试类，这在实际项目实践中肯定是不可行的。 为了解决这个问题，JUnit 提供了一种批量运行测试类的方法，叫做测试套件。 断言： Assert 标注： 标注|描述|—|—|@Test|该方法是一个测试用例@Before|每个测试方法执行之前执行@After|每个测试方法执行后执行@BeforeClass|一个测试文件只执行一次@AfterClass|一个测试文件最后执行一次@Ignore|这个注解是用来忽略有关不需要执行的测试的。 Mockito模拟被测对象依赖的对象 参考 https://dunwu.github.io/javatech/test/mockito.html PowerMock模拟被测对象依赖的静态方法 RobolectricAndroid SDK测试框架 Config配置参考 https://maxwell-nc.github.io/android/robolectricTest.html https://www.jianshu.com/p/6c23f2681105 Espresso","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"如何提升Android应用的安全","slug":"Android/逆向/如何提升Android应用的安全","date":"2021-05-29T06:50:55.102Z","updated":"2021-05-29T06:50:55.102Z","comments":true,"path":"wiki/Android/逆向/如何提升Android应用的安全/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E9%80%86%E5%90%91/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87Android%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8/","excerpt":"","text":"关于权限获取关于exported参考 https://blog.csdn.net/u013107656/category_6257625.html","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://shjlone.github.io/categories/Android/%E9%80%86%E5%90%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android客户端经验谈","slug":"Android/Android客户端经验谈","date":"2021-05-29T06:50:55.101Z","updated":"2021-06-07T10:09:06.265Z","comments":true,"path":"wiki/Android/Android客户端经验谈/","link":"","permalink":"http://shjlone.github.io/wiki/Android/Android%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%8F%E9%AA%8C%E8%B0%88/","excerpt":"","text":"一些技巧异步线程应该在Activity、Fragment的生命周期结束时停止掉关于隐私策略由于政策要求，隐私策略需要放到运行时就弹出并由用户确认。这里有个点需要注意，只有当用户确认后才可进行后续的数据请求。","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"JNI笔记","slug":"Android/JNI笔记","date":"2021-05-29T06:50:55.100Z","updated":"2021-06-04T02:37:05.664Z","comments":true,"path":"wiki/Android/JNI笔记/","link":"","permalink":"http://shjlone.github.io/wiki/Android/JNI%E7%AC%94%E8%AE%B0/","excerpt":"","text":"JNI开发流程 编写声明了native方法的Java类 将Java源代码编译成class字节码文件 用javah -jni 命令生成.h头文件（javah 是 jdk 自带的一个命令，-jni 参数表示将 class 中用native 声明的函数生成 JNI 规则的函数） 用本地代码实现.h头文件中的函数 将本地代码编译成动态库（Windows：*.dll，linux/unix：*.so，mac os x：*.jnilib） 拷贝动态库至 java.library.path 本地库搜索目录下，并运行 Java 程序 JVM查找native方法的规则JNI数据类型与Java数据类型的映射关系字符串处理访问数组C/C++访问Java实例方法和静态方法C/C++访问Java实例变量和静态变量JNI调用构造方法和父类实例方法参考 https://developer.android.com/training/articles/perf-jni wiki.jikexueyuan.com/project/jni-ndk-developer-guide/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"CoordinatorLayout","slug":"Android/UI/CoordinatorLayout","date":"2021-05-29T06:50:55.100Z","updated":"2021-06-08T08:00:38.250Z","comments":true,"path":"wiki/Android/UI/CoordinatorLayout/","link":"","permalink":"http://shjlone.github.io/wiki/Android/UI/CoordinatorLayout/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"UI","slug":"Android/UI","permalink":"http://shjlone.github.io/categories/Android/UI/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"JEB使用笔记","slug":"Android/逆向/JEB使用笔记","date":"2021-05-29T06:50:55.100Z","updated":"2021-05-29T06:50:55.100Z","comments":true,"path":"wiki/Android/逆向/JEB使用笔记/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E9%80%86%E5%90%91/JEB%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"https://www.pnfsoftware.com/jeb/manual/ 在使用Jeb的时候，关闭Android Studio。 如何debug 对于一个release包，是无法进行debug的，需要apktool进行反编译，自行打包并签名。 command+b：打开关闭断点","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://shjlone.github.io/categories/Android/%E9%80%86%E5%90%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"OkHttp学习笔记","slug":"Android/开源库/OKHttp学习笔记","date":"2021-05-29T06:50:55.099Z","updated":"2021-06-02T06:05:07.615Z","comments":true,"path":"wiki/Android/开源库/OKHttp学习笔记/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/OKHttp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Handler原理","slug":"Android/基础/Handler原理","date":"2021-05-29T06:50:55.099Z","updated":"2021-06-08T03:18:20.344Z","comments":true,"path":"wiki/Android/基础/Handler原理/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Handler%E5%8E%9F%E7%90%86/","excerpt":"","text":"Hanlder系列目录： Handler基本用法 Handler原理 概要Handler是Android子线程和主线程之间通信的一种机制。 使用Handler的原因是多个线程并发更新UI的同时保证线程安全。 概念 定义 作用 主线程 当应用程序第一次启动时，会同时自动开启一条主线程 处理UI相关 子线程 人为手动创建的线程 执行耗时操作 消息（Message） 线程间通讯的数据单元 存储需要操作的信息 消息队列（MessageQueue） 一种数据结构 存储Handler发送过来的信息（Message） 处理者（Handler） 主线程与子线程的通信媒介，线程消息的主要处理者 添加消息到消息队列，处理Looper分派过来的消息 循环器（Looper） 消息队列与处理器的通信媒介 消息获取：循环取出消息队列的消息，消息分发：将取出的消息发送给对应的处理者 ThreadLocal 用于不同线程保存自己的信息 工作流程 异步通信准备 在主线程中创建 处理器对象Looper 消息队列对象MessageQueue，Looper自动进入消息循环 Handler对象，自动绑定主线程的Looper、MessageQueue 消息发送 消息循环 消息处理 注意 每个线程只有一个Looper 一个Looper可以绑定多个线程的Handler（实现线程间通信） 源码分析按照我们的使用顺序，先看看Handler的构造函数 123456789101112131415161718192021222324252627//接受Looper参数，绑定线程public Handler(@NonNull Looper looper) &#123; this(looper, null, false);&#125; public Handler(@Nullable Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125;//绑定线程，在使用的时候，如果不设置Looper，则使用当前线程的Looper。//Looper.myLooper()作用：获取当前线程的Looper对象；若线程无Looper对象则抛出异常 mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&#x27;t create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 那么Looper是在什么时候构造的呢？我们可以先看看主线程的初始化是如何做的，以下是ActivityThread的入口函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper();//构造了Looper // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format &quot;seq=114&quot; long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop();//looper进入循环，正常情况下下面的代码是不会执行的 throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 那么Looper内部又做了什么呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125; &#125;private static void prepare(boolean quitAllowed) &#123;//判断looper是否是null如果是，就创建，并将其存到ThreadLocal中，上面说的handler中的looper就是从ThreadLocal中取出来的；//这里可知，每个线程只有一个Looper if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; Binder.clearCallingIdentity(); //这里大家不用管，我个人理解是对进程的校验，有知道的同学也可以留言告诉我。 final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); //分发消息，这里的target就是handler &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); //消息的回收 &#125;&#125; 至此，我们知道一个线程中只有一个Looper，Looper进行循环后，会不停的从消息队列中拿到消息进行处理。 然后就是消息的发送和接收，我们先看看消息是如何发送的 123456789101112131415161718192021222324252627282930313233343536Handler.java//发送消息public final boolean sendMessage(@NonNull Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; //消息被添加到消息队列中，loop中处理 return queue.enqueueMessage(msg, uptimeMillis);&#125; 从loop方法中可知，dispatchMessage会最终处理消息 123456789101112131415Handler.javapublic void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 判断msg.callback是不是null，如果不是，那么就给这个callback处理，这个callback是message中的一个Runnable；Message.obtain()其实是有其他参数的方法的，其中有一个是obtain(Handler h, Runnable callback)；如果你用了这个，那么消息就会在你实现的Runnable中接收到处理的回调； 第二个是判断handler内部的callback是不是null，如果不是null，就让他去处理，这里的Callback可不是Runnable了，他是一个interface，里面定义了一个handleMessage(Message msg);方法，这个怎么实现呢？handler类里同样有Handler(Callback callback)构造方法 最后才轮到handler类里的方法handleMessage来处理消息。 Handler引起的内存泄露原因以及最佳解决方案Handler允许我们发送延时消息，如果在延时期间用户关闭了Activity，那么该 Activity 会泄露。 这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。 将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并在Acitivity的onDestroy()中调用handler.removeCallbacksAndMessages(null)及时移除所有消息。具体用法可以参考Handler基本用法 参考 https://www.jianshu.com/p/03d29cfe85cc https://www.jianshu.com/p/b4d745c7ff7a","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android逆向记录","slug":"Android/逆向/Android逆向记录","date":"2021-05-29T06:50:55.099Z","updated":"2021-05-29T06:50:55.099Z","comments":true,"path":"wiki/Android/逆向/Android逆向记录/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E9%80%86%E5%90%91/Android%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"12345678910111213#反编译apk文件apktool d app-release.apk如果出现编译assets文件夹中的dex文件失败，则使用--only-main-classes参数。#编译修改后的应用apktool b app-release -o output.apk#对编译好的apk进行签名apksigner sign --ks keystore文件路径 output.apk~/Android/sdk/build-tools/29.0.3/apksigner sign --ks ~/Android/tools/keys/test_keystore lizhi_output.apk 签名参考：https://developer.android.com/studio/command-line/apksigner?hl=zh-cn META-INF文件夹的内容 MINFEST.MF：声明了资源，与CERT.SF文件相似。CERT.RSA：公钥证书。keytool -printcert -file CERT.RSA 输出证书内容 1234567891011所有者: CN=Bbcallen, OU=danmaku.tv, O=danmaku.tv, L=Zhuhai, ST=Guangdong, C=CN发布者: CN=Bbcallen, OU=danmaku.tv, O=danmaku.tv, L=Zhuhai, ST=Guangdong, C=CN序列号: 4f3bb0ec有效期为 Wed Feb 15 21:19:40 CST 2012 至 Thu Nov 18 21:19:40 CST 2066证书指纹: MD5: 71:94:D5:31:CB:E7:96:0A:22:00:7B:9F:6B:DA:A3:8B SHA1: 96:DC:60:5B:95:19:BA:B9:4E:DD:BE:AA:A0:59:A6:69:FB:A2:C2:11 SHA256: 93:BA:27:0F:55:21:13:9E:CA:FE:4B:B6:38:AC:5B:11:98:BC:54:8F:62:D9:FD:8F:85:80:A0:79:FA:F5:91:0E签名算法名称: SHA1withRSA主体公共密钥算法: 1024 位 RSA 密钥版本: 3 CERT.SF：包含了app的所有资源文件，负责对app进行签名， Android Studio动态调试12345678910111213141516171819202122232425262728反编译apk文件，添加debug属性，打包、签名新的可debug的apk。安装。安装Android Studio插件smalideahttps://bitbucket.org/JesusFreke/smali/downloads/使用baksmali反编译apk文件java -jar baksmali -o myapp/src先启动应用，查看主activityadb shell &quot;dumpsys activity top | grep ACTIVITY&quot;然后以debug模式启动appadb shell am start -D -n androiddemo.han.com.myapplication/.MainActivity查看进程adb shell &quot;ps | grep 包名&quot;端口转发adb forward tcp:8787 jdwp:app_pidadb shell am set-debug-app -w --persistent 包名 一直使用debug模式启动应用adb shell am clear-debug-app 取消使用debug启动应用","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"逆向","slug":"Android/逆向","permalink":"http://shjlone.github.io/categories/Android/%E9%80%86%E5%90%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android sdk目录结构","slug":"Android/基础/Android sdk目录结构","date":"2021-05-29T06:50:55.098Z","updated":"2021-06-10T10:15:06.848Z","comments":true,"path":"wiki/Android/基础/Android sdk目录结构/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Android%20sdk%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","excerpt":"","text":"sdk add-ons：第三方公司为Android平台开发的附加功能系统 build-tools：构建工具 28.0.3： aapt.exe：打包res资源文件，生成R.java、resources.arsc和res aapt2.exe aidl.exe apksigner.bat bcc_compat.exe d8.bat dexdump.exe dx.bat llvm-rs-cc.exe mainDexClasses.bat split-select.exe zipalign.exe cmake docs：API文档 emulator extras：存放Android support v4、v7、v13、v17包 fonts licenses lldb：C/C++调试器，它与LLVM编译器一起使用，提供了丰富的流程控制和数据检测 ndk-bundle ndk-build.cmd ndk-depends.cmd ndk-gdb.cmd ndk-stack.cmd ndk-which.cmd patcher platforms：根据API level存放不同版本的Android系统 android-28：28表示版本 data：系统资源 optional skin：Android模拟器的皮肤 android.jar uiautomator.jar platform-tools：Android平台通用工具 adb.exe dmtracedump.exe etc1tool.exe：PNG图像压缩为etc1标准 fastboot.exe：刷机工具 hprof-conv.exe：hprof文件转换命令，将Android Studio工具生成的hprof文件转换成一个标准格式 make_f2fs.exe mke2fs.exe：建立ext2文件系统 sqlite3.exe：数据库工具 sources system-images：模拟器映像文件 tools：Android开发和调试工具 bin archquery.bat avdmanager.bat jobb.bat：处理APK扩展文件的工具 lint.bat：代码检测 monkeyrunner.bat：测试工具 sdkmanager.bat:SDK管理器 uiautomatorviewer.bat：测试工具 android.bat emulator.exe emulator-check.exe mksdcard.exe：使用模拟器时，用来创建sd卡 monitor.bat compileSdkVersion：告诉Gradle用哪个Android SDK版本编译你的应用，使用任何新添加的API都需要对应等级的Android SDK。修改compileSdkVersion不会改变运行时的行为。如果使用Support Library，那么使用最新发布的 Support Library 就需要使用最新的 SDK 编译。例如，要使用 23.1.1 版本的 Support Library ，compileSdkVersion 就必需至少是 23 （大版本号要一致！）。 minSdkVersion：设置应用可以运行的最低版本要求 targetSdkVersion：系统会根据这个值来应用最新的行为变化。比如API 23会把你的应用转换到运行时权限模型。当设置targetSdkVersion小于23时，在6.0的机器上不会动态申请权限。 buildToolsVersion：构建工具的版本，其中包括aapt、dx等，这个工具的目录在Android sdk/build-tools/ 参考 https://medium.com/androiddevelopers/picking-your-compilesdkversion-minsdkversion-targetsdkversion-a098a0341ebd#.tz5zzucma","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Android中support的使用","slug":"Android/基础/Android support包","date":"2021-05-29T06:50:55.098Z","updated":"2021-06-10T10:15:06.844Z","comments":true,"path":"wiki/Android/基础/Android support包/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Android%20support%E5%8C%85/","excerpt":"","text":"使用support-vX包的原因 向后兼容 提供不适合打包进framework的功能 支持不同形态的设备 support-v4implemention: &quot;com.android.support:support-v4:27.1.1&quot; v4名称是最开始支持api level4的库，官方在Support Library 24.2.0版本的时候移除了对Android 2.2(API Level 8)及以下版本的支持，所以从Android Support Library 24.2.0开始，V4包支持的最低版本是Android 2.3即API Level 9)，并且把v4库拆分成5个部分，可以在项目中按需要引用，但是必要性不是很大，一是因为这5个部分有依赖关系，二是compat库占了v4库的一半大小，v4库的依赖关系图： Fragment:一个专为解决Android碎片化的类，通过它可以让同一个程序适配不同的屏幕。NotificationCompat:支持更丰富的通知形式；LocalBroadcastManager:适合于应用内的消息传递。ViewPager:一个可以管理子view的viewgroup，用户可以在各个view之间自由切换，这个在很多应用中都有使用到； support-v7V7和V4一样，同样包含多个依赖包，但和V4不同的是，V7下的多个子包并不是后面拆分开来的，而是最初发布时就以各个独立库的形式发布的。它是针对Android 2.3(API Level 9)及以上的版本谷歌提供了一系列的support包（和V4包的命名一样，V7最初支持的最低版本是Android 2.1即API Level 7，所以称其为V7，同样在Android Support Library 24.2.0将V7支持的最低版本改为Android 2.3即API Level 9了），这些support包各自对应着特定的功能，每一个都可以单独地被引用。 implemention: &quot;com.android.support:appcompat-v7:27.1.1&quot;, implemention: &quot;com.android.support:design:27.1.1&quot;, implemention: &quot;com.android.support:recyclerview-v7:27.1.1&quot;, implemention: &quot;com.android.support:cardview-v7:27.1.1&quot;, implemention: &quot;com.android.support:support-annotations:27.1.1&quot;, implemention: &quot;com.android.support:support-vector-drawable:27.1.1&quot;, implemention: &quot;com.android.support:mediarouter-v7:27.1.1&quot;, implemention: &quot;com.android.support:gridlayout-v7:27.1.1&quot;, implemention: &quot;com.android.support:preference-v7:27.1.1&quot;, implemention: &quot;com.android.support:palette-v7:27.1.1&quot;, appcompat-v7：这个包支持对Action Bar接口的设计模式、Material Design接口的实现等，核心类有ActionBar、AppCompatActivity、AppCompatDialog、ShareActionProvider等。当使用依赖这个包后，会自动引入v4包 design： recyclerview-v7：核心类是RecyclerView，用于替换ListView、GridView cardview-v7：支持cardview控件，使用Material Design语言设计，卡片式的信息展示，在电视App中有广泛的使用 support-annotations：支持标注 support-vector-drawable： mediarouter-v7：用于设备间音频、视频交换显示的support包 gridlayout-v7：支持Grid Layout布局的包 preference-v7：支持存储配置数据的包，比如CheckBoxPreference和ListPreference palette-v7：页面的颜色动态变换 support-v13这个包的作用主要是为Android3.2（API Level 13）及以上的系统提供更多地Framgnet特性支持，使用它的原因在于，android-support-v4.jar中虽然也对Fragment做了支持，由于要兼容低版本，导致他是自行实现的 Fragment 效果，在高版本的Fragment的一些特性丢失了，而对于v13以上的sdk版本，我们可以使用更加有效，特性更多的代码。 implemention: &quot;com.android.support:support-v13:27.1.1&quot;, support-v14support-v17支持电视设备 implemention &quot;com.android.support:leanback-v17:27.1.1&quot; AndroidX配置 properties.gradle中配置 //启用AndroidX android.useAndroidX=true //将依赖包也迁移到AndroidX android.enableJetifier=true Android Studio中设置 Refactor -&gt; Migrate to AndroidX 解决依赖冲突的一些方法保持版本统一 强制设置使用某一个版本 android &#123; configurations.all &#123; resolutionStrategy.force &quot;com.squareup.okhttp3:okhttp:3.12.1&quot; &#125; &#125; 依赖的时候使用exclude implementation(&#39;me.drakeet.multitype:multitype:3.4.4&#39;, &#123; exclude group: &#39;com.android.support&#39; &#125;) 参考 https://developer.android.com/jetpack/androidx https://developer.android.com/jetpack/androidx/migrate","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Apk包体积优化","slug":"Android/性能优化/Apk包体积优化","date":"2021-05-29T06:50:55.098Z","updated":"2021-06-10T10:14:05.140Z","comments":true,"path":"wiki/Android/性能优化/Apk包体积优化/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Apk%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/","excerpt":"","text":"Gradle配置minifyEnabled true shrinkResources true minifyEnabled：删除无用代码shrinkResources：删除无用资源","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"性能优化","slug":"Android/性能优化","permalink":"http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Dagger2学习笔记","slug":"Android/开源库/Dagger2学习笔记","date":"2021-05-29T06:50:55.096Z","updated":"2021-06-02T06:05:07.610Z","comments":true,"path":"wiki/Android/开源库/Dagger2学习笔记/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Dagger2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"开源库","slug":"Android/开源库","permalink":"http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"}],"tags":[]},{"title":"AndroidManifest描述文件","slug":"Android/基础/AndroidManifest","date":"2021-05-29T06:50:55.096Z","updated":"2021-06-04T10:10:42.047Z","comments":true,"path":"wiki/Android/基础/AndroidManifest/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/AndroidManifest/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;?xml version=&quot;1.0&quot; encoding=&quot;uft-8&quot; ?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/red/android&quot; package=&quot;com.example.android&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot;&gt; &lt;uses-permission /&gt; &lt;permission /&gt; &lt;permission-tree /&gt; 权限配置 &lt;permission-group /&gt; &lt;instrumentation android:functionalTest=[&quot;true&quot; | &quot;false&quot;] android:handleProfiling=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:label=&quot;string resource&quot; android:name=&quot;string&quot; android:targetPackage=&quot;string&quot; /&gt; &lt;uses-sdk /&gt; &lt;uses-configuration /&gt; &lt;uses-feature /&gt; 环境配置 &lt;supports-screens /&gt; &lt;compatible-screens /&gt; &lt;supports-gl-texture /&gt; 应用基本配置 &lt;application android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;] android:allowBackup=[&quot;true&quot; | &quot;false&quot;] android:backupAgent=&quot;string&quot; android:debuggable=[&quot;true&quot; | &quot;false&quot;] android:description=&quot;string resource&quot; android:enabled=[&quot;true&quot; | &quot;false&quot;] android:hasCode=[&quot;true&quot; | &quot;false&quot;] android:hardwareAccelerated=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:killAfterRestore=[&quot;true&quot; | &quot;false&quot;] android:largeHeap=[&quot;true&quot; | &quot;false&quot;] android:label=&quot;string resource&quot; android:logo=&quot;drawable resource&quot; android:manageSpaceActivity=&quot;string&quot; android:name=&quot;string&quot; android:permission=&quot;string&quot; android:persistent=[&quot;true&quot; | &quot;false&quot;] android:process=&quot;string&quot; android:restoreAnyVersion=[&quot;true&quot; | &quot;false&quot;] android:requiredAccountType=&quot;string&quot; android:restrictedAccountType=&quot;string&quot; android:supportsRtl=[&quot;true&quot; | &quot;false&quot;] android:taskAffinity=&quot;string&quot; android:testOnly=[&quot;true&quot; | &quot;false&quot;] android:theme=&quot;resource or theme&quot; android:uiOptions=[&quot;none&quot; | &quot;splitActionBarWhenNarrow&quot;] android:vmSafeMode=[&quot;true&quot; | &quot;false&quot;] &gt; //界面组件配置 &lt;activity android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;] android:alwaysRetainTaskState=[&quot;true&quot; | &quot;false&quot;] android:clearTaskOnLaunch=[&quot;true&quot; | &quot;false&quot;] android:configChanges=[&quot;mcc&quot;, &quot;mnc&quot;, &quot;locale&quot;, &quot;touchscreen&quot;, &quot;keyboard&quot;, &quot;keyboardHidden&quot;, &quot;navigation&quot;, &quot;screenLayout&quot;, &quot;fontScale&quot;, &quot;uiMode&quot;, &quot;orientation&quot;, &quot;screenSize&quot;, &quot;smallestScreenSize&quot;] android:enabled=[&quot;true&quot; | &quot;false&quot;] android:excludeFromRecents=[&quot;true&quot; | &quot;false&quot;] android:exported=[&quot;true&quot; | &quot;false&quot;] android:finishOnTaskLaunch=[&quot;true&quot; | &quot;false&quot;] android:hardwareAccelerated=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:label=&quot;string resource&quot; android:launchMode=[&quot;multiple&quot; | &quot;singleTop&quot; | &quot;singleTask&quot; | &quot;singleInstance&quot;] android:multiprocess=[&quot;true&quot; | &quot;false&quot;] android:name=&quot;string&quot; android:noHistory=[&quot;true&quot; | &quot;false&quot;] android:parentActivityName=&quot;string&quot; android:permission=&quot;string&quot; android:process=&quot;string&quot; android:screenOrientation=[&quot;unspecified&quot; | &quot;behind&quot; | &quot;landscape&quot; | &quot;portrait&quot; | &quot;reverseLandscape&quot; | &quot;reversePortrait&quot; | &quot;sensorLandscape&quot; | &quot;sensorPortrait&quot; | &quot;userLandscape&quot; | &quot;userPortrait&quot; | &quot;sensor&quot; | &quot;fullSensor&quot; | &quot;nosensor&quot; | &quot;user&quot; | &quot;fullUser&quot; | &quot;locked&quot;] android:stateNotNeeded=[&quot;true&quot; | &quot;false&quot;] android:taskAffinity=&quot;string&quot; android:theme=&quot;resource or theme&quot; android:uiOptions=[&quot;none&quot; | &quot;splitActionBarWhenNarrow&quot;] android:windowSoftInputMode=[&quot;stateUnspecified&quot;, &quot;stateUnchanged&quot;, &quot;stateHidden&quot;, &quot;stateAlwaysHidden&quot;, &quot;stateVisible&quot;, &quot;stateAlwaysVisible&quot;, &quot;adjustUnspecified&quot;, &quot;adjustResize&quot;, &quot;adjustPan&quot;] &gt; . . . &lt;/activity&gt; &lt;activity&gt; &lt;intent-filter&gt; &lt;action /&gt; &lt;category /&gt; &lt;data /&gt; &lt;/intent-filter&gt; &lt;meta-data /&gt; &lt;/activity&gt; &lt;activity-alias&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; &lt;meta-data /&gt; &lt;/activity-alias&gt; &lt;service&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; &lt;meta-data/&gt; 服务组件配置 &lt;/service&gt; &lt;receiver&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; 触发器组件配置 &lt;meta-data /&gt; &lt;/receiver&gt; 数据源组件配置 &lt;provider android:authorities=&quot;list&quot; android:enabled=[&quot;true&quot; | &quot;false&quot;] android:exported=[&quot;true&quot; | &quot;false&quot;] android:grantUriPermissions=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:initOrder=&quot;integer&quot; android:label=&quot;string resource&quot; android:multiprocess=[&quot;true&quot; | &quot;false&quot;] android:name=&quot;string&quot; android:permission=&quot;string&quot; android:process=&quot;string&quot; android:readPermission=&quot;string&quot; android:syncable=[&quot;true&quot; | &quot;false&quot;] android:writePermission=&quot;string&quot; &gt; . . . &lt;/provider&gt;------------------------------------------------------------------------------------------------------------------------------------------- &lt;uses-library /&gt; 依赖库配置------------------------------------------------------------------------------------------------------------------------------------------- &lt;/application&gt;&lt;/manifest&gt; manifest标签 属性 描述 android:installLocation 设置应用的安装环境，如preferExternal表示安装到外部存储设备中；但运行时产生的数据还是会在/data/data目录下 uses-permission标签请求应用使用到的权限 属性 描述 android:name 使用的权限名字 permission标签限定权限来限制第三方应用的访问 属性 描述 android:name android:permissionGroup 权限的分组，如android.permission-group.COST_MONEY提示用户该应用可能会消耗通信费用，如果没有预定义该权限的分组，也可以通过配置项定义 android:label 标签 android:description 描述 instrumentation标签这个元素声明了一个Instrumentation类，这个类能够监视应用程序跟系统的交互。Instrumentation对象会在应用的其他所有组件被实例化之前实例化。 属性 描述 android:functionalTest 这个属性用于指定Instrumentation类是否应该作为一个功能性的测试来运行，如果设置为true，这要运行，否则不应该运行。默认值是false。 android:handleProfiling 这个属性用于指定Instrumentation对象是否会开启和关闭分析功能。如果设置为true，那么由Instrumentation对象来决定分析功能的启动和终止时机，如果设置为false，则分析功能会持续到Instrumentation对象整个运行周期。如果设置为true，会使Instrumentation对象针对一组特定的操作来进行分析。默认值是false。 android:targetPackage 制定Intrumentation对象所监视的应用程序。 uses-feature标签声明应用所依赖的外设或Android的特色功能。比如，一款主打拍照功能的应用需要声明所安装的设备需要有相机 supports-screens标签 属性 描述 android:resizeable 指明应用程序是否根据不同的屏幕尺寸进行缩放。如果设为否，则在较大屏幕上系统将以屏幕兼容模式运行应用程序。本属性已过时。为了帮助程序从Android 1.5升级为1.6才引入本属性，当时第一次引入了对多种屏幕的支持。不应再使用本属性。 android:smallScreens 指明应用程序是否支持较小屏幕。较小的屏幕是指小于“normal”（传统的HVGA）大小的屏幕。不支持小屏幕的应用程序将在外部服务（比如Android Market）中禁止用于小屏幕设备，因为只有很少一部分平台能让程序运行在小屏幕上。缺省值是“true”。 android:normalScreens 指明应用程序是否支持“normal”屏幕尺寸。传统意义上指的是中等密度的HVGA 屏幕，但低密度的WQVGA和高密度的WVGA一般也被视为是正常尺寸。缺省属性是“true”。 android:largeScreens 指明应用程序是否支持大屏幕尺寸。大屏幕是指明显比“normal”手持设备屏幕更大的尺寸。虽然依赖于系统的缩放也能全屏显示，但为了更好的用户体验可能需要对程序组件进行特定的处理。本属性的缺省值依版本而各不相同，因此最好是一直都明确声明这个属性。注意设为“false”将总是启用屏幕兼容模式。 android:xlargeScreens 指明应用程序是否支持超大屏幕尺寸。超大屏幕是指明显比“large”屏幕更大的尺寸，比如平板设备（或更大），虽然依赖于系统的缩放也能全屏显示，但为了更好的用户体验可能需要对程序组件进行特定的处理。本属性的缺省值依版本而各不相同，因此最好是一直都明确声明这个属性。注意设为“false”将总是启用屏幕兼容模式。本属性自API level 9引入。 android:anyDensity 指明应用程序是否包含适用于任何屏幕密度的资源。对于支持Android 1.6 (API level 4)以上版本的应用程序而言，本属性缺省值是“true”。除非绝对确认程序必须要能运行，不应设为“false”。只有应用程序要直接操作位图时（详情参阅支持多种屏幕文档），才可能需要禁用此选项。 android:requiresSmallestWidthDp 指定程序所需的smallestWidth最小值。smallestWidth是指可被程序用户界面使用的屏幕可用空间的最小值（单位为dp）——指可用屏幕两边中最短的那条边长。为了保证与应用程序兼容，设备的smallestWidth必须大于等于本属性值。（通常此值对应于布局layout所支持的“最小宽度”，而与屏幕当前的方向无关。）例如，典型的手持设备的最小宽度是320dp，7英寸的平板设备的最小宽度是600dp，10英寸的平板设备的最小宽度是720dp。因为这些值即为屏幕可用空间的最小值，所以一般也即是smallestWidth的值。在计算屏幕上的组件排列和系统用户界面大小时会与本属性值进行比较。例如，如果设备屏幕上需要显示一些永久性的用户界面元素，这些元素占用的屏幕位置对于其它用户界面元素是不可用的，通过对这些元素尺寸进行计算，系统声明的设备smallestWidth会比实际屏幕尺寸要小些。因此，应该用layout所需的最小宽度来设置此值，而与屏幕的方向无关。如果应用程序能在小屏幕上正确缩放（最低是small尺寸或最小宽度320dp），那就不需要用到本属性。否则，就应该为最小屏幕宽度标识符设置本属性来匹配应用程序所需的最小尺寸。警告：Android系统并不关心本属性，因此它不会影响程序运行时的表现。它是用于为诸如Android Market之类的服务启用过滤功能。不过，Android Market 当前还不支持对这个属性的过滤（Android 3.2），因此如程序不支持小屏幕的话还应继续使用其它屏幕尺寸的属性来进行限制。本属性自API level 13引入。 android:compatibleWidthLimitDp 通过指定程序支持的“最小屏幕宽度”的最大值，本属性可启用屏幕兼容模式作为用户可选项。如果设备可用屏幕的最小边长大于在此设置的值，用户将仍可以安装程序，但会运行在屏幕兼容模式。缺省情况下，屏幕兼容模式将被关闭，layout将如常缩放至全屏显示，但系统状态栏中会出现一个按钮，用户可以用此按钮来开关屏幕兼容模式。如果应用程序能兼容所有的屏幕尺寸，layout也能正确缩放，那就不需要用到本属性。注意：目前屏幕兼容模式只能在手持设备上仿真320dp宽度的屏幕，因此ndroid:compatibleWidthLimitDp大于320时屏幕兼容模式将不会生效。本属性自API level 13引入。 android:largestWidthLimitDp 通过指定程序支持的“最小屏幕宽度”的最大值，本属性可强制开启屏幕兼容模式。如果设备屏幕的最小边长大于本属性值，应用程序将运行在屏幕兼容模式，且用户无法将其关闭。如果应用程序能兼容所有的屏幕尺寸，layout也能正确缩放，那就不需要用到本属性。不然也应优先考虑使用android:compatibleWidthLimitDp属性。仅当应用程序缩放到大屏幕时会崩溃，屏幕兼容模式是用户使用的唯一方式，才会用到android:largestWidthLimitDp属性。注意：目前屏幕兼容模式只能在手持设备上仿真320dp宽度的屏幕，因此android:largestWidthLimitDp大于320时屏幕兼容模式将不会生效。本属性自API level 13引入。 uses-sdk标签 属性 描述 targetSdkVersion minSdkVersion application 属性 描述 android:uiOptions “none” 默认值”splitActionBarWhenNarrow”，分裂ActionBar用来分开action item，在屏幕底部出现一个actionbar来显示顶部显示不完的items android:backupAgent 云端存储组件声明，该组件一个应用只有一个。其值为BackupAgent的子类 android:allowbackup 是否允许备份 android:allowClearUserData 用户是否能选择自行清除数据，默认为true，程序管理器包含一个选择允许用户清除数据。当为true时，用户可自己清理用户数据，反之亦然 android:testOnly 用于判断该应用是否用于测试 android:largeHeap 可以给程序分配大内存。 getMemoryClass() 或getLargeMemoryClass()查询可用内存 activity 属性 描述 android:launchMode 运行模式 android:configChanges 当配置变化时，activity将会重启，但声明了这个属性会阻止activity重新启动，而调用onConfigurationChanged() android:screenOrientation activity在设别中的显示方向 android:parentActivityName 指定父级的activity。系统根据这个属性来决定当使用actionbar的向上按钮时那个activity响应 android:taskAffinity 表示当前activity进入的task adnroid:finishOnTaskLanuch 离开这个Task栈, 则系统会马上清除这个Activity,不管这个Activity在堆栈的任何位置. android:allowTaskReparenting 允许当前Activity可以在任务栈中移动 android:alwaysRetaainTaskState android:excludeFromRecents android:stateNotNeeded android:exported 是否可以导出，是否可以被外部访问 android:clearTaskOnLaunch 当值为true, 只要你一离开这个Task栈, 则系统会马上清理除了Root Activity的全部Activity. android:windowSoftInputMode android:permission android:alwaysRetainTaskState intent-filtermeta-dataactivity-aliastargetActivity属性所指activity的别名。别名会作为一个独立的实体来代表目标Activity。它能够有自己的Intent过滤器。该标签的其他属性是属性的一个子集，对于子集中的属性，不会把目标Activity中所设置的任何值转交给别名Activity，但对于子集中所没有的属性，则目标Activity所设置的值有会应用到别名Activity。 属性 描述 android:enabled android:exported servicereceiverprovider声明内容存储组件 属性 描述 android:authorities android:enabled 是否可以被实例化。只有当application和provider中的enabled都为true时，provider才可以 android:name uses-library引用类库 属性 描述 android:name 指定类库的名称 android:required 是否一定要找个库，true的时候，如果机器上没有这个库则不能安装","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Android常见问题整理","slug":"Android/Android常见问题整理","date":"2021-05-29T06:50:55.095Z","updated":"2021-06-04T02:36:58.643Z","comments":true,"path":"wiki/Android/Android常见问题整理/","link":"","permalink":"http://shjlone.github.io/wiki/Android/Android%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/","excerpt":"","text":"问题描述12345678!SESSION 2017-08-29 15:27:40.107 ----------------------------------------------- eclipse.buildId=unknown java.version=1.8.0_112-release java.vendor=JetBrains s.r.o BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN Command-line arguments: -os win32 -ws win32 -arch x86_64 -data @noDefault... !ENTRY org.eclipse.osgi 4 0 2017-08-29 15:27:41.441 !MESSAGE Application error !STACK 1 java.lang.NullPointerException at org.eclipse.core.runtime.URIUtil.toURI(URIUtil.java:280) at org.eclipse.e4.ui.internal.workbench.ResourceHandler.loadMostRecentModel(ResourceHandler.java:127)... 解决办法 进程管理器中杀死monitor.exe进程； 删除$HOME/.android/monitor-workspace目录 参考 https://tutel.me/c/programming/questions/26052849/unexpected+error+while+parsing+input+invalid+uiautomator+hierarchy+file 问题描述12345* What went wrong:Execution failed for task &#x27;:app:transformDexArchiveWithExternalLibsDexMergerForDebug&#x27;.&gt; com.android.builder.dexing.DexArchiveMergerException: Error while merging dex archives: Program type already present: org.intellij.lang.annotations.Identifier Learn how to resolve the issue at https://developer.android.com/studio/build/dependencies#duplicate_classes. 解决办法android &#123; configurations &#123; cleanedAnnotations compile.exclude group: &#39;org.jetbrains&#39; , module:&#39;annotations&#39; &#125; &#125; 参考 https://stackoverflow.com/questions/49811851/program-type-already-present-org-intellij-lang-annotations-flow 问题描述1Error:Execution failed for task &#x27;:app:javaPreCompilePreProductDebug&#x27;. &gt; Annotation processors must be explicitly declared now. The following dependencies on the compile classpath are found to contain annotation processor. Please add them to the annotationProcessor configuration. 解决办法android &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; includeCompileClasspath true &#125; &#125; &#125; 参考 问题描述1234567FAILURE: Build failed with an exception.* What went wrong:A problem occurred configuring project &#x27;:myProject&#x27;.&gt; Could not resolve all files for configuration &#x27;:myProject:classpath&#x27;.&gt; Could not find org.jetbrains.trove4j:trove4j:20160824. Searched in the following locations: 解决办法找不到依赖，添加仓库地址。 buildscript &#123; repositories &#123; google() jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; mavenCentral() &#125; dependencies &#123; classpath &#39;com.android.tools.build:gradle:3.3.2&#39; &#125; &#125; allprojects &#123; repositories &#123; google() jcenter() mavenCentral() maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125; &#125; 参考 https://blog.csdn.net/rooney8/article/details/86065188 问题描述1Android-SDK/ndk-bundle/build/core/add-application.mk:178: ### * Android NDK: APP_STL gnustl_shared is no longer supported. Please switch to either c++_static or c++_shared. See https://developer.android.com/ndk/guides/cpp-support.html for more information. . Stop. 解决办法修改项目中Application.mk文件，将其中的APP_STL := gnustl_static改成APP_STL := c++_static 参考 https://stackoverflow.com/questions/52475177/android-ndk-app-stl-gnustl-shared-is-no-longer-supported 问题描述1This Activity already has an action bar supplied by the window decor. Do not request Window.FEATURE_SUPPORT_ACTION_BAR and set windowActionBar to false in your theme to use a Toolbar instead. 解决办法修改主题属性 参考 https://my.oschina.net/ocean870227/blog/738442","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"内存模型","slug":"Java/基础/内存模型","date":"2021-05-28T16:00:00.000Z","updated":"2021-06-07T03:05:44.704Z","comments":true,"path":"wiki/Java/基础/内存模型/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%9F%BA%E7%A1%80/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://shjlone.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"反射","slug":"Java/基础/反射","date":"2021-05-28T16:00:00.000Z","updated":"2021-06-07T01:45:07.545Z","comments":true,"path":"wiki/Java/基础/反射/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://shjlone.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"引用类型","slug":"Java/基础/引用类型","date":"2021-05-28T16:00:00.000Z","updated":"2021-06-07T01:45:07.545Z","comments":true,"path":"wiki/Java/基础/引用类型/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%9F%BA%E7%A1%80/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"概要介绍Java中的几种引用类型： 强引用 弱引用 软引用 参考资料","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://shjlone.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"类加载","slug":"Java/基础/类加载","date":"2021-05-28T16:00:00.000Z","updated":"2021-06-07T01:45:07.545Z","comments":true,"path":"wiki/Java/基础/类加载/","link":"","permalink":"http://shjlone.github.io/wiki/Java/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://shjlone.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://shjlone.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Fragment","slug":"Android/基础/Fragment","date":"2021-05-01T02:01:01.000Z","updated":"2021-06-01T07:07:40.901Z","comments":true,"path":"wiki/Android/基础/Fragment/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Fragment/","excerpt":"","text":"来源Fragment的概念来源于Android3.0，主要目的是为大屏幕（如平板电脑）上更加动态和灵活的界面设计提供支持。他可添加到Activity中，所以多个Activity可添加同一个Fragment，提高了代码复用性。 生命周期 Fragment跟Activity的生命周期类似，不过只有在显示调用addToBackStack()时，系统才会将片段放入由宿主 Activity 管理的返回栈。 生命周期方法onCreate() 系统会在创建片段时调用此方法。当片段经历暂停或停止状态继而恢复后， onCreateView() 系统会在片段首次绘制其界面时调用此方法。如要为片段绘制界面，从此方法中返回的 View 必须是片段布局的根视图。如果片段未提供界面，可以返回 null。 onPause() 系统会将此方法作为用户离开片段的第一个信号（但并不总是意味着此片段会被销毁）进行调用。 onAttach() 在片段已与 Activity 关联时进行调用（Activity 传递到此方法内）。 onCreateView() 调用它可创建与片段关联的视图层次结构。 onActivityCreated() 当 Activity 的 onCreate() 方法已返回时进行调用。 onDestroyView() 在移除与片段关联的视图层次结构时进行调用。 onDetach() 在取消片段与 Activity 的关联时进行调用。 事务为什么Fragment需要事务呢？我的理解是，由于需要对Fragment进行添加、移除、替换等操作，那么FragmentManager的出现是合适的，而FragmentManager内部使用事务的方式来进行管理，就能保证各种操作的原子性了。 基本用法 123456789101112// 1.获取FragmentManager，在活动中可以直接通过调用getFragmentManager()方法得到 fragmentManager = getSupportFragmentManager();// fragmentManager = getFragmentManager(); // 2.开启一个事务，通过调用beginTransaction()方法开启 transaction = fragmentManager.beginTransaction(); // 3.向容器内添加或替换碎片，一般使用replace()方法实现，需要传入容器的id和待添加的碎片实例 transaction.replace(R.id.testFragment, fragment); //fr_container不能为fragment布局，可使用线性布局相对布局等。 // 4.使用addToBackStack()方法，将事务添加到返回栈中，填入的是用于描述返回栈的一个名字 transaction.addToBackStack(null); // 5.提交事物,调用commit()方法来完成 transaction.commit(); 有几个注意点： FragmentActivity和Fragment都有自己的FragmentManager 事务的操作如何通信可通过以下一些方式进行通信： Framgnet中直接获取Activity的引用 Activity中通过FragmentManager获取对应Fragment的引用 通过函数回调 setArguments将参数传递给Fragment 共享ViewModel Fragment Result API 直接获取引用123456//Fragment中获取Activity中的控件View listView = getActivity().findViewById(R.id.list);//Activity中获取某个FragmentExampleFragment fragment = (ExampleFragment) getSupportFragmentManager().findFragmentById(R.id.example_fragment); 这种方式虽然能方便的获取，但从代码设计的角度看是不合适的，耦合性太高了 函数回调1234567891011121314151617181920212223242526272829303132333435363738public static class FragmentA extends ListFragment &#123; ... // Container Activity must implement this interface //定义回调接口 public interface OnArticleSelectedListener &#123; public void onArticleSelected(Uri articleUri); &#125; ...&#125;public static class FragmentA extends ListFragment &#123; OnArticleSelectedListener listener; ... @Override public void onAttach(Context context) &#123; super.onAttach(context); try &#123; //宿主实现该接口，context就是宿主Activity listener = (OnArticleSelectedListener) context; &#125; catch (ClassCastException e) &#123; throw new ClassCastException(context.toString() + &quot; must implement OnArticleSelectedListener&quot;); &#125; &#125; @Override public void onListItemClick(ListView l, View v, int position, long id) &#123; // Append the clicked item&#x27;s row ID with the content provider Uri Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id); // Send the event and Uri to the host activity // 将数据传给Activity，宿主中操作其他Fragment listener.onArticleSelected(noteUri); &#125; ...&#125; 共享ViewModel与宿主Activity通信123456789101112131415161718192021222324252627282930313233343536373839404142public class ItemViewModel extends ViewModel &#123; private final MutableLiveData&lt;Item&gt; selectedItem = new MutableLiveData&lt;Item&gt;(); public void selectItem(Item item) &#123; selectedItem.setValue(item); &#125; public LiveData&lt;Item&gt; getSelectedItem() &#123; return selectedItem; &#125;&#125;public class MainActivity extends AppCompatActivity &#123; private ItemViewModel viewModel; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //注意ViewModelProvider的参数 viewModel = new ViewModelProvider(this).get(ItemViewModel.class); viewModel.getSelectedItem().observe(this, item -&gt; &#123; // Perform an action with the latest item data &#125;); &#125;&#125;public class ListFragment extends Fragment &#123; private ItemViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); //注意requireActivity viewModel = new ViewModelProvider(requireActivity()).get(ItemViewModel.class); ... items.setOnClickListener(item -&gt; &#123; // Set a new item viewModel.select(item); &#125;); &#125;&#125; 将ViewModel放到同一范围，这样返回的是同一个ViewModel。 与其他Fragment通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ListViewModel extends ViewModel &#123; private final MutableLiveData&lt;Set&lt;Filter&gt;&gt; filters = new MutableLiveData&lt;&gt;(); private final LiveData&lt;List&lt;Item&gt;&gt; originalList = ...; private final LiveData&lt;List&lt;Item&gt;&gt; filteredList = ...; public LiveData&lt;List&lt;Item&gt;&gt; getFilteredList() &#123; return filteredList; &#125; public LiveData&lt;Set&lt;Filter&gt;&gt; getFilters() &#123; return filters; &#125; public void addFilter(Filter filter) &#123; ... &#125; public void removeFilter(Filter filter) &#123; ... &#125;&#125;public class ListFragment extends Fragment &#123; private ListViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); //保证在同一个范围 viewModel = new ViewModelProvider(requireActivity()).get(ListViewModel.class); viewModel.getFilteredList().observe(getViewLifecycleOwner(), list -&gt; &#123; // Update the list UI &#125;); &#125;&#125;public class FilterFragment extends Fragment &#123; private ListViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; //保证在同一个范围 viewModel = new ViewModelProvider(requireActivity()).get(ListViewModel.class); viewModel.getFilters().observe(getViewLifecycleOwner(), set -&gt; &#123; // Update the selected filters UI &#125;); &#125; public void onFilterSelected(Filter filter) &#123; viewModel.addFilter(filter); &#125; public void onFilterDeselected(Filter filter) &#123; viewModel.removeFilter(filter); &#125;&#125; 父子Fragment通信12345678910111213141516171819202122public class ListFragment extends Fragment &#123; private ListViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; viewModel = new ViewModelProvider(this).get(ListViewModel.class); viewModel.getFilteredList().observe(getViewLifecycleOwner(), list -&gt; &#123; // Update the list UI &#125; &#125;&#125;public class ChildFragment extends Fragment &#123; private ListViewModel viewModel; @Override public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; //注意参数 viewModel = new ViewModelProvider(requireParentFragment()).get(ListViewModel.class); ... &#125;&#125; Fragment Result API在某些情况下，您可能要在 Fragment 之间或 Fragment 与其宿主 Activity 之间传递一次性值。则可以使用setFragmentResultListener。它的原理是在getParentFragmentManager实现了观察者模式。 与其他Fragment通信 一旦 Fragment A 处于 STARTED 状态，它就会收到结果并执行监听器回调。 对于给定的键，只能有一个监听器和结果。如果您对同一个键多次调用 setFragmentResult()，并且监听器未处于 STARTED 状态，则系统会将所有待处理的结果替换为更新后的结果。如果您设置的结果没有相应的监听器来接收，则结果会存储在 FragmentManager 中，直到您设置一个具有相同键的监听器。监听器收到结果并触发 onFragmentResult() 回调后，结果会被清除。这种行为有两个主要影响： 返回堆栈上的 Fragment 只有在被弹出且处于 STARTED 状态之后才会收到结果。 如果在设置结果时监听结果的 Fragment 处于 STARTED 状态，则会立即触发监听器的回调。 123456789101112131415161718192021222324@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //监听某个事件 getParentFragmentManager().setFragmentResultListener(&quot;requestKey&quot;, this, new FragmentResultListener() &#123; @Override public void onFragmentResult(@NonNull String requestKey, @NonNull Bundle bundle) &#123; // We use a String here, but any type that can be put in a Bundle is supported String result = bundle.getString(&quot;bundleKey&quot;); // Do something with the result &#125; &#125;);&#125;//在Fragment中触发该事件button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Bundle result = new Bundle(); result.putString(&quot;bundleKey&quot;, &quot;result&quot;); getParentFragmentManager().setFragmentResult(&quot;requestKey&quot;, result); &#125;&#125;); 父子Fragment通信 12345678910111213141516171819202122232425@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // We set the listener on the child fragmentManager getChildFragmentManager() .setFragmentResultListener(&quot;requestKey&quot;, this, new FragmentResultListener() &#123; @Override public void onFragmentResult(@NonNull String requestKey, @NonNull Bundle bundle) &#123; String result = bundle.getString(&quot;bundleKey&quot;); // Do something with the result &#125; &#125;);&#125;button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Bundle result = new Bundle(); result.putString(&quot;bundleKey&quot;, &quot;result&quot;); // The child fragment needs to still set the result on its parent fragment manager getParentFragmentManager().setFragmentResult(&quot;requestKey&quot;, result); &#125;&#125;); 与宿主Activity通信123456789101112131415class MainActivity extends AppCompatActivity &#123; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getSupportFragmentManager().setFragmentResultListener(&quot;requestKey&quot;, this, new FragmentResultListener() &#123; @Override public void onFragmentResult(@NonNull String requestKey, @NonNull Bundle bundle) &#123; // We use a String here, but any type that can be put in a Bundle is supported String result = bundle.getString(&quot;bundleKey&quot;); // Do something with the result &#125; &#125;); &#125;&#125; 参考资料 https://developer.android.com/guide/components/fragments?hl=zh-cn https://developer.android.com/guide/fragments?hl=zh-cn","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"Intent","slug":"Android/基础/Intent","date":"2021-05-01T02:01:01.000Z","updated":"2021-06-04T10:36:05.587Z","comments":true,"path":"wiki/Android/基础/Intent/","link":"","permalink":"http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Intent/","excerpt":"","text":"介绍Intent是一个消息传递对象，他的作用： 启动Activity。不同的业务场景启动Activity又分为显示调用和隐式调用。 启动Service 传递广播 参考 Intent和Intent过滤器","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/categories/Android/"},{"name":"基础","slug":"Android/基础","permalink":"http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://shjlone.github.io/tags/Android/"}]},{"title":"设计原则","slug":"设计模式/设计原则","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-08T07:54:59.458Z","comments":true,"path":"wiki/设计模式/设计原则/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","excerpt":"","text":"单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】：一个类负责一项职责。 里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】：继承与派生的规则。 依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。 接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。 迪米特法则【LOW OF DEMETER】：低耦合，高内聚。 开闭原则【OPEN CLOSE PRINCIPLE】：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】：尽量使用组合和聚合少使用继承的关系来达到复用的原则。 参考","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"原型模式","slug":"设计模式/创建型模式/原型模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.568Z","comments":true,"path":"wiki/设计模式/创建型模式/原型模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"工厂模式","slug":"设计模式/创建型模式/工厂模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.569Z","comments":true,"path":"wiki/设计模式/创建型模式/工厂模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"建造者模式","slug":"设计模式/创建型模式/建造者模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.569Z","comments":true,"path":"wiki/设计模式/创建型模式/建造者模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"抽象工厂模式","slug":"设计模式/创建型模式/抽象工厂模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.569Z","comments":true,"path":"wiki/设计模式/创建型模式/抽象工厂模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"享元模式","slug":"设计模式/结构型模式/享元模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.568Z","comments":true,"path":"wiki/设计模式/结构型模式/享元模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"代理模式","slug":"设计模式/结构型模式/代理模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.568Z","comments":true,"path":"wiki/设计模式/结构型模式/代理模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"外观模式","slug":"设计模式/结构型模式/外观模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.568Z","comments":true,"path":"wiki/设计模式/结构型模式/外观模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"桥接模式","slug":"设计模式/结构型模式/桥接模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.569Z","comments":true,"path":"wiki/设计模式/结构型模式/桥接模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"组合模式","slug":"设计模式/结构型模式/组合模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.569Z","comments":true,"path":"wiki/设计模式/结构型模式/组合模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"装饰模式","slug":"设计模式/结构型模式/装饰模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.569Z","comments":true,"path":"wiki/设计模式/结构型模式/装饰模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"适配器模式","slug":"设计模式/结构型模式/适配器模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-08T01:47:24.371Z","comments":true,"path":"wiki/设计模式/结构型模式/适配器模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义适配器模式（Adapter Pattern）：将一个类的接口转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以相互合作。适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。 适配器模式优点 复用且不修改类 : 不改变现有类的基础上 , 提高类的复用性 , 透明性 ; 让现有类与目标类接口匹配 ; 降低耦合 : 目标类 ( 用户调用的接口所在类 ) 和 现有类 ( 被适配者 ) 解除耦合 , 降低了系统的耦合性 , 易于扩展维护; 符合开闭原则 : 用户调用适配器接口 , 只与适配器类进行交互 , 如果需要修改扩展 , 只需要修改适配器类即可 , 目标类和现有类各自都是相互独立的 , 互不影响 ; 适配器模式缺点 增加复杂性 : 编写适配器类时 , 需要考虑全面 , 包括被适配者 和 目标类 , 系统复杂性会增加; 降低可读性 : 系统代码可读性降低 , 可维护性降低 ; 对象适配器在对象适配器模式中，适配器与适配者之间是关联关系（适配者是适配器的成员变量）。 结构图 Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。 Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承(或者实现)Target并关联一个Adaptee对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.shjlone.designpattern.adapter.objectadapter;/** * 对象适配器模式 */public class ObjectAdapterTest &#123; public static void main(String[] args) &#123; TypeC typeC = new Phone(); MicroUsb microUsb = new Adapter(typeC); microUsb.microUsb(); &#125;&#125;// 供应接口interface MicroUsb &#123; public void microUsb();&#125;// 需求接口interface TypeC &#123; public void typeC();&#125;// 需求实现类class Phone implements TypeC &#123; public void typeC() &#123; System.out.println(&quot;Type-C接口&quot;); &#125;&#125;// 适配器class Adapter implements MicroUsb &#123; private TypeC typeC; public Adapter(TypeC typeC) &#123; this.typeC = typeC; &#125; @Override public void microUsb() &#123; typeC.typeC(); &#125;&#125; 类适配器在类适配器模式中，适配器与适配者之间是继承关系。 123456789101112131415161718192021222324252627282930313233343536package com.shjlone.designpattern.adapter.classadapter;/** * 类适配器 */public class ClassAdapterTest &#123; public static void main(String[] args) &#123; MicroUsb microUsb = new Adapter(); microUsb.microUsb(); &#125;&#125;//供应接口interface MicroUsb &#123; public void microUsb();&#125;//需求接口interface TypeC &#123; public void typeC();&#125;//需求实现类class Phone implements TypeC &#123; public void typeC() &#123; System.out.println(&quot;Type-C接口&quot;); &#125;&#125;//适配器class Adapter extends Phone implements MicroUsb &#123; public void microUsb() &#123; typeC(); &#125;&#125; 缺省适配器模式(Default Adapter Pattern)当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.shjlone.designpattern.adapter.defaultadapter;/** * 默认适配器，用于隐藏一些实现细节 */public class DefaultAdapterTest &#123; public static void main(String[] args) &#123; TypecToVGA typecToVGA = new TypecToVGA(); typecToVGA.isTypeC(); typecToVGA.isVGA(); &#125;&#125;// 接口类interface AllPorts &#123; public void isTypeC(); public void isVGA(); public void isHdmi();&#125;// 适配器的框架abstract class Adapter implements AllPorts &#123; @Override public void isTypeC() &#123; &#125; @Override public void isVGA() &#123; &#125; @Override public void isHdmi() &#123; &#125;&#125;// 适配器类class TypecToVGA extends Adapter &#123; @Override public void isTypeC() &#123; System.out.println(&quot;信号从TypeC接口进入&quot;); &#125; @Override public void isVGA() &#123; System.out.println(&quot;信号从VGA接口出&quot;); &#125;&#125; 使用场景 Java连接数据的JDBC工具 List Arrays.asList(T[]) InputStreamReader StringReader 123456789101112131415161718192021222324252627282930313233/*** 对象适配器* StringReader相当于Adapter，Reader相当于Target，String相当于Adaptee***/public class StringReader extends Reader &#123; // 维持对adaptee对象的引用 private String str; private int length; private int next = 0; private int mark = 0; /** * 构造注入一个String用于之后的read操作 */ public StringReader(String s) &#123; this.str = s; this.length = s.length(); &#125; // 这里相当于是在做适配操作，转为目标对象所期望的请求 public int read() throws IOException &#123; synchronized (lock) &#123; ensureOpen(); if (next &gt;= length) return -1; return str.charAt(next++); &#125; &#125;&#125; 参考资料 https://www.liaoxuefeng.com/wiki/1252599548343744/1281319245971489 https://www.cnblogs.com/bytesfly/p/adapter-pattern.html","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"中介者模式","slug":"设计模式/行为型模式/中介者模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.568Z","comments":true,"path":"wiki/设计模式/行为型模式/中介者模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"命令模式","slug":"设计模式/行为型模式/命令模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.568Z","comments":true,"path":"wiki/设计模式/行为型模式/命令模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"备忘录模式","slug":"设计模式/行为型模式/备忘录模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.568Z","comments":true,"path":"wiki/设计模式/行为型模式/备忘录模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"模板方法模式","slug":"设计模式/行为型模式/模板方法模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.569Z","comments":true,"path":"wiki/设计模式/行为型模式/模板方法模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"状态模式","slug":"设计模式/行为型模式/状态模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.569Z","comments":true,"path":"wiki/设计模式/行为型模式/状态模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"策略模式","slug":"设计模式/行为型模式/策略模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.569Z","comments":true,"path":"wiki/设计模式/行为型模式/策略模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"观察者模式","slug":"设计模式/行为型模式/观察者模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-01T01:45:18.731Z","comments":true,"path":"wiki/设计模式/行为型模式/观察者模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"解释器模式","slug":"设计模式/行为型模式/解释器模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.569Z","comments":true,"path":"wiki/设计模式/行为型模式/解释器模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"访问者模式","slug":"设计模式/行为型模式/访问者模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.570Z","comments":true,"path":"wiki/设计模式/行为型模式/访问者模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"迭代器模式","slug":"设计模式/行为型模式/迭代器模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.570Z","comments":true,"path":"wiki/设计模式/行为型模式/迭代器模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"责任链模式","slug":"设计模式/行为型模式/责任链模式","date":"2018-06-01T02:01:01.000Z","updated":"2021-06-07T01:45:07.570Z","comments":true,"path":"wiki/设计模式/行为型模式/责任链模式/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料","raw":null,"content":null,"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"《干就对了：业绩增长九大关键》读书笔记","slug":"读书笔记/干就对了","date":"2017-03-11T16:00:00.000Z","updated":"2021-05-29T08:44:05.169Z","comments":true,"path":"wiki/读书笔记/干就对了/","link":"","permalink":"http://shjlone.github.io/wiki/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%B9%B2%E5%B0%B1%E5%AF%B9%E4%BA%86/","excerpt":"","text":"摘要1 宁愿要三流的战略加上一流的组织，也不要一流的战略、三流的组织。 感悟： 好的团队很重要，一群优秀的人，目的明确，团结一致，想不成功都难。在团队建设过程中，一定要尽量留下优秀的人才。 摘要2组织架构的设计原则： 1.自上而下和自下而上要结合。 2.组织架构设计要保持弹性，也就是要跳出KPI做正确的事。 摘要3中台建设原则： 客户第一 赋能而非管控 前线要有授权 总部要有看板 善用双线汇报 摘要4岗位职责的设计注意点： 切忌“大而全” 要有颗力度和明确的比重 人事部门不能包揽岗位职责编写工作 岗位职责不能一成不变 岗位职责再纵深层次上不能一样 感悟： 每个岗位都应该有明确的职责要求，实际工作当中，很多人会把模棱两可的任务推来推去。 摘要5如何扣动员工的心灵扳机： 寻找心动点 寻找成就点 生理需求和安全需求 情感和归属需求 尊重需求 自我实现需求 管理者不要站在自己的角度思考员工的原动力 管理者要看到目标实现的可能性，不能画大饼 感悟： 说到底还是要关注”人”本身，关注他的真实需求，尽量在现有框架下满足他的需求，他才能给团队带来更多的价值。 摘要6 “No Surprise”：管理者在日常过程中发现问题没有及时提醒 当员工犯错的时候，不要急于批评，因为大多数批评解决不了问题。正确的步骤是判断这些错误会产生什么影响，然后再做处理。一般从两个维度判断——业绩和价值观。 感悟： 自己在实际工作中就出现过类似的问题，在问题刚刚出现时没有及时去处理，最终那个团队成员离职了。回过头想，其实在问题刚出现的时候，就处理的话，他应该在近期是不会离职的。 摘要6设计KPI时要关注的6个要素： 目标值； 权重； 计算方式； 评分标准； 评估周期。 摘要7 裸心会，真正的关心员工，而不是流于形式。 感悟： 阿里所谓但裸心会，说到底还是要真正但关心团队成员的内心真实想法，流于表面的生日会、聚餐，并不能跟大家交心。想要交心，是要真正的去了解对方，把对方当成好哥们，哥们家人生病了，你是要关怀的。","raw":null,"content":null,"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://shjlone.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Welcome Shjlone's Blog","slug":"index","date":"2017-01-21T17:55:57.000Z","updated":"2021-05-29T06:50:55.106Z","comments":true,"path":"wiki/index/","link":"","permalink":"http://shjlone.github.io/wiki/index/","excerpt":"","text":"这是我的个人博客，用于记录自己的点点滴滴！","raw":null,"content":null,"categories":[],"tags":[]}]}