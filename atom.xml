<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shjlone&#39;s Blog</title>
  
  <subtitle>Hello World</subtitle>
  <link href="http://shjlone.github.io/atom.xml" rel="self"/>
  
  <link href="http://shjlone.github.io/"/>
  <updated>2021-06-10T12:37:29.485Z</updated>
  <id>http://shjlone.github.io/</id>
  
  <author>
    <name>shjlone</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动画造成的OOM的处理方式</title>
    <link href="http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E5%8A%A8%E7%94%BB%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E5%8A%A8%E7%94%BB%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</id>
    <published>2021-06-10T12:37:02.537Z</published>
    <updated>2021-06-10T12:37:29.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="OOM专题" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Bitmap造成的OOM的处理方式</title>
    <link href="http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/Bitmap%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/Bitmap%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</id>
    <published>2021-06-10T09:23:17.551Z</published>
    <updated>2021-06-10T09:23:31.943Z</updated>
    
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="OOM专题" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>非静态内部类造成的OOM的处理方式</title>
    <link href="http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</id>
    <published>2021-06-10T09:07:24.489Z</published>
    <updated>2021-06-10T10:03:07.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>我们日常写代码中，很容易写一些以下样子的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMInnerClassActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_oom_inner_class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        EditText editText = findViewById(R.id.oom_edittext);</span><br><span class="line">        TextView textView = findViewById(R.id.oom_textview);</span><br><span class="line">        editText.addTextChangedListener(<span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">                textView.setText(s.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，TextWatcher的匿名内部类是会持有Activity的引用的。如果它没有跟着Activity的生命周期一起销毁，则会引发内存泄漏。</p><p>为什么匿名内部类会持有外部引用而静态内部类不会呢？静态内部类它是静态的呀，只能访问外部的静态变量，无需持有外部对象的引用。</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>其实这种现象跟Handler的处理方式是类似的，监听器持有弱引用，且生命周期结束时同步销毁。可参考以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OOMInnerClassRightActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TextView textView;</span><br><span class="line">    EditText editText;</span><br><span class="line">    WeakTextWatcher weakTextWatcher;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_oom_inner_class);</span><br><span class="line"></span><br><span class="line">        editText = findViewById(R.id.oom_edittext);</span><br><span class="line">        textView = findViewById(R.id.oom_edittext);</span><br><span class="line"></span><br><span class="line">        weakTextWatcher = <span class="keyword">new</span> WeakTextWatcher(<span class="keyword">this</span>);</span><br><span class="line">        editText.addTextChangedListener(weakTextWatcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakTextWatcher</span> <span class="keyword">implements</span> <span class="title">TextWatcher</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用弱引用</span></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;OOMInnerClassRightActivity&gt; activityWeakReference;</span><br><span class="line"></span><br><span class="line">        WeakTextWatcher(OOMInnerClassRightActivity activity) &#123;</span><br><span class="line">            activityWeakReference = <span class="keyword">new</span> WeakReference&lt;OOMInnerClassRightActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            OOMInnerClassRightActivity activity = activityWeakReference.get();</span><br><span class="line">            <span class="keyword">if</span>(activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.textView.setText(s.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">//释放监听</span></span><br><span class="line">        editText.removeTextChangedListener(weakTextWatcher);</span><br><span class="line">        weakTextWatcher = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以参考<a href="/wiki/Android/%E5%9F%BA%E7%A1%80/Handler%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">Handler基本用法</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://cashow.github.io/Android-Anonymous-Inner-Class-Leaks-Memory.html">Android - 匿名内部类导致内存泄露的处理办法</a></li><li><a href="https://cloud.tencent.com/developer/article/1179625">匿名内部类导致内存泄露的面试题</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h2&gt;&lt;p&gt;我们日常写代码中，很容易写一些以下样子的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="OOM专题" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>LeakCanary</title>
    <link href="http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/LeakCanary/"/>
    <id>http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/LeakCanary/</id>
    <published>2021-06-10T08:50:27.638Z</published>
    <updated>2021-06-10T08:50:41.506Z</updated>
    
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="开源库" scheme="http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Glide</title>
    <link href="http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Glide/"/>
    <id>http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Glide/</id>
    <published>2021-06-10T07:22:52.311Z</published>
    <updated>2021-06-10T07:23:02.720Z</updated>
    
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="开源库" scheme="http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RxJava</title>
    <link href="http://shjlone.github.io/wiki/Java/%E5%BC%80%E6%BA%90%E5%BA%93/RxJava/"/>
    <id>http://shjlone.github.io/wiki/Java/%E5%BC%80%E6%BA%90%E5%BA%93/RxJava/</id>
    <published>2021-06-07T10:16:51.809Z</published>
    <updated>2021-06-07T10:17:02.873Z</updated>
    
    
    
    
    <category term="Java" scheme="http://shjlone.github.io/categories/Java/"/>
    
    <category term="开源库" scheme="http://shjlone.github.io/categories/Java/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="Java" scheme="http://shjlone.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Handler基本用法</title>
    <link href="http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Handler%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Handler%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</id>
    <published>2021-06-07T06:13:25.099Z</published>
    <updated>2021-06-08T02:45:08.475Z</updated>
    
    <content type="html"><![CDATA[<p>Hanlder系列目录：</p><ul><li><a href="./Handler%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html">Handler基本用法</a></li><li><a href="./Handler%E5%8E%9F%E7%90%86.html">Handler原理</a></li></ul><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance<br>is associated with a single thread and that thread’s message queue. When you create a new Handler it is bound to a Looper.<br>It will deliver messages and runnables to that Looper’s message queue and execute them on that Looper’s thread.</p><p>There are two main uses for a Handler: (1) to schedule messages and runnables to be executed at some point in the future;<br>and (2) to enqueue an action to be performed on a different thread than your own.</p><p>Scheduling messages is accomplished with the post(Runnable), postAtTime(java.lang.Runnable, long),<br>postDelayed(Runnable, Object, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long), and<br>sendMessageDelayed(Message, long) methods. The post versions allow you to enqueue Runnable objects to be called by the<br>message queue when they are received; the sendMessage versions allow you to enqueue a Message object containing a bundle<br>of data that will be processed by the Handler’s handleMessage(Message) method (requiring that you implement a subclass of Handler).</p><p>When posting or sending to a Handler, you can either allow the item to be processed as soon as the message queue is ready<br>to do so, or specify a delay before it gets processed or absolute time for it to be processed. The latter two allow you<br>to implement timeouts, ticks, and other timing-based behavior.</p><p>When a process is created for your application, its main thread is dedicated to running a message queue that takes care<br>of managing the top-level application objects (activities, broadcast receivers, etc) and any windows they create. You<br>can create your own threads, and communicate back with the main application thread through a Handler. This is done by<br>calling the same post or sendMessage methods as before, but from your new thread. The given Runnable or Message will then<br>be scheduled in the Handler’s message queue and processed when appropriate.</p><p>Handler用于Android中的线程通信。主要的用于在异步线程中发送<code>Message</code>或者直接运行一个<code>Runnable</code>，即可回到主线程执行UI操作。Handler在哪个线程<br>初始化，则它依附在哪个线程。Activity中有一个runOnUiThread方法，封装了Handler可以直接在异步线程中使用。Handler也可以延迟执行。</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lqd.androidpractice.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lqd.androidpractice.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * handler 使用实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在异步线程发送消息到主线程刷新UI</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: a564</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TAG = <span class="string">&quot;HandlerActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyHandler myHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.activity_handler);</span><br><span class="line"></span><br><span class="line">        textView = findViewById(R.id.ah_textview);</span><br><span class="line">        findViewById(R.id.ah_btn1).setOnClickListener(v -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.run();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Log.d(TAG, Thread.currentThread().getStackTrace()[<span class="number">2</span>].getMethodName());</span><br><span class="line"></span><br><span class="line">                    Message msg = Message.obtain();</span><br><span class="line">                    msg.what = <span class="number">1</span>; <span class="comment">// 消息标识</span></span><br><span class="line">                    msg.obj = <span class="string">&quot;A&quot;</span>; <span class="comment">// 消息内存存放</span></span><br><span class="line">                    myHandler.sendMessage(msg); <span class="comment">// 异步线程发送消息</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//使用post</span></span><br><span class="line">                    myHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="comment">//回到UI线程</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        myHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        myHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);<span class="comment">//跟随Activity销毁</span></span><br><span class="line">        myHandler = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="comment">//弱引用</span></span><br><span class="line">        WeakReference&lt;HandlerActivity&gt; activityWeakReference;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(HandlerActivity activity)</span> </span>&#123;</span><br><span class="line">            activityWeakReference = <span class="keyword">new</span> WeakReference&lt;HandlerActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> <span class="meta">@NotNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, Thread.currentThread().getStackTrace()[<span class="number">2</span>].getMethodName());</span><br><span class="line">            Log.d(TAG, msg.toString());</span><br><span class="line">            HandlerActivity activity = activityWeakReference.get();</span><br><span class="line">            <span class="keyword">if</span> (activity == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    activity.textView.setText(<span class="string">&quot;执行了线程1的UI操作&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    activity.textView.setText(<span class="string">&quot;执行了线程2的UI操作&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>顾名思义，HandlerThread使得Thread拥有的Handler的特性，可以在此线程中进行消息的分发和处理。使用场景也是创建异步线程并有数据交互。我们也可以<br>将其封装成一个工具类，这样不需要每次都new一个线程出来，方便使用且节省性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackgroundHandlerThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> BackgroundHandlerThread _instance = <span class="keyword">new</span> BackgroundHandlerThread();</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            _instance.init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BackgroundHandlerThread <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder._instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HandlerThread mHandlerThread;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//HandlerThread的第二个参数为线程优先级</span></span><br><span class="line">        mHandlerThread = <span class="keyword">new</span> HandlerThread(BackgroundHandlerThread.class.getSimpleName());</span><br><span class="line">        mHandlerThread.start();</span><br><span class="line"></span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler(mHandlerThread.getLooper())&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mHandlerThread.getLooper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当需要异步执行的地方可以直接使用下面的代码</span></span><br><span class="line">BackgroundHandlerThread.getInstance().getHandler().post(Runnable)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><p><code>sendMessage(Message message)</code></p><p>发送消息到消息队列</p><p><code>post(Runnable runable)</code></p><p>把一个Runnable对象添加到消息队列中，这个方法会在对应Looper的线程中运行。</p><p>dispatchMessage(Message msg)</p><p>将消息分发给对应的Handler</p><p><code>handleMessage</code></p><p>根据某个消息类型进行处理</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.android.com/reference/android/os/Handler">https://developer.android.com/reference/android/os/Handler</a></li><li><a href="https://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/">详解 Android 中的 HandlerThread</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hanlder系列目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;./Handler%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html&quot;&gt;Handler基本用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;./Handler%E5%8E%</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="基础" scheme="http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor</title>
    <link href="http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor/"/>
    <id>http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor/</id>
    <published>2021-06-07T03:47:22.391Z</published>
    <updated>2021-06-07T03:47:38.454Z</updated>
    
    
    
    
    <category term="Java" scheme="http://shjlone.github.io/categories/Java/"/>
    
    <category term="并发编程" scheme="http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="http://shjlone.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/"/>
    <id>http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/</id>
    <published>2021-06-07T01:45:07.568Z</published>
    <updated>2021-06-07T01:45:07.568Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>顺序查找（Sequential Search）又称线性查找。从表中第一个(或最后一个)记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，如果查找到表中最后一个元素，还没有找到，则查找不成功。</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找（Binary Search）又称折半查找。它的前提是线性表中的记录必须是关键码有序，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</p><h3 id="插值查找-Interpolation-Search"><a href="#插值查找-Interpolation-Search" class="headerlink" title="插值查找(Interpolation Search)"></a>插值查找(Interpolation Search)</h3><p>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。即根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式mid=low+(key-a[low])/(a[high]-a[low])(high-low)，替换了二分查找的计算公式mid=low+1/2(high-low)。</p><p>这样的好处在于，对表长较长，且关键字分布比较均匀，插值查找算法的平均性能要比折半查找要好的多。但是如果表中关键字分布极端不均匀，那么插值查找还不如折半查找呢。</p><h3 id="斐波那契查找-Fibonacci-Search"><a href="#斐波那契查找-Fibonacci-Search" class="headerlink" title="斐波那契查找(Fibonacci Search)"></a>斐波那契查找(Fibonacci Search)</h3><p>也是一种改进的二分查找，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。</p><p><strong>斐波那契查找的整个过程可以分为：</strong></p><ul><li>构建斐波那契数列；</li><li>计算数组长度对应的斐波那契数列元素个数；</li><li>对数组进行填充；</li><li>循环进行区间分割，查找中间值；</li><li>判断中间值和目标值的关系，确定更新策略；</li></ul><h3 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h3><p>对二叉查找树进行中序遍历，即可得到有序的数列。</p><h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><h4 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h4><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h3 id="B树-B-树-、B-树"><a href="#B树-B-树-、B-树" class="headerlink" title="B树(B_树)、B+树"></a>B树(B_树)、B+树</h3><p>B树也称B-树,它是一颗多路平衡查找树</p><h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。<br>　　算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……<br>　　算法流程：<br>　　step1 先选取各块中的最大关键字构成一个索引表；<br>　　step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</p><h3 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h3><p>我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。<br>　　总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。</p><p>　　什么是哈希函数？</p><p>　　哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。</p><p>　　算法思想：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p><p>　　算法流程：<br>　　1）用给定的哈希函数构造哈希表；<br>　　2）根据选择的冲突处理方法解决地址冲突；<br>　　　　常见的解决冲突的方法：拉链法和线性探测法。详细的介绍可以参见：浅谈算法和数据结构: 十一 哈希表。<br>　　3）在哈希表的基础上执行哈希查找。<br>　　哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</p><p>　　复杂度分析：</p><p>　　单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</p><p>　　使用Hash，我们付出了什么？<br>　　我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV pair，经常使用Python的博友可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？</p><p>　　Hash是一种典型以空间换时间的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。</p><br/><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">算法可视化演示</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;顺序查找&quot;&gt;&lt;a href=&quot;#顺序查找&quot; class=&quot;headerlink&quot; title=&quot;顺序查找&quot;&gt;&lt;/a&gt;顺序查找&lt;/h3&gt;&lt;p&gt;顺序查找（Sequential Search）又称线性查找。从表中第一个(或最后一个)记录开始，逐个进行记录的关键字和给定值</summary>
      
    
    
    
    <category term="算法" scheme="http://shjlone.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    <id>http://shjlone.github.io/wiki/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-07T01:45:07.567Z</published>
    <updated>2021-06-07T01:45:07.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><strong>具体算法：</strong></p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2-5。</li></ol><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。</p><p>希尔排序实质上是一种分组直接插入方法。</p><p><strong>基本思想：</strong></p><p>对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；<br>然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。<br>然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，即所有记录放在同一组中进行直接插入排序为止, 整个数列就是有序的。</p><br/><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h3 id="堆选择排序"><a href="#堆选择排序" class="headerlink" title="堆选择排序"></a>堆选择排序</h3><h4 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h4><p>堆结构有很多种，如二叉堆、B堆、斐波那契堆、三元堆，树堆、弱堆等。<br>二叉堆是堆实现中最流行的一种。二叉堆是一个完全二叉树，树的所有内部节点都被完全填充，最后一层可以完全填充的或部分填充。通俗的说，堆（二叉堆）可以视为一棵完全的二叉树。完全二叉树的一个优秀的性质就是，除了最底层之外，每一层都是满的。堆又分为最大堆（堆顶Root是最大值）和最小堆（堆顶Root是最小值）。 </p><p>总结一下，只要你是一个完全二叉树，父节点又大于子节点，你就是堆。</p><blockquote><p>完全二叉树 + 父节点大于(或小于)子节点 = 堆</p></blockquote><p><a href="https://chihokyo.com/post/18/">https://chihokyo.com/post/18/</a></p><br/><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html">https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html</a></li></ul><br/><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序算法完全遵循分治模式。直观上其操作如下：</p><p>分解：分解等排序的n个元素的序列成各具n/2个元素的两个子序列；<br>解决：使用归并排序递归地排序两个子序列；<br>合并：合并两个已排序的子序列以产生已排序的答案。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cc/Merge-sort-example-300px.gif/220px-Merge-sort-example-300px.gif"></p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F#Python3">https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F#Python3</a></li></ul><br/><h2 id="各种内排序方法的比较"><a href="#各种内排序方法的比较" class="headerlink" title="各种内排序方法的比较"></a>各种内排序方法的比较</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;h3 id=&quot;直接插入排序&quot;&gt;&lt;a href=&quot;#直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;直接插入排</summary>
      
    
    
    
    <category term="算法" scheme="http://shjlone.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP中opcodes的原理</title>
    <link href="http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/PHP%E4%B8%ADopcodes%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/PHP%E4%B8%ADopcodes%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-07T01:45:07.567Z</published>
    <updated>2021-06-07T01:45:07.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHP代码的生命周期"><a href="#PHP代码的生命周期" class="headerlink" title="PHP代码的生命周期"></a>PHP代码的生命周期</h2><p><strong>不启用OPcache的流程</strong></p><p><img src="./php_1.png"></p><p><strong>启用OPcache的流程</strong></p><p><img src="./php_2.png"></p><ol><li>Scanning：将PHP代码转换为语言片段（Tokens）</li><li>Parsingg：将Tokens转换成简单而有意义的表达式</li><li>Compilation：将表达式编译成opcodes</li><li>Execution:执行opcodes，每次一条，从而实现PHP脚本的功能</li></ol><h2 id="opcodes"><a href="#opcodes" class="headerlink" title="opcodes"></a>opcodes</h2><p>当一个 PHP 文件被解释执行的时候，首先是被编译成名为 opcode （CPU专用的机器语言指令）的中间代码，然后才被底层的虚拟机执行。 如果PHP文件没有被修改过，opcode 始终是一样的。这就意味着编译步骤白白浪费了 CPU 的资源。<br>此时 opcode 缓存就派上用场了。通过将 opcode 缓存在内存中，它能防止冗余的编译步骤，并且在下次调用执行时得到重用。一般执行过程是先检查文件的签名（signature）或者修改时间，以防文件有改动。</p><p>PHP 5.5 以后的所有版本都内置了一个 opcode 缓存工具，叫做 Zend OPcache。 根据你所使用的 PHP 安装包/发行版的不同，一般情况下是默认开启的，请查看 OPcache.enable phpinfo() 和 phpinfo() 输出的信息确认是否已经开启。</p><p>Operate Code：当解释器完成对脚本代码的分析后，便将它们生成可以直接运行的中间代码，也称为操作码。</p><h2 id="OPcache"><a href="#OPcache" class="headerlink" title="OPcache"></a>OPcache</h2><p>opcode cache的目地是避免重复编译，减少CPU和内存开销。</p><h3 id="PHP配置"><a href="#PHP配置" class="headerlink" title="PHP配置"></a>PHP配置</h3><p>PHP5.5以上默认有OPcache，如果需要安装，则使用以下脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://pecl.php.net/get/zendOPcache-7.0.3.tgz</span><br><span class="line">tar zxvf zendOPcache-7.0.3.tgz &amp;&amp; cd zendOPcache-7.0.3</span><br><span class="line">/usr/local/php/bin/phpize</span><br><span class="line">./configure --with-php-config=/usr/local/php/bin/php-config</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>php.ini配置说明</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Zend Opcache]</span></span><br><span class="line"><span class="attr">zend_extension</span> = OPcache.so</span><br><span class="line"><span class="comment">#比较常用的配置</span></span><br><span class="line"><span class="attr">OPcache.enable</span>=<span class="number">1</span>                    <span class="comment">#是否启用操作码缓存</span></span><br><span class="line"><span class="attr">OPcache.enable_cli</span>=<span class="number">1</span>                <span class="comment">#仅针对CLI环境启用操作码缓存</span></span><br><span class="line"><span class="attr">OPcache.revalidate_freq</span>=<span class="number">60</span>          <span class="comment">#检查文件的修改的时间周期, 定位为秒，即缓存后60秒去检查代码文件是否被修改过</span></span><br><span class="line"><span class="attr">OPcache.fast_shutdown</span>=<span class="number">1</span>             <span class="comment">#打开快速关闭, 一次释放全部请求变量的内存，打开这个在PHP Request Shutdown的时候回收内存的速度会提高</span></span><br><span class="line"><span class="comment">;OPcache.error_log=&quot;&quot;               #OPcache模块的错误日志文件</span></span><br><span class="line"><span class="comment">;OPcache.log_verbosity_level=1      #将错误信息写入到服务器的日志级别。致命（0）错误（1) 警告（2）信息（3）调试（4）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#其它不常用的配置</span></span><br><span class="line"><span class="attr">OPcache.memory_consumption</span>=<span class="number">128</span>      <span class="comment">#共享内存大小，单位MB</span></span><br><span class="line"><span class="attr">OPcache.interned_strings_buffer</span>=<span class="number">8</span>   <span class="comment">#存储临时字符串的内存大小，单位MB</span></span><br><span class="line"><span class="attr">OPcache.max_accelerated_files</span>=<span class="number">4000</span>  <span class="comment">#哈希表中可存储的脚本文件数量上限</span></span><br><span class="line"><span class="comment">;OPcache.max_wasted_percentage=5    #浪费内存的上限，以百分比计</span></span><br><span class="line"><span class="comment">;OPcache.use_cwd=1                  #附加改脚本的工作目录,避免同名脚本冲突</span></span><br><span class="line"><span class="attr">OPcache.validate_timestamps</span>=<span class="number">1</span>       <span class="comment">#每隔revalidate_freq 设定的秒数 检查脚本是否更新</span></span><br><span class="line"><span class="comment">;OPcache.revalidate_path=0          #如果禁用此选项，在同一个 include_path 已存在的缓存文件会被重用</span></span><br><span class="line"><span class="comment">;OPcache.save_comments=1            #禁用后将也不会加载注释内容</span></span><br><span class="line"><span class="attr">OPcache.enable_file_override</span>=<span class="number">0</span>      <span class="comment">#如果启用，则在调用函数file_exists()， is_file() 以及 is_readable() 的时候， 都会检查操作码缓存</span></span><br><span class="line"><span class="comment">;OPcache.optimization_level=0xffffffff  #控制优化级别的二进制位掩码。</span></span><br><span class="line"><span class="comment">;OPcache.inherited_hack=1           #PHP 5.3之前做的优化</span></span><br><span class="line"><span class="comment">;OPcache.dups_fix=0                 #仅作为针对 “不可重定义类”错误的一种解决方案。</span></span><br><span class="line"><span class="comment">;OPcache.blacklist_filename=&quot;&quot;      #黑名单文件为文本文件，包含了不进行预编译优化的文件名</span></span><br><span class="line"><span class="comment">;OPcache.max_file_size=0            #以字节为单位的缓存的文件大小上限</span></span><br><span class="line"><span class="comment">;OPcache.consistency_checks=0       #如果是非 0 值，OPcache 将会每隔 N 次请求检查缓存校验和</span></span><br><span class="line"><span class="attr">OPcache.force_restart_timeout</span>=<span class="number">180</span>   <span class="comment">#如果缓存处于非激活状态，等待多少秒之后计划重启。</span></span><br><span class="line"><span class="comment">;OPcache.preferred_memory_model=&quot;&quot;  #OPcache 首选的内存模块。可选值包括： mmap，shm, posix 以及 win32。</span></span><br><span class="line"><span class="comment">;OPcache.protect_memory=0           #保护共享内存，以避免执行脚本时发生非预期的写入。 仅用于内部调试。</span></span><br><span class="line"><span class="comment">;OPcache.mmap_base=null             #在Windows 平台上共享内存段的基地址</span></span><br></pre></td></tr></table></figure><h3 id="监测OPcache"><a href="#监测OPcache" class="headerlink" title="监测OPcache"></a>监测OPcache</h3><ul><li><strong>可视化显示</strong>：<a href="https://github.com/PeeHaa/OpCacheGUI">https://github.com/PeeHaa/OpCacheGUI</a></li><li>**简易的显示缓存信息(PHP7+)**：<a href="https://github.com/rlerdorf/opcache-status">https://github.com/rlerdorf/opcache-status</a></li></ul><h3 id="相关PHP的API使用"><a href="#相关PHP的API使用" class="headerlink" title="相关PHP的API使用"></a>相关PHP的API使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opcache_is_script_cached(string $filename):bool    是否缓存</span><br><span class="line">opcache_get_configuration(): array 获取缓存的配置信息</span><br><span class="line">opcache_invalidate(string $script , boolean $force = false):boolean 废除脚本缓存</span><br><span class="line">opcache_reset():boolean   重置字节码缓存的内容</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="">Understanding OPCode</a></li><li><a href="https://www.php.net/manual/zh/OPcache.configuration.php">OPcache运行时配置</a></li><li><a href="https://www.awaimai.com/2684.html">PHP Opcache工作原理</a></li><li><a href="http://www.nowamagic.net/librarys/veda/detail/1324">PHP内核探索：操作码OpCode</a></li><li><a href="https://blog.51cto.com/ckl893/1786964">OPcache安装配置及链接生效配置</a></li><li><a href="https://www.php.net/manual/zh/ref.opcache.php">OPcache 函数</a></li><li><a href="https://www.zybuluo.com/phper/note/1016714">Opcode是啥以及如何使用好Opcache</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PHP代码的生命周期&quot;&gt;&lt;a href=&quot;#PHP代码的生命周期&quot; class=&quot;headerlink&quot; title=&quot;PHP代码的生命周期&quot;&gt;&lt;/a&gt;PHP代码的生命周期&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;不启用OPcache的流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="程序语言" scheme="http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    <category term="PHP" scheme="http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
    <category term="PHP" scheme="http://shjlone.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Symfony使用记录</title>
    <link href="http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/symfony%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/symfony%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</id>
    <published>2021-06-07T01:45:07.567Z</published>
    <updated>2021-06-07T01:45:07.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Symfony中请求的流程"><a href="#Symfony中请求的流程" class="headerlink" title="Symfony中请求的流程"></a>Symfony中请求的流程</h2><h3 id="如何在新接口部署的时候平稳的切换缓存"><a href="#如何在新接口部署的时候平稳的切换缓存" class="headerlink" title="如何在新接口部署的时候平稳的切换缓存"></a>如何在新接口部署的时候平稳的切换缓存</h3><p>使用php console cache:warmup命令，进行缓存预热，当缓存文件全部生成好后，即可平稳当切换。而不是手动删除缓存文件，待请求来之后再生成缓存。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h4><ul><li><a href="https://blog.whiteoctober.co.uk/index.html%3Fp=1751.html">https://blog.whiteoctober.co.uk/index.html%3Fp=1751.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Symfony中请求的流程&quot;&gt;&lt;a href=&quot;#Symfony中请求的流程&quot; class=&quot;headerlink&quot; title=&quot;Symfony中请求的流程&quot;&gt;&lt;/a&gt;Symfony中请求的流程&lt;/h2&gt;&lt;h3 id=&quot;如何在新接口部署的时候平稳的切换缓存&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="程序语言" scheme="http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    <category term="PHP" scheme="http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/PHP/"/>
    
    
    <category term="PHP" scheme="http://shjlone.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>cef笔记</title>
    <link href="http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/cef/"/>
    <id>http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/cef/</id>
    <published>2021-06-07T01:45:07.566Z</published>
    <updated>2021-06-07T01:45:07.566Z</updated>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://github.com/chromiumembedded/cef">https://github.com/chromiumembedded/cef</a><br>下载地址：<a href="http://opensource.spotify.com/cefbuilds/index.html">http://opensource.spotify.com/cefbuilds/index.html</a></p><p>Python版： <a href="https://github.com/cztomczak/cefpython">https://github.com/cztomczak/cefpython</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官网：&lt;a href=&quot;https://github.com/chromiumembedded/cef&quot;&gt;https://github.com/chromiumembedded/cef&lt;/a&gt;&lt;br&gt;下载地址：&lt;a href=&quot;http://opensource.spoti</summary>
      
    
    
    
    <category term="程序语言" scheme="http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="http://shjlone.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>socket编程笔记</title>
    <link href="http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/socket%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/socket%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2021-06-07T01:45:07.566Z</published>
    <updated>2021-06-07T01:45:07.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>；AF_INET6 表示 IPv6 地址，例如 <span class="number">1030</span>::C9B4:FF12:<span class="number">48</span>AA:<span class="number">1</span>A2B。</span><br><span class="line">type 为数据传输方式，常用的有 SOCK_STREAM 和 SOCK_DGRAM</span><br><span class="line">protocol 表示传输协议，常用的有 IPPROTO_TCP 和 <span class="function">IPPTOTO_UDP</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(SOCKET sock, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">int</span> addrlen)</span></span>;  <span class="comment">//Windows</span></span><br><span class="line">sock 为 socket 文件描述符，</span><br><span class="line">addr 为 sockaddr 结构体变量的指针，</span><br><span class="line">addrlen 为 addr 变量的大小，可由 <span class="built_in"><span class="keyword">sizeof</span></span>() 计算得出。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin_family;   <span class="comment">//地址族（Address Family），也就是地址类型</span></span><br><span class="line">    <span class="keyword">uint16_t</span>        sin_port;     <span class="comment">//16位的端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>     <span class="comment">//32位IP地址</span></span><br><span class="line">    <span class="keyword">char</span>            sin_zero[<span class="number">8</span>];  <span class="comment">//不使用，一般用0填充</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr *serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(SOCKET sock, <span class="keyword">const</span> struct sockaddr *serv_addr, <span class="keyword">int</span> addrlen)</span></span>;  <span class="comment">//Windows</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">让套接字进入被动监听状态，所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。 </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> backlog)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(SOCKET sock, <span class="keyword">int</span> backlog)</span></span>;  <span class="comment">//Windows</span></span><br><span class="line">sock 为需要进入监听状态的套接字</span><br><span class="line">backlog 为请求队列的最大长度</span><br><span class="line"></span><br><span class="line">请求队列</span><br><span class="line">当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。</span><br><span class="line">缓冲区的长度（能存放多少个客户端请求）可以通过 <span class="built_in">listen</span>() 函数的 backlog 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是<span class="number">10</span>或者<span class="number">20</span>。</span><br><span class="line">如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。</span><br><span class="line">当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误，对于 Windows，客户端会收到 WSAECONNREFUSED 错误。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(SOCKET sock, struct sockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span>;  <span class="comment">//Windows</span></span><br><span class="line">返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Linux下的数据接收和发送</span><br><span class="line"></span><br><span class="line">会将缓冲区 buf 中的 nbytes 个字节写入文件 fd，成功则返回写入的字节数，失败则返回 <span class="number">-1</span>。</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line">fd 为要写入的文件的描述符，buf 为要写入的数据的缓冲区地址，nbytes 为要写入的数据的字节数。 </span><br><span class="line"></span><br><span class="line">会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回<span class="number">0</span>），失败则返回 <span class="number">-1</span>。</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Windows下的数据接收和发送</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(SOCKET sock, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(SOCKET sock, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="socket缓冲区"><a href="#socket缓冲区" class="headerlink" title="socket缓冲区"></a>socket缓冲区</h3><p>每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。</p><p>write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。</p><p>TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。</p><p><img src="./socket_1.png"></p><p>这些I/O缓冲区特性可整理如下：</p><pre><code>I/O缓冲区在每个TCP套接字中单独存在；I/O缓冲区在创建套接字时自动生成；即使关闭套接字也会继续传送输出缓冲区中遗留的数据；关闭套接字将丢失输入缓冲区中的数据。</code></pre><p>输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> optVal;</span><br><span class="line"><span class="keyword">int</span> optLen = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="built_in">getsockopt</span>(servSock, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">char</span>*)&amp;optVal, &amp;optLen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Buffer length: %d\n&quot;</span>, optVal);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h3><p>对于TCP套接字（默认情况下），当使用 write()/send() 发送数据时：</p><ol><li>首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么 write()/send() 会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()/send() 函数继续写入数据。</li><li>如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()/send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()/send() 才会被唤醒。</li><li>如果要写入的数据大于缓冲区的最大长度，那么将分批写入。</li><li>直到所有数据被写入缓冲区 write()/send() 才能返回。</li></ol><p>当使用 read()/recv() 读取数据时：</p><ol><li>首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。</li><li>如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()/recv() 函数再次读取。</li><li>直到读取到数据后 read()/recv() 函数才会返回，否则就一直被阻塞。</li></ol><p>这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。 </p><h3 id="TCP数据报结构以及三次握手"><a href="#TCP数据报结构以及三次握手" class="headerlink" title="TCP数据报结构以及三次握手"></a>TCP数据报结构以及三次握手</h3><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。</p><p>客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。</p><p>TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：</p><ul><li>[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”</li><li>[Shake 2] 套接字B：“好的，我这边已准备就绪。”</li><li>[Shake 3] 套接字A：“谢谢你受理我的请求。”</li></ul><h4 id="TCP数据报结构"><a href="#TCP数据报结构" class="headerlink" title="TCP数据报结构"></a>TCP数据报结构</h4><p><img src="./socket_2.png"></p><p>带阴影的几个字段需要重点说明一下：</p><ol><li><p>序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。</p></li><li><p>确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。</p></li><li><p>标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：</p><ul><li>URG：紧急指针（urgent pointer）有效。</li><li>ACK：确认序号有效。</li><li>PSH：接收方应该尽快将这个报文交给应用层。</li><li>RST：重置连接。</li><li>SYN：建立一个新连接。</li><li>FIN：断开一个连接。</li></ul></li></ol><blockquote><p>Seq 是 Sequence 的缩写，表示序列；Ack(ACK) 是 Acknowledge 的缩写，表示确认；SYN 是 Synchronous 的缩写，愿意是“同步的”，这里表示建立同步连接；FIN 是 Finish 的缩写，表示完成。</p></blockquote><h4 id="连接的建立（三次握手）"><a href="#连接的建立（三次握手）" class="headerlink" title="连接的建立（三次握手）"></a>连接的建立（三次握手）</h4><p><img src="./socket_3.png"></p><p>客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。</p><p>这个时候，客户端开始发起请求：</p><ol><li><p>当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。</p></li><li><p>服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。</p></li></ol><p>服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。<br>服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。<br>服务器将数据包发出，进入SYN-RECV状态。</p><ol start="3"><li><p>客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。<br>接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。<br>客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。</p></li><li><p>服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。<br>至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了。</p></li></ol><h3 id="数据的传输过程"><a href="#数据的传输过程" class="headerlink" title="数据的传输过程"></a>数据的传输过程</h3><p><img src="./socket_4.png"></p><p> 上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1个数据包发送100个字节的数据，数据包的 Seq 号设置为 1200。主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。 </p><blockquote><p>为了保证数据准确到达，目标机器在收到数据包（包括SYN包、FIN包、普通数据包等）包后必须立即回传ACK包，这样发送方才能确认数据传输成功。</p></blockquote><p>此时 Ack 号为 1301 而不是 1201，原因在于 Ack 号的增量为传输的数据字节数。假设每次 Ack 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全部正确传递还是丢失了一部分，比如只传递了80字节。因此按如下的公式确认 Ack 号： Ack号 = Seq号 + 传递的字节数 + 1，与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。</p><p>下面分析传输过程中数据包丢失的情况，如下图所示： </p><p><img src="./socket_5.png"></p><p>上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。</p><p>为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。 </p><p><strong>重传超时时间（RTO, Retransmission Time Out）</strong></p><p>这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。 </p><blockquote><p>往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 ACK 确认包（接收端收到数据后便立即确认），总共经历的时延。</p></blockquote><p><strong>重传时间</strong></p><p>TCP数据包重传次数根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传3次，如果重传3次后还未收到该数据包的 ACK 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。</p><h3 id="TCP四次握手断开连接"><a href="#TCP四次握手断开连接" class="headerlink" title="TCP四次握手断开连接"></a>TCP四次握手断开连接</h3><p>建立连接需要三次握手，断开连接需要四次握手，可以形象的比喻为下面的对话：</p><ul><li>[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”</li><li>[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”</li><li>等待片刻后……</li><li>[Shake 3] 套接字B：“我准备好了，可以断开连接了。”</li><li>[Shake 4] 套接字A：“好的，谢谢合作。”</li></ul><p><img src="./socket_6.png"></p><p>建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求：</p><ol><li><p>客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。</p></li><li><p>服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。</p></li></ol><p>注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。</p><ol start="3"><li><p>客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。</p></li><li><p>等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。</p></li><li><p>客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。</p></li><li><p>服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。 </p></li></ol><p><strong>关于 TIME_WAIT 状态的说明</strong></p><p>客户端最后一次发送 ACK包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，这是为什么呢？</p><p>TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，不能丢失或出错，而网络是不稳定的，随时可能会毁坏数据，所以机器A每次向机器B发送数据包后，都要求机器B”确认“，回传ACK包，告诉机器A我收到了，这样机器A才能知道数据传送成功了。如果机器B没有回传ACK包，机器A会重新发送，直到机器B回传ACK包。</p><p>客户端最后一次向服务器回传ACK包时，有可能会因为网络问题导致服务器收不到，服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到ACK包了，所以客户端需要等待片刻、确认对方收到ACK包后才能进入CLOSED状态。那么，要等待多久呢？</p><p>数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为报文最大生存时间（MSL，Maximum Segment Lifetime）。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包。</p><h3 id="窗口协议"><a href="#窗口协议" class="headerlink" title="窗口协议"></a>窗口协议</h3><h3 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h3><p>ARQ协议主要包含：停等ARQ协议、连续ARQ协议，其中连续ARQ协议是为了解决停等ARQ协议信道利用率低的问题，目前传统的连续ARQ协议有回退N帧ARQ协议、选择性重传ARQ协议。</p><p>连续ARQ协议（Continuous ARQ）</p><p>回退N帧ARQ协议（Go-Back-N）</p><ol><li>接收端丢弃从第一个没有收到的数据包开始的所有数据包</li><li>发送端收到NACK后，从NACK中指明的数据包开始重新发送</li></ol><p>选择性重传ARQ协议（Selective Repeat）</p><ol><li>发送端连续发送数据包但对每个数据包都设有个一个计时器</li><li>当在一定时间内没有收到某个数据包的ACK时，发送端只重新发送那个没有ACK的数据包</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;API介绍&quot;&gt;&lt;a href=&quot;#API介绍&quot; class=&quot;headerlink&quot; title=&quot;API介绍&quot;&gt;&lt;/a&gt;API介绍&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="程序语言" scheme="http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="http://shjlone.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C语言学习笔记</title>
    <link href="http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-06-07T01:45:07.566Z</published>
    <updated>2021-06-07T01:45:07.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名hello.c</span></span><br><span class="line"><span class="comment">//预处理指令</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gcc hello.c</span><br><span class="line">./a.out  <span class="comment">//输出hello world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C语言数据类型"><a href="#C语言数据类型" class="headerlink" title="C语言数据类型"></a>C语言数据类型</h2><ul><li>字符型（char）：描述单个字符（一个字节），用半角的单引号包含起来，如’a’、’A’、’1’、’$’等，键盘能输入的英文和半角的符号都是字符。中文的汉字和标点符号是两个字节（GBK编码），不能算一个字符。</li><li>整型（int）：描述整数。</li><li>浮点型（float）：描述实数。</li><li>字符串：描述多个字符，用半角的双引号包含起来，可以是英文、数字、中文、标点符号，半角全角的都可以。</li><li>结构体（struct）：由基本类型通过一定的构造方法构造出来的类型，包括数组和结构体。</li><li>指针类型：指针可以存放内存变量和常量地址。</li><li>其他类型：如复数类型（_Complex）、虚数类型（_Imaginary）、布尔型（_bool）等。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h3><p>变量名属于标识符，需要符合标识符的命名规范，具体如下：</p><ol><li>变量名的第一个字符必须是字母或下划线，不能是数字和其它字符。</li><li>变量名中的字母是区分大小写的。比如a和A是不同的变量名，num和Num也是不同的变量名。</li><li>变量名绝对不可以是C语言的关键字。</li></ol><h3 id="变量的定义和初始化"><a href="#变量的定义和初始化" class="headerlink" title="变量的定义和初始化"></a>变量的定义和初始化</h3><p>变量在定义后，操作系统为它分配了一块内存，但并不会把这块内存打扫干静，也就是说内存中可能有垃圾数据，建议在使用之间对其初始化（打扫干静）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>   ii;   <span class="comment">// 定义整数型变量，用于存放整数。</span></span><br><span class="line"><span class="keyword">char</span>  cc;  <span class="comment">// 定义字符型变量，用于存放字符。</span></span><br><span class="line"><span class="keyword">double</span> money;   <span class="comment">// 定义浮点型变量，用于存放浮点数。</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">21</span>];   <span class="comment">// 定义一个可以存放20字符的字符串。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对整数型、字符型、浮点型变量来说，初始化就是给它们赋0值。</span></span><br><span class="line"><span class="keyword">int</span>   ii=<span class="number">0</span>;   <span class="comment">// 定义整数型变量并初始化</span></span><br><span class="line"><span class="keyword">char</span>  cc=<span class="number">0</span>;  <span class="comment">// 定义字符型变量并初始化</span></span><br><span class="line"><span class="keyword">double</span> money=<span class="number">0</span>;   <span class="comment">// 定义浮点型变量并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以先定义，然后再初始化。</span></span><br><span class="line"><span class="keyword">int</span>   ii;  <span class="comment">// 定义整数型变量</span></span><br><span class="line"><span class="keyword">char</span>  cc;  <span class="comment">// 定义字符型变量</span></span><br><span class="line"><span class="keyword">double</span> money;   <span class="comment">// 定义浮点型变量</span></span><br><span class="line">ii=<span class="number">0</span>;  <span class="comment">// 初始化ii为0</span></span><br><span class="line">cc=<span class="number">0</span>;  <span class="comment">// 初始化cc为0</span></span><br><span class="line">money=<span class="number">0</span>;  <span class="comment">// 初始化money为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对字符串变量来说，初始化就是把内容清空，本质上也是赋0值。</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">21</span>];  <span class="comment">// 定义一个可以存放20字符的字符串</span></span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="keyword">sizeof</span>(name));   <span class="comment">// 清空字符串name中的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明常量</span></span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">double</span>  pi = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="C语言中的关键字"><a href="#C语言中的关键字" class="headerlink" title="C语言中的关键字"></a>C语言中的关键字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>：声明自动变量</span><br><span class="line"><span class="keyword">break</span>：跳出当前循环</span><br><span class="line"><span class="keyword">case</span>：开关语句分支</span><br><span class="line"><span class="keyword">char</span>：声明字符型变量或函数返回值类型</span><br><span class="line"><span class="keyword">const</span>：声明只读变量</span><br><span class="line"><span class="keyword">continue</span>：结束当前循环，开始下一轮循环</span><br><span class="line"><span class="keyword">default</span>：开关语句中的“默认”分支</span><br><span class="line"><span class="keyword">do</span>：循环语句的循环体</span><br><span class="line"><span class="keyword">double</span>：声明双精度浮点型变量或函数返回值类型</span><br><span class="line"><span class="keyword">else</span>：条件语句否定分支（与<span class="keyword">if</span>连用）</span><br><span class="line"><span class="keyword">enum</span>：声明枚举类型</span><br><span class="line"><span class="keyword">extern</span>：声明变量或函数是在其它文件或本文件的其他位置定义</span><br><span class="line"><span class="keyword">float</span>：声明浮点型变量或函数返回值类型</span><br><span class="line"><span class="keyword">for</span>：一种循环语句</span><br><span class="line"><span class="keyword">goto</span>：无条件跳转语句</span><br><span class="line"><span class="keyword">if</span>：条件语句</span><br><span class="line"><span class="keyword">int</span>：声明整型变量或函数</span><br><span class="line"><span class="keyword">long</span>：声明长整型变量或函数返回值类型</span><br><span class="line"><span class="keyword">register</span>：声明寄存器变量</span><br><span class="line"><span class="keyword">return</span>：子程序返回语句（可以带参数，也可不带参数）</span><br><span class="line"><span class="keyword">short</span>：声明短整型变量或函数</span><br><span class="line"><span class="keyword">signed</span>：声明有符号类型变量或函数</span><br><span class="line"><span class="keyword">sizeof</span>：计算数据类型或变量长度（即所占字节数）</span><br><span class="line"><span class="keyword">static</span>：声明静态变量</span><br><span class="line">struct：声明结构体类型</span><br><span class="line"><span class="keyword">switch</span>：用于开关语句</span><br><span class="line"><span class="keyword">typedef</span>：用以给数据类型取别名</span><br><span class="line"><span class="keyword">unsigned</span>：声明无符号类型变量或函数</span><br><span class="line"><span class="keyword">union</span>：声明共用体类型</span><br><span class="line"><span class="keyword">void</span>：声明函数无返回值或无参数，声明无类型指针</span><br><span class="line"><span class="keyword">volatile</span>：说明变量在程序执行中可被隐含地改变</span><br><span class="line"><span class="keyword">while</span>：循环语句的循环条件</span><br></pre></td></tr></table></figure><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">getchar：输入单个字符，保存到字符变量中。</span><br><span class="line">gets：输入一行数据，保存到字符串变量中。</span><br><span class="line"><span class="built_in">scanf</span>：格式化输入函数，一次可以输入多个数据，保存到多个变量中。</span><br><span class="line"></span><br><span class="line"><span class="built_in">putchar</span>：输出单个字符。</span><br><span class="line"><span class="built_in">puts</span>：输出字符串。</span><br><span class="line"><span class="built_in">printf</span>：格式化输出函数，可输出常量、变量等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age=<span class="number">18</span>;</span><br><span class="line"><span class="keyword">char</span> xb=<span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="keyword">double</span> weight=<span class="number">62.5</span>;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="keyword">sizeof</span>(name));</span><br><span class="line"><span class="built_in">strcpy</span>(name, <span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我的姓名是：%s，姓别：%c，年龄：%d岁，体重%lf公斤。\n&quot;</span>,name,xb,age,weight);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> xb=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> weight=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="keyword">sizeof</span>(name));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您的姓名、姓别（x-男；y-女），年龄和体重，中间用空格分隔：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %c %d %lf&quot;</span>,name,&amp;xb,&amp;age,&amp;weight); </span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;您的姓名是：%s，姓别：%c，年龄：%d岁，体重%lf公斤。\n&quot;</span>,name,xb,age,weight);</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol><li>算术运算符；</li><li>赋值运算符；</li><li>sizeof运算符；</li><li>关系运算符；</li><li>逻辑运算符；</li><li>位运算符。</li></ol><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>两个数相加</td><td>A+B 将得到 23</td></tr><tr><td>-</td><td>一个数减另一个数</td><td>A-B 将得到 13</td></tr><tr><td>*</td><td>两个数相乘</td><td>A*B 将得到 90</td></tr><tr><td>/</td><td>分子除以分母</td><td>A/B 将得到 3.6</td></tr><tr><td>%</td><td>余数运算符，整除后的余数</td><td>B%A 将得到 3</td></tr><tr><td>++</td><td>自增运算符，整数值增加 1</td><td>A++ 将得到 19</td></tr><tr><td>–</td><td>自减运算符，整数值减少 1</td><td>A– 将得到 17</td></tr></tbody></table><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td>C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td>+=</td><td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td>C += A 相当于 C = C + A</td></tr><tr><td>-=</td><td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td>C -= A 相当于 C = C - A</td></tr><tr><td>*=</td><td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td>C *= A 相当于 C = C * A</td></tr><tr><td>/=</td><td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td>C /= A 相当于 C = C / A</td></tr><tr><td>%=</td><td>求余数且赋值运算符，求两个操作数的模赋值给左边操作数，浮点数不适用取余数。</td><td>C %= A 相当于 C = C % A</td></tr></tbody></table><h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><p>用来计算变量（或数据类型）在当前系统中占用内存的字节数。sizeof不是函数，产生这样的疑问是因为sizeof的书写确实有点像函数，sizeof有两种写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于数据类型，数据类型必须用括号括住。</span></span><br><span class="line"><span class="keyword">sizeof</span>(数据类型);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字符型变量占用的内存是=%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));   <span class="comment">// 输出：字符型变量占用的内存是=1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;整型变量占用的内存是=%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));   <span class="comment">// 输出：整型变量占用的内存是=4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于变量</span></span><br><span class="line"><span class="keyword">sizeof</span>(变量名);</span><br><span class="line"><span class="keyword">sizeof</span> 变量名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ii;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ii占用的内存是=%d\n&quot;</span>,<span class="keyword">sizeof</span>(ii));   <span class="comment">// 输出：ii占用的内存是=4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ii占用的内存是=%d\n&quot;</span>,<span class="keyword">sizeof</span> ii);   <span class="comment">// 输出：ii占用的内存是=4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th>关系</th><th>数学中的表示</th><th>C语言的表示</th></tr></thead><tbody><tr><td>小于</td><td>&lt;</td><td>&lt;</td></tr><tr><td>小于等于</td><td>≤</td><td>&lt;=</td></tr><tr><td>大于</td><td>&gt;</td><td>&gt;</td></tr><tr><td>大于等于</td><td>≥</td><td>&gt;=</td></tr><tr><td>等于</td><td>=</td><td>==</td></tr><tr><td>不等于</td><td>≠</td><td>!=</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与</td><td>true &amp;&amp; false 等于false</td></tr><tr><td>||</td><td>逻辑或</td><td>true &amp;&amp; false 等于true</td></tr><tr><td>!</td><td>逻辑非</td><td>true的逻辑非为真</td></tr></tbody></table><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><blockquote><p>表达式1?表达式2:表达式3;</p></blockquote><p>先执行表达式1，如果表达式1的结果如果为真，那么执行表达式2，并且这个整体的运算式的结果是表达式2的结果；如果表达式1的结果如果为假，执行表达式3，运算式的结果是表达式3的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> year;</span><br><span class="line">year=(year%<span class="number">100</span>==<span class="number">0</span>)?(year%<span class="number">400</span>==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>):(year%<span class="number">4</span>==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="if、switch语句"><a href="#if、switch语句" class="headerlink" title="if、switch语句"></a>if、switch语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 整型数值<span class="number">1</span>: 语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">case</span> 整型数值<span class="number">2</span>: 语句<span class="number">2</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">case</span> 整型数值n: 语句n;</span><br><span class="line"><span class="keyword">default</span>: 语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意</span></span><br><span class="line"><span class="comment">//1. case后面必须是整数和字符，或者是结果为整数和字符的表达式，但不能包含任何变量</span></span><br><span class="line"><span class="comment">//2. default不是必须的。当没有 default时，如果所有case都匹配失败，那么就什么都不执行。</span></span><br></pre></td></tr></table></figure><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(表达式)语句块;</span><br><span class="line">    <span class="keyword">if</span>(表达式)<span class="keyword">break</span>;<span class="comment">//跳出当前循环</span></span><br><span class="line">    <span class="keyword">if</span>(表达式)<span class="keyword">continue</span>; <span class="comment">//跳转到循环的首部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    语句块</span><br><span class="line">&#125;  <span class="keyword">while</span> (表达式)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> times=<span class="number">0</span>;   <span class="comment">// 记录用户输入数据的次数</span></span><br><span class="line"><span class="keyword">int</span> value=<span class="number">0</span>;   <span class="comment">// 用户每次从键盘输入的数据</span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;     <span class="comment">// 记录用户输入数据的和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (sum&lt;<span class="number">5000</span>)  <span class="comment">// 如果sum的值小于5000，进入循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数字：&quot;</span>);    <span class="comment">// 提示用户输入</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;value);  <span class="comment">// 接受用户从键盘输入的数据</span></span><br><span class="line"></span><br><span class="line">times++;  <span class="comment">// 用户输入数据的次数自增1</span></span><br><span class="line">sum=sum+value;             <span class="comment">// 记录用户输入数据的和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;您一共输入了%d个数据，和为%d。\n&quot;</span>,times,sum);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句<span class="number">1</span>;表达式;语句<span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    语句块</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>for循环开始时，会先执行语句1，而且在整个循环过程中只执行一次语句1。</li><li>接着判断表达式的条件，如果条件成立，就执行一次循环体中的语句块。</li><li>语句块执行完后，接下来会执行语句2。</li><li>重复第2）步和第3），直到表达式的条件不成立才结束for循环。</li></ol><p><strong>注意：</strong></p><ol><li>在for循环中，语句1、表达式和语句2都可以为空，for (;;)等同于while (1)。</li><li>continue和break两个关键字也可以用在for循环体中。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ii=<span class="number">1</span>;      <span class="comment">// 用于for循环的计数器</span></span><br><span class="line">  <span class="keyword">int</span> sum=<span class="number">0</span>;     <span class="comment">// 记录1到100的累积值</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (ii=<span class="number">1</span>;ii&lt;=<span class="number">100</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    sum=sum+ii;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;1到100的累积值为%d。\n&quot;</span>,sum);</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组（array）是一组数据类型相同的变量，可以存放一组数据，它定义的语法是：</p><blockquote><p>数据类型 数组名[数组长度];</p></blockquote><p>定义数组的时候，数组的长度必须是整数，可以是常量，也可以是变量。数据的下标也必须是整数，可以是常量，也可以是变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ii[<span class="number">10</span>];    <span class="comment">// 定义一个整型数组变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(ii)=%d\n&quot;</span>,<span class="keyword">sizeof</span>(ii));     <span class="comment">// 输出结果：sizeof(ii)=40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组初始化</span></span><br><span class="line"><span class="keyword">int</span> no[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(no,<span class="number">0</span>,<span class="keyword">sizeof</span>(no)); <span class="comment">//第一个参数是数组名，第二个参数填0，第三个参数是数组占用的内存总空间，用sizeof(变量名)获取。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>二维数组</strong></p><blockquote><p>数据类型 数组名[第一维的长度][第二维的长度];</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>    ii=<span class="number">0</span>;          <span class="comment">// 用于组别循环的计数器</span></span><br><span class="line"><span class="keyword">int</span>    jj=<span class="number">0</span>;          <span class="comment">// 用于超女人数循环的计数器</span></span><br><span class="line"><span class="keyword">int</span>    <span class="class"><span class="keyword">class</span>=</span><span class="number">3</span>;       <span class="comment">// 小组总数，初始化为3</span></span><br><span class="line"><span class="keyword">int</span>    total=<span class="number">5</span>;       <span class="comment">// 每个组超女的总人数，初始化为5</span></span><br><span class="line"><span class="keyword">double</span> weight[<span class="class"><span class="keyword">class</span>][<span class="title">total</span>];</span>  <span class="comment">// 定义二维数组，存放超女的体重</span></span><br><span class="line"><span class="keyword">double</span> sum[<span class="class"><span class="keyword">class</span>];</span>    <span class="comment">// 定义一维数组存放超女体重的和</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(weight,<span class="number">0</span>,<span class="keyword">sizeof</span>(weight));   <span class="comment">// 初始化数组为0</span></span><br><span class="line"><span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));          <span class="comment">// 初始化数组为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用两个循环，第一级循环为小组数，第二级循环为超女人数</span></span><br><span class="line"><span class="keyword">for</span> (ii=<span class="number">0</span>;ii&lt;class;ii++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (jj=<span class="number">0</span>;jj&lt;total;jj++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d组第%d名超女的体重：&quot;</span>,ii+<span class="number">1</span>,jj+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;weight[ii][jj]);    <span class="comment">// 接受从键盘输入的体重</span></span><br><span class="line">  sum[ii]=sum[ii]+weight[ii][jj];  <span class="comment">// 计算小组超女体重的和</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串就是一个以空字符’\0’结束的字符数组，是一个特别的字符数组，这是约定，是规则。空字符’\0’也可以直接写成0。</p><p><img src="./c_1.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化， 因为字符串需要用0结束，所以在定义字符串的时候，要预留多一个字节来存放0。</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">21</span>];  <span class="comment">// 定义一个最多存放20个字符或10个汉字的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串是数组，当然可以用初始化数组的方法来初始化字符串。</span></span><br><span class="line"><span class="built_in">memset</span>(strname,<span class="number">0</span>,<span class="keyword">sizeof</span>(strname));</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串的赋值</span></span><br><span class="line"><span class="built_in">strcpy</span>(strword,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 或者用以下代码</span></span><br><span class="line"><span class="keyword">char</span> strword[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">memset</span>(strword,<span class="number">0</span>,<span class="keyword">sizeof</span>(strword));</span><br><span class="line">strword[<span class="number">0</span>]=<span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">strword[<span class="number">1</span>]=<span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">strword[<span class="number">2</span>]=<span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">strword[<span class="number">3</span>]=<span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">strword[<span class="number">4</span>]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">strword[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;      <span class="comment">// 或者 name[5]=0;</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><blockquote><p>return_type function_name( parameter list );</p></blockquote><ol><li>返回值的数据类型return_type：函数执行完任务后的返回值，可以是int、char、double或其它自定义的数据类型。如果函数只执行任务而不返回值，return_type用关键字 void表示，如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void function_name( parameter list );</span><br></pre></td></tr></table></figure><ol start="2"><li><p>函数名function_name：函数名是标识符，命名规则与变量相同。</p></li><li><p>参数列表parameter list：当函数被调用时，调用者需要向函数传递参数。参数列表包括参数的数据类型和书写顺序。参数列表是可选的，也就是说，函数可以没有参数，如下：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type function_name();</span><br></pre></td></tr></table></figure><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数定义的return_type、function_name和parameter list必须与函数声明一致。</span></span><br><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span>       <span class="comment">// 注意，不要在函数定义的最后加分号。</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 实现函数功能的代码</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>#include &lt;&gt; 用于包含系统提供的头文件，编译的时候，gcc在系统的头文件目录中寻找头文件。</li><li>#include “” 用于包含程序员自定义的头文件，编译的时候，gcc先在当前目录中寻找头文件，如果找不到，再到系统的头文件目录中寻找。</li></ul><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>C语言标准库函数的声明的头文件存放在/usr/include目录中，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;asset.h&gt;  &lt;ctype.h&gt;  &lt;errno.h&gt;  &lt;float.h&gt;  &lt;limits.h&gt;</span><br><span class="line">&lt;locale.h&gt;  &lt;math.h&gt;  &lt;setjmp.h&gt;  &lt;signal.h&gt;  &lt;stdarg.h&gt;</span><br><span class="line">&lt;stddef.h&gt;  &lt;stdlib.h&gt;  &lt;stdio.h&gt;  &lt;string.h&gt;  &lt;time.h&gt;</span><br></pre></td></tr></table></figure><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>作用域是程序中定义的变量存在（或生效）的区域，超过该区域变量就不能被访问。C 语言中有四种地方可以定义变量。</p><ol><li>在所有函数外部定义的是全局变量。</li><li>在头文件中定义的是全局变量。</li><li>在函数或语句块内部定义的是局部变量。它们只能在该函数或语句块内部的语句使用。</li><li>函数的参数是该函数的局部变量。</li></ol><p><strong>注意</strong></p><ul><li>局部变量和全局变量的名称可以相同，在某函数或语句块内部，如果局部变量名与全局变量名相同，就会屏蔽全局变量而使用局部变量。</li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><strong>变量</strong></p><p>内存变量简称变量，在C语言中，每定义一个变量，系统就会给变量分配一块内存，而内存是有地址的。如果把计算机的内存区域比喻成一个大宾馆，每块内存的地址就像宾馆房间的编号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">int</span>    ii=<span class="number">10</span>;</span><br><span class="line"> <span class="keyword">char</span>   cc=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"> <span class="keyword">double</span> dd=<span class="number">100.56</span>;</span><br><span class="line"><span class="comment">//在printf函数中，输出内存地址的格式控制符是%p，地址采用十六进制的数字显示。</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;变量ii的地址是：%p\n&quot;</span>,&amp;ii);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;变量cc的地址是：%p\n&quot;</span>,&amp;cc);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;变量dd的地址是：%p\n&quot;</span>,&amp;dd);</span><br></pre></td></tr></table></figure><p><strong>指针</strong></p><p>指针是一种特别变量，全称是指针变量，专用于存放其它变量在内存中的地址编号，指针在使用之前要先声明，语法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">datatype *varname;</span><br><span class="line"></span><br><span class="line">datatype 是指针的基类型，它必须是一个有效的C数据类型（<span class="keyword">int</span>、<span class="keyword">char</span>、<span class="keyword">double</span>或其它自定义的数据类型），varname 是指针的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  *ip;  <span class="comment">// 一个整型的指针</span></span><br><span class="line"><span class="keyword">char</span>  *cp;  <span class="comment">// 一个字符型的指针</span></span><br><span class="line"><span class="keyword">double</span>  *dp;  <span class="comment">// 一个 double 型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ii = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *pii = <span class="number">0</span>;  <span class="comment">// 定义整数型指针并初始化</span></span><br><span class="line">pii = &amp;ii;  <span class="comment">// 数型指针指向变量ii</span></span><br><span class="line"><span class="comment">// 通过指针操作内存变量，改变内存变量的值</span></span><br><span class="line">*pii = <span class="number">20</span>;    <span class="comment">// 同ii=20;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pii的值是：%p\n&quot;</span>, pii);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*pii的值是：%d\n&quot;</span>, *pii);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ii的值是：%d\n&quot;</span>, ii);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//空指针</span></span><br><span class="line"><span class="keyword">int</span> *pi=<span class="number">0</span>;  <span class="comment">// 定义一个指针</span></span><br><span class="line">*pi=<span class="number">10</span>;  <span class="comment">// 试图对空指针进行赋值操作，必将引起程序的崩溃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//地址的运算</span></span><br><span class="line"><span class="keyword">char</span>   cc[<span class="number">4</span>];   <span class="comment">// 字符数组</span></span><br><span class="line"><span class="keyword">int</span>    ii[<span class="number">4</span>];   <span class="comment">// 整数数组</span></span><br><span class="line"><span class="keyword">double</span> dd[<span class="number">4</span>];   <span class="comment">// 浮点数组</span></span><br><span class="line"><span class="comment">// 用地址相加的方式显示数组全部元素的的址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p\n&quot;</span>,cc,cc+<span class="number">1</span>,cc+<span class="number">2</span>,cc+<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p\n&quot;</span>,ii,ii+<span class="number">1</span>,ii+<span class="number">2</span>,ii+<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p %p %p\n&quot;</span>,dd,dd+<span class="number">1</span>,dd+<span class="number">2</span>,dd+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针也是一种内存变量，是内存变量就要占用内存空间，在C语言中，任何类型的指针占用8字节的内存（32位操作系统4字节）。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(int *) is %d.\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span> *));        <span class="comment">// 输出：sizeof(int *) is 8</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(char *) is %d.\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span> *));      <span class="comment">// 输出：sizeof(char *) is 8</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(double *) is %d.\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span> *));  <span class="comment">// 输出：sizeof(double *) is 8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>在定义整型变量的时候，可以在int关键字之前加signed、unsigned、short和long四种修饰符。</p><ul><li>signed：有符号的，可以表示正数和负数。</li><li>unsigned：无符号的，只能表示正数，例如数组的下标、人的身高等。</li><li>short：短的，现在主流的64位操作系统下，整数占用内存4个字节。</li><li>long：长的，更长的整数。</li></ul><h3 id="整数的取值范围"><a href="#整数的取值范围" class="headerlink" title="整数的取值范围"></a>整数的取值范围</h3><p>整数的取值范围与计算机操作系统和C语言编译器有关，没有一个固定的数值，我们可以根据它占用的内存大小来推断它的取值范围。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">一个字节有<span class="number">8</span>个位，表示的数据的取值范围是<span class="number">28</span><span class="number">-1</span>，即<span class="number">255</span>。</span><br><span class="line">如果占用的内存是两个字节，无符号型取值范围是<span class="number">2</span>**<span class="number">8</span>ⅹ<span class="number">2</span>**<span class="number">8</span><span class="number">-1</span>。</span><br><span class="line">如果占用的内存是四个字节，无符号型取值范围是<span class="number">2</span>**<span class="number">8</span>ⅹ<span class="number">2</span>**<span class="number">8</span>ⅹ<span class="number">2</span>**<span class="number">8</span>ⅹ<span class="number">2</span>**<span class="number">8</span><span class="number">-1</span>。</span><br><span class="line">如果占用的内存是八个字节，无符号型取值范围是<span class="number">2</span>**<span class="number">8</span>ⅹ<span class="number">2</span>**<span class="number">8</span>ⅹ<span class="number">2</span>**<span class="number">8</span>ⅹ<span class="number">2</span>**<span class="number">8</span>ⅹ<span class="number">2</span>**<span class="number">8</span>ⅹ<span class="number">2</span>**<span class="number">8</span>ⅹ<span class="number">2</span>**<span class="number">8</span>ⅹ<span class="number">2</span>**<span class="number">8</span><span class="number">-1</span>。</span><br><span class="line">如果是有符号，取值范围减半，因为符号占一个位。</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> si;   <span class="comment">// 短整数</span></span><br><span class="line"><span class="keyword">int</span>   ii;   <span class="comment">// 整数</span></span><br><span class="line"><span class="keyword">long</span>  li;   <span class="comment">// 长整数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof short is %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof int is %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof long is %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型简写</th><th>类型全称</th><th>长度</th><th>取值范围</th></tr></thead><tbody><tr><td>short</td><td>[signed] short [int]</td><td>2字节</td><td>-32768~32767</td></tr><tr><td>unsigned short</td><td>unsigned short [int]</td><td>2字节</td><td>0~65535</td></tr><tr><td>int</td><td>[signed] int</td><td>4字节</td><td>-2147483648~2147483647</td></tr><tr><td>unsigned int</td><td>unsigned [int]</td><td>4字节</td><td>0~4294967295</td></tr><tr><td>long</td><td>[signed] long [int]</td><td>8字节</td><td>-9223372036854775808~9223372036854775807</td></tr><tr><td>unsigned long</td><td>unsigned long [int]</td><td>8字节</td><td>0~18446744073709551615</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li>计算机用最高位1位来表达符号（0-正数，1-负数），unsigned修饰过的正整数不需要符号位，在表达正整数的时候比signed修饰的正整数取值大一倍。</li><li>在写程序的时候，上表中括号[]的单词可以省略不书写。</li><li>在写程序的时候，给整数变量赋值不能超出变量的取值范围，编译的时候会出现类似以下的错误，程序运行也可能产生不可预后的后果。</li></ol><p><strong>常用的库函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;   <span class="comment">// 把字符串nptr转换为int整数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">atol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;     <span class="comment">// 把字符串nptr转换为long整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">abs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> j)</span></span>;            <span class="comment">// 求int整数的绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">labs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">int</span> j)</span></span>;     <span class="comment">// 求long整数的绝对值</span></span><br></pre></td></tr></table></figure><p><strong>数据类型的别名</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">size_t</span>;</span><br><span class="line"><span class="keyword">size_t</span> ii; 等同于 <span class="keyword">unsigned</span> <span class="keyword">int</span> ii;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>整型类型级别从低到高依次为：</p><p>signed char-&gt;unsigned char-&gt;short-&gt;unsigned short-&gt;int-&gt;unsigned int-&gt;long-&gt;unsigned long</p><p>浮点型级别从低到高依次为：</p><p>float-&gt;double</p><ol><li>操作数中没有浮点型数据时</li></ol><p>当 char、unsigned char、short 或 unsigned short 出现在表达式中参与运算时，一般将其自动转换为 int 类型。<br>int 与 unsigned int混合运算时，int自动转换为unsigned int型。<br>int、unsigned int 与 long 混合运算时，均转换为 long 类型。</p><ol start="2"><li>操作数中有浮点型数据时</li></ol><p>当操作数中含有浮点型数据时，所有操作数都将转换为 double 型。</p><ol start="3"><li>赋值运算符两侧的类型不一致时</li></ol><p>当赋值运算符的右值（可能为常量、变量或表达式）类型与左值类型不一致时，将右值类型提升/降低为左值类型。</p><ol start="4"><li>右值超出左值类型范围时</li></ol><p>赋值运算符右值的范围超出了左值类型的表示范围，将把该右值截断后，赋给左值。所得结果可能毫无意义。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><blockquote><p>(目标类型) 表达式;</p></blockquote><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体（struct）来存放一组不同类型的数据。语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  结构体成员变量一的声明;</span><br><span class="line">  结构体成员变量二的声明;</span><br><span class="line">  结构体成员变量三的声明;</span><br><span class="line">  ......</span><br><span class="line">  结构体成员变量四的声明;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">51</span>];   <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">int</span>  age;        <span class="comment">// 年龄</span></span><br><span class="line">  <span class="keyword">int</span>  height;     <span class="comment">// 身高，单位：cm</span></span><br><span class="line">  <span class="keyword">int</span>  weight;     <span class="comment">// 体重，单位：kg</span></span><br><span class="line">  <span class="keyword">char</span> sc[<span class="number">31</span>];     <span class="comment">// 身材，火辣；普通；飞机场</span></span><br><span class="line">  <span class="keyword">char</span> yz[<span class="number">31</span>];     <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体是一种程序员自定义的数据类型，是模板，可以用它来定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span> <span class="title">queen</span>, <span class="title">princess</span>, <span class="title">waiting</span>, <span class="title">workers</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span> <span class="title">queen</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct st_girl) %d\n&quot;</span>,<span class="keyword">sizeof</span>(struct st_girl));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(queen) %d\n&quot;</span>,<span class="keyword">sizeof</span>(queen));</span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言提供了结构体成员内存对齐的方法，在定义结构体之前，增加以下代码可以使结构体成员变量之间的内存没有空隙。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//和数组不一样，结构体变量名不是结构体变量的地址，结构体变量名就是变量名，就象int ii一样，只是不能直接输出，直接输出没有意义。取地址要用&amp;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span> <span class="title">stgirl</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,stgirl);   <span class="comment">// 没有意义。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,stgirl);   <span class="comment">// 没有意义，结构体变量名不是结构体变量的地址。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;stgirl);  <span class="comment">// 这才是结构体的地址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体的初始化</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct st_girl));</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="keyword">sizeof</span>(queen));</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意事项，如果把一个结构体的地址传给子函数，子函数用一个结构体指针（如struct st_girl *pst）来存放传入的结构体的地址，那么，在子函数中只能用以下方法来初始化结构体</span></span><br><span class="line"><span class="built_in">memset</span>(pst,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct st_girl));</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span> <span class="title">queen</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span> *<span class="title">pst</span>=</span>&amp;queen;</span><br><span class="line"><span class="comment">//结构体指针使用成员变量</span></span><br><span class="line">(*pointer).memberName</span><br><span class="line">pointer-&gt;memberName</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体复制</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span> <span class="title">girl1</span>,<span class="title">girl2</span>;</span></span><br><span class="line"><span class="built_in">strcpy</span>(girl1.name,<span class="string">&quot;西施&quot;</span>);  <span class="comment">// 对girl1的成员赋值</span></span><br><span class="line">girl1.age=<span class="number">18</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;girl2,&amp;girl1,<span class="keyword">sizeof</span>(struct st_girl));</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体是多个变量集合，作为函数参数时就可以传递整个集合，也就是所有成员。如果结构体成员较多，函数参数的初始化和赋值的内存开销会很大，影响程序的运行效率。所以最好的办法就是传递结构体变量的地址。</span></span><br><span class="line"><span class="comment">// 对结构体赋值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setvalue</span><span class="params">(struct st_girl *pst)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span> <span class="title">queen</span>;</span>  <span class="comment">// 定义结构体变量 </span></span><br><span class="line"><span class="comment">// 初始化结构体变量</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct st_girl));</span><br></pre></td></tr></table></figure><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf是把结果输出到屏幕，sprintf把格式化输出的内容保存到字符串str中，snprintf的n类似于strncpy中的n，意思是只获取输出结果的前n-1个字符，不是n个字符。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式说明符</p><blockquote><p>%[flags][width][.prec]type</p></blockquote><p><strong>类型符type</strong>：表示输出数据的类型</p><ul><li>%hd、%d、%ld 以十进制、有符号的形式输出 short、int、long 类型的整数。</li><li>%hu、%u、%lu 以十进制、无符号的形式输出 short、int、long 类型的整数</li><li>%c 输出字符。</li><li>%lf 以普通方式输出double（float弃用，long doube无用）。</li><li>%e 以科学计数法输出double。</li><li>%s 输出字符串。</li><li>%p 输出内存的地址。</li></ul><p><strong>宽度width</strong>：用于控制输出内容的宽度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12s=\n&quot;</span>,<span class="string">&quot;abc&quot;</span>);     <span class="comment">// 输出=         abc=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12d=\n&quot;</span>,<span class="number">123</span>);       <span class="comment">// 输出=         123=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12lf=\n&quot;</span>,<span class="number">123.5</span>);    <span class="comment">// 输出=  123.500000=</span></span><br></pre></td></tr></table></figure><p><strong>对其标志flags</strong>：用于控制输出内容的对齐方式</p><ul><li>不填或+：输出的内容右对齐，这是缺省的方式</li><li>-：输出的内容左对齐。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%-12s=\n&quot;</span>,<span class="string">&quot;abc&quot;</span>);    <span class="comment">// 输出=abc         =</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%-12d=\n&quot;</span>,<span class="number">123</span>);     <span class="comment">// 输出=123         =</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%-12f=\n&quot;</span>,<span class="number">123.5</span>);    <span class="comment">// 输出=123.500000  =</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%012s=\n&quot;</span>,<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 输出=         abc=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%012d=\n&quot;</span>,<span class="number">123</span>);   <span class="comment">// 输出=000000000123=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%012f=\n&quot;</span>,<span class="number">123.5</span>);  <span class="comment">// 输出=00123.500000=</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>精度prec</strong>：如果输出的内容是浮点数，它用于控制输出内容的精度，也就是说小数点后面保留多少位，后面的数四舍五入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12.2lf=\n&quot;</span>,<span class="number">123.5</span>);   <span class="comment">// 输出=      123.50=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%.2lf=\n&quot;</span>,<span class="number">123.5</span>);     <span class="comment">// 输出=123.50=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%12.2e=\n&quot;</span>,<span class="number">123500000000.0</span>);  <span class="comment">// 输出=    1.24e+11=</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=%.2e=\n&quot;</span>,<span class="number">123500000000.0</span>);    <span class="comment">// 输出=1.24e+11=</span></span><br></pre></td></tr></table></figure><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[],<span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//int argc，存放了命令行参数的个数。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//char *argv[]，是个字符串的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//char *envp[]，也是一个字符串的数组，这个数组的每一个元素是指向一个环境变量的字符指针。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//envp存放了当前程序运行环境的参数。</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span>；</span></span><br><span class="line"><span class="function"><span class="comment">//malloc的作用是向系统申请一块大小为size的连续内存空间，如果申请失败，函数返回0，如果申请成功，返回成功分配内存块的起始地址。</span></span></span><br><span class="line"><span class="function"><span class="title">malloc</span><span class="params">(<span class="number">100</span>)</span>； <span class="comment">// 申请 100 个字节的临时分配域，返回值为其第一个字节的地址</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"><span class="comment">//free的作用是释放指针p指向的动态内存空间，p是调用malloc函数时返回的地址，free函数无返回值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><ol><li>内存指针变量未初始化</li><li>内存释放后之后指针未置空</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> *pi=&amp;i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pi);</span><br><span class="line">pi=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作文件的时候，C语言为文件分配一个信息区，该信息区包含文件描述信息、缓冲区位置、缓冲区大小、文件读写到的位置等基本信息，这些信息用一个结构体来存放（struct _IO_FILE），这个结构体有一个别名FILE（typedef struct _IO_FILE FILE），FILE结构体和对文件操作的库函数在 stdio.h 头文件中声明的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开文件的时候，fopen函数中会动态分配一个FILE结构体大小的内存空间，并把FILE结构体内存的地址作为函数的返回值，程序中用FILE结构体指针存放这个地址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭文件的时候，fclose函数除了关闭文件，还会释放FILE结构体占用的内存空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FILE结构体指针习惯称为文件指针。</span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode )</span></span>;</span><br><span class="line"><span class="comment">//参数filename 是字符串，表示需要打开的文件名，可以包含目录名，如果不包含路径就表示程序运行的当前目录。实际开发中，采用文件的全路径。</span></span><br><span class="line"><span class="comment">//参数mode也是字符串，表示打开文件的方式（模式），打开方式可以是下列值中的一个。</span></span><br><span class="line"><span class="comment">//r  只读   文件必须存在，否则打开失败</span></span><br><span class="line"><span class="comment">//w  只写  如果文件存在，则清除原文件内容；如果文件不存在，则新建文件。</span></span><br><span class="line"><span class="comment">//a  追加只写   如果文件存在，则打开文件，如果文件不存在，则新建文件。</span></span><br><span class="line"><span class="comment">//r+ 读写文件必须存在。在只读 r 的基础上加 &#x27;+&#x27; 表示增加可写的功能。</span></span><br><span class="line"><span class="comment">//w+    在只写w的方式上增加可读的功能。</span></span><br><span class="line"><span class="comment">//a+ 在追加只写a的方式上增加可读的功能。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意了，不同教材中对文件打开的方式有不同的说法。</span></span><br><span class="line"><span class="comment">有的说打开文本文件的方式要用&quot;rt&quot;、&quot;wt&quot;、&quot;at&quot;、&quot;rt+&quot;、&quot;wt+&quot;、&quot;at+&quot;，&quot;t&quot;是text的简写，&quot;t&quot;可以省略不写。</span></span><br><span class="line"><span class="comment">有的说打开二进制文件的方式要用&quot;rb&quot;、&quot;wb&quot;、&quot;ab&quot;、&quot;rb+&quot;、&quot;wb+&quot;、&quot;ab+&quot;，&quot;b&quot;是binary的简写。</span></span><br><span class="line"><span class="comment">准确的说，在Linux平台下，打开文本文件和二进制文件的方式没有区别。</span></span><br><span class="line"><span class="comment">在windows平台下，如果以“文本”方式打开文件，当读取文件的时候，系统会将所有的&quot;\r\n&quot;转换成&quot;\n&quot;；当写入文件的时候，系统会将&quot;\n&quot;转换成&quot;\r\n&quot;写入， 如果以&quot;二进制&quot;方式打开文件，则读和写都不会进行这样的转换，真是罗嗦。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size, FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fgets的功能是从文件中读取一行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参数buf是一个字符串，用于保存从文件中读到的数据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参数size是打算读取内容的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参数fp是待读取文件的文件指针。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果文件中将要读取的这一行的内容的长度小于size，fgets函数就读取一行，如果这一行的内容大于等于size，fgets函数就读取size-1字节的内容。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">调用fgets函数如果成功的读取到内容，函数返回buf，如果读取错误或文件已结束，返回空，即0。如果fgets返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>二进制文件处理</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line"><span class="comment">//ptr：为内存区块的指针，存放了要写入的数据的地址，它可以是数组、变量、结构体等。</span></span><br><span class="line"><span class="comment">//size：固定填1。</span></span><br><span class="line"><span class="comment">//nmemb：表示打算写入数据的字节数。</span></span><br><span class="line"><span class="comment">//fp：表示文件指针。</span></span><br><span class="line"><span class="comment">//函数的返回值是本次成功写入数据的字节数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">//ptr：用于存放从文件中读取数据的变量地址，它可以是数组、变量、结构体等。</span></span><br><span class="line"><span class="comment">//size：固定填1。</span></span><br><span class="line"><span class="comment">//nmemb：表示打算读取的数据的字节数。</span></span><br><span class="line"><span class="comment">//fp：表示文件指针。</span></span><br><span class="line"><span class="comment">//调用fread函数如果成功的读取到内容，函数返回读取到的内容的字节数，如果读取错误或文件已结束，返回空，即0。如果fread返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ftell函数用来返回当前文件位置指针的值，这个值是当前位置相对于文件开始位置的字节数。</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rewind函数用来将位置指针移动到文件开头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span> <span class="params">( FILE *fp )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fseek() 用来将位置指针移动到任意位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span> <span class="params">( FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> origin )</span></span>;</span><br><span class="line"><span class="comment">//fp 为文件指针，也就是被移动的文件。</span></span><br><span class="line"><span class="comment">//offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。</span></span><br><span class="line"><span class="comment">//origin 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为：0-文件开头；1-当前位置；2-文件末尾。</span></span><br><span class="line"></span><br><span class="line">fseek(fp,<span class="number">100</span>,<span class="number">0</span>);     <span class="comment">// 从文件的开始位置计算，向后移动100字节。</span></span><br><span class="line">fseek(fp,<span class="number">100</span>,<span class="number">1</span>);     <span class="comment">// 从文件的当前位置计算，向后移动100字节。</span></span><br><span class="line">fseek(fp,<span class="number">-100</span>,<span class="number">2</span>);    <span class="comment">// 从文件的尾部位置计算，向前移动100字节。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">当offset是向文件尾方向偏移的时候，无论偏移量是否超出文件尾，fseek都是返回0，当偏移量没有超出文件尾的时候，文件指针式指向正常的偏移地址的，当偏移量超出文件尾的时候，文件指针是指向文件尾的，不会返回偏移出错-1值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当offset是向文件头方向偏移的时候，如果offset没有超出文件头，是正常偏移，文件指针指向正确的偏移地址，fseek返回值为0，当offset超出文件头时，fseek返回出错-1值，文件指针还是处于原来的位置。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件缓冲区"><a href="#文件缓冲区" class="headerlink" title="文件缓冲区"></a>文件缓冲区</h3><p>在操作系统中，存在一个内存缓冲区，当调用fprintf、fwrite等函数往文件写入数据的时候，数据并不会立即写入磁盘文件，而是先写入缓冲区，等缓冲区的数据满了之后才写入文件。还有一种情况就是程序调用了fclose时也会把缓冲区的数据写入文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="标准输入、标准输出、标准错误"><a href="#标准输入、标准输出、标准错误" class="headerlink" title="标准输入、标准输出、标准错误"></a>标准输入、标准输出、标准错误</h3><p>Linux操作系统为每个程序默认打开三个文件，即标准输入stdin、标准输出stdout和标准错误输出stderr，其中0就是stdin，表示输入流，指从键盘输入，1代表stdout，2代表stderr，1,2默认是显示器。</p><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前目录</span></span><br><span class="line"><span class="keyword">char</span> strpwd[<span class="number">301</span>];</span><br><span class="line"><span class="built_in">memset</span>(strpwd,<span class="number">0</span>,<span class="keyword">sizeof</span>(strpwd));</span><br><span class="line">getcwd(strpwd,<span class="number">300</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前目录是：%s\n&quot;</span>,strpwd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//切换工作目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目录的创建和删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取目录中的文件列表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="comment">//打开目录</span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">//读取目录</span></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">//关闭目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目录指针</span></span><br><span class="line">DIR *目录指针名;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每调用一次readdir函数会返回一个struct dirent的地址，存放了本次读取到的内容，它的原理与fgets函数读取文件相同。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">long</span> d_ino;                    <span class="comment">// inode number 索引节点号</span></span><br><span class="line">   <span class="keyword">off_t</span> d_off;                   <span class="comment">// offset to this dirent 在目录文件中的偏移</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;     <span class="comment">// length of this d_name 文件名长</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;         <span class="comment">// the type of d_name 文件类型</span></span><br><span class="line">   <span class="keyword">char</span> d_name [NAME_MAX+<span class="number">1</span>];    <span class="comment">// file name文件名，最长255字符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">time_t</span>;</span><br><span class="line"><span class="keyword">time_t</span> tnow;</span><br><span class="line">tnow =time(<span class="number">0</span>);     <span class="comment">// 将空地址传递给time函数，并将time返回值赋给变量tnow</span></span><br><span class="line">time(&amp;tnow);       <span class="comment">// 将变量tnow的地址作为参数传递给time函数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> tm_sec;     <span class="comment">// 秒：取值区间为[0,59]</span></span><br><span class="line">  <span class="keyword">int</span> tm_min;     <span class="comment">// 分：取值区间为[0,59]</span></span><br><span class="line">  <span class="keyword">int</span> tm_hour;    <span class="comment">// 时：取值区间为[0,23]</span></span><br><span class="line">  <span class="keyword">int</span> tm_mday;    <span class="comment">// 日期：一个月中的日期：取值区间为[1,31]</span></span><br><span class="line">  <span class="keyword">int</span> tm_mon;     <span class="comment">// 月份：（从一月开始，0代表一月），取值区间为[0,11]</span></span><br><span class="line">  <span class="keyword">int</span> tm_year;    <span class="comment">// 年份：其值等于实际年份减去1900</span></span><br><span class="line">  <span class="keyword">int</span> tm_wday;    <span class="comment">// 星期：取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推</span></span><br><span class="line">  <span class="keyword">int</span> tm_yday;    <span class="comment">// 从每年的1月1日开始的天数：取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推</span></span><br><span class="line">  <span class="keyword">int</span> tm_isdst;   <span class="comment">// 夏令时标识符，该字段意义不大，我们不用夏令时。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tm * <span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数用于把struct tm表示的时间转换为time_t表示的时间</span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">mktime</span><span class="params">(struct tm *tm)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usleep</span><span class="params">(<span class="keyword">useconds_t</span> usec)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span>  tv_sec;  <span class="comment">// 1970年1月1日到现在的秒。</span></span><br><span class="line">  <span class="keyword">long</span>  tv_usec; <span class="comment">// 当前秒的微妙，即百万分之一秒。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> tz_minuteswest;  <span class="comment">// 和UTC（格林威治时间）差了多少分钟。</span></span><br><span class="line">  <span class="keyword">int</span> tz_dsttime;      <span class="comment">// type of DST correction，修正参数据，忽略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gettimeofday是获得当前的秒和微秒的时间，其中的秒是指1970年1月1日到现在的秒，微秒是指当前秒已逝去的微秒数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct  timeval *tv, struct  timezone *tz )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><h2 id="编译预处理"><a href="#编译预处理" class="headerlink" title="编译预处理"></a>编译预处理</h2><blockquote><p>C源程序－&gt;编译预处理－&gt;编译－&gt;优化程序－&gt;汇编程序－&gt;链接程序－&gt;可执行文件</p></blockquote><h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><ul><li>包含文件：将源文件中以#include格式包含的文件复制到编译的源文件中，可以是头文件，也可以是其它的程序文件。</li><li>宏定义指令：#define指令定义一个宏，#undef指令删除一个宏定义。</li><li>条件编译：根据#ifdef和#ifndef后面的条件决定需要编译的代码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果使用尖括号&lt;&gt;括起文件名，则编译程序将到C语言开发环境中设置好的 include文件中去找指定的文件（/usr/include）</span></span><br><span class="line"><span class="comment">//#include包含文件，可以是 “.h”,表示C语言程序的头文件，也可以是“.c”,表示包含普通C语言源程序。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;文件名&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;文件名&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名  字符串</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">define 关键字“define”为宏定义命令。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">宏名 是一个标示符，必须符合C语言标示符的规定，一般以大写字母标识宏名。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">字符串 可以是常数，表达式，格式串等。在前面使用的符号常量的定义就是一个无参数宏定义。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.141592</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">宏定义是宏名来表示一个字符串，在宏展开时又以该字符串取代宏名。这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，编译预处理时不会对它进行语法检查，如有错误，只能在编译已被宏展开后的源程序时发现。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层替换。建议不要这么做，会把程序复杂化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 习惯上宏名用大写字母表示，以方便与变量区别。但也可以用小写字母。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带参数的宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名(形参表) 字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y)  ((x)&gt;(y) ? (x) : (y))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">  程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 标识符</span></span><br><span class="line">  程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  程序段 <span class="number">2</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取消已定义的标志符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span></span></span><br></pre></td></tr></table></figure><h2 id="系统错误"><a href="#系统错误" class="headerlink" title="系统错误"></a>系统错误</h2><p>我们在写程序的时候需要调用C语言提供的库函数，并通过函数的返回值判断调用是否成功。其实在C语言中，还有一个全局变量errno，存放了函数调用过程中产生的错误码。</p><p>为防止和正常的返回值混淆，库函数的调用一般并不直接返回错误码，而是将错误码（是一个整数值，不同的值代表不同的含义）存入一个名为 errno 的全局变量中，errno 不同数值所代表的错误消息定义在 &lt;errno.h&gt; 文件中。如果库函数调用失败，可以通过读出 errno 的值来确定问题所在，推测程序出错的原因，这也是调试程序的一个重要方法。</p><p>配合 strerror和perror两个库函数，可以很方便地查看出错的详细信息。</p><p>strerror 在 &lt;string.h&gt; 中声明，用于获取错误码对应的消息描述。</p><p>perror 在 &lt;stdio.h&gt; 中声明，用于在屏幕上最近一次系统错误码消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errno)</span></span>;</span><br><span class="line"><span class="comment">//strerror()用来依参数errno 的错误代码来查询其错误原因的描述字符串，然后将该字符串指针返回。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://freecplus.net/3e27bfb1a810493d9a0550131e2a1633.html">https://freecplus.net/3e27bfb1a810493d9a0550131e2a1633.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    <category term="程序语言" scheme="http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="http://shjlone.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（红黑树）</title>
    <link href="http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2021-06-07T01:45:07.565Z</published>
    <updated>2021-06-07T01:45:07.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>红黑树是一种自平衡二叉查找树，它可以在 O($\log(n)$ ) 时间内完成查找、插入和删除，这里的n是树中元素的数目。</p><p>红黑树是每个节点都带有颜色属性的<strong>二叉查找树</strong>，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求： </p><ol><li>节点是红色或黑色。</li><li>根节点是黑色。</li><li>每个叶子节点都是黑色的空节点（NIL节点）。</li><li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ol><p><img src="./red_black_tree_1.png"></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量（O($\log(n)$)的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为 O ($\log(n)$)次。</p><p><strong>左旋转</strong></p><p>逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。下图中身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。</p><p><img src="./red_black_tree_2.png"></p><p><strong>右旋转</strong></p><p>顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。下图中身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。</p><p><img src="./red_black_tree_3.png"></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>JDK的集合类TreeMap、TreeSet、HashMap</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cxyxiaowu.com/3173.html">https://www.cxyxiaowu.com/3173.html</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;红黑树是一种自平衡二叉查找树，它可以在 O($\log(n)$ ) 时间内完成查找、插入和删除，这里的n是树中元素的数目。&lt;/p&gt;
&lt;p&gt;红</summary>
      
    
    
    
    <category term="数据结构" scheme="http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法 数据结构" scheme="http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（线性表）</title>
    <link href="http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2021-06-07T01:45:07.565Z</published>
    <updated>2021-06-07T01:45:07.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>线性表（Linear List）是具有相同特性的数据元素的一个有限序列。该序列中所含元素的个数叫做线性表的长度，用n表示，n&gt;=0。当n=0时，表示线性表是一个<br>空表。设序列中第i个元素为a<sub>1</sub>（1 ≤ i ≤ n），则线性表的一般表示为：</p><p>(a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>i</sub>,…,a<sub>n</sub>)</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>元素在位置上是有序的</li><li>长度是可变的</li></ul><h2 id="线性存储"><a href="#线性存储" class="headerlink" title="线性存储"></a>线性存储</h2><p>将数据依次存储在连续的整块物理空间中。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。</p><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系。</p><p>在线性表的链接存储中，存储的第一个元素的结点称为<strong>表头结点</strong>，存储最后一个元素的结点称为<strong>表尾结点</strong>，其余为中间结点。每个链接表都需要设置<br>一个指针指向表头结点，称为<strong>表头指针</strong>。从表头指针出发，沿着结点的链可以访问到每一个结点。</p><p>链接表由于每个结点带有指针域，因而在存储空间上比线性存储要付出较大代价。由于每个结点的存储位置可以任意安排，因此插入、删除操作方便又省时。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><img src="./list_1.png"></p><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p><img src="./list_2.png"></p><h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>尾结点的下一个结点是头结点。</p><br/><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;线性表（Linear List）是具有相同特性的数据元素的一个有限序列。该序列中所含元素的个数叫做线性表的长度，用n表示，n&amp;gt;=0。当</summary>
      
    
    
    
    <category term="数据结构" scheme="http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法 数据结构" scheme="http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://shjlone.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-06-07T01:45:07.565Z</published>
    <updated>2021-06-07T01:45:07.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数重载（Function-Overloading）"><a href="#函数重载（Function-Overloading）" class="headerlink" title="函数重载（Function Overloading）"></a>函数重载（Function Overloading）</h2><p><strong>定义</strong>：函数名相同，函数的参数列表包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析XML字符串的函数族，支持int、char *和double三种类型。</span></span><br><span class="line"><span class="comment">// 返回值：0-成功，-1-失败。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in_XMLBuffer,<span class="keyword">const</span> <span class="keyword">char</span> *in_FieldName,<span class="keyword">int</span> *out_Value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in_XMLBuffer,<span class="keyword">const</span> <span class="keyword">char</span> *in_FieldName,<span class="keyword">char</span> *out_Value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in_XMLBuffer,<span class="keyword">const</span> <span class="keyword">char</span> *in_FieldName,<span class="keyword">double</span> *out_Value)</span></span>;</span><br></pre></td></tr></table></figure><p>C++编译器在编译的时候会根据参数列表的类型对函数进行重命名，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetXMLBuffer_char_char_int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in_XMLBuffer,<span class="keyword">const</span> <span class="keyword">char</span> *in_FieldName,<span class="keyword">int</span> *out_Value)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="结构体新特征"><a href="#结构体新特征" class="headerlink" title="结构体新特征"></a>结构体新特征</h2><p>在C++中，结构体的成员可以有函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age;          <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> height;       <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">    <span class="keyword">char</span> sc[<span class="number">30</span>];       <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">    <span class="keyword">char</span> yz[<span class="number">30</span>];       <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">()</span></span>;       <span class="comment">// 声明结构体成员函数show，用于显示其它成员变量的值。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    st_girl stgirl;      <span class="comment">// struct关键定可以不书写</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirl, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stgirl));</span><br><span class="line">    <span class="built_in">strcpy</span>(stgirl.name, <span class="string">&quot;西施&quot;</span>);</span><br><span class="line">    stgirl.age = <span class="number">22</span>;</span><br><span class="line">    stgirl.height = <span class="number">168</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(stgirl.sc, <span class="string">&quot;火辣&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(stgirl.yz, <span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stgirl.<span class="built_in">show</span>();  <span class="comment">// 调用结构体的成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">st_girl::show</span><span class="params">()</span>   <span class="comment">// 结构体st_girl成员函数的定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name=%s,age=%d,height=%d,sc=%s,yz=%s\n&quot;</span>, name, age, height, sc, yz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类详解"><a href="#类详解" class="headerlink" title="类详解"></a>类详解</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ol><li>构造函数必须是 public 属性。</li><li>构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许。</li><li>构造函数可以有参数，允许重载。一个类可以有多个重载的构造函数，创建对象时根据传递的参数来判断调用哪一个构造函数。</li><li>构造函数在实际开发中会大量使用，它往往用来做一些初始化工作，对成员变量进行初始化等，注意，不能用memset对整个类进行初始化。</li></ol><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ol><li>析构函数必须是 public 属性的。</li><li>析构函数没有参数。</li><li>析构函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许。</li><li>析构函数不允许重载的。一个类只能有一个析构函数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFile</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  FILE *m_fp;        <span class="comment">// 文件指针</span></span><br><span class="line">  <span class="keyword">bool</span>  m_bEnBuffer; <span class="comment">// 是否启用缓冲区，true-启用；false-不启用</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CFile</span>();   <span class="comment">// 类的构造函数</span></span><br><span class="line">  <span class="built_in">CFile</span>(<span class="keyword">bool</span> bEnBuffer);   <span class="comment">// 类的构造函数</span></span><br><span class="line"> </span><br><span class="line"> ~<span class="built_in">CFile</span>();   <span class="comment">// 类的析构函数</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">EnBuffer</span><span class="params">(<span class="keyword">bool</span> bEnBuffer=<span class="literal">true</span>)</span></span>;  <span class="comment">// 启、禁用缓冲区</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 打开文件，参数与fopen相同，打开成功true，失败返回false         </span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,<span class="keyword">const</span> <span class="keyword">char</span> *openmode)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 调用fprintf向文件写入数据</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Fprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ... )</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 调用fgets从文件中读取一行</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Fgets</span><span class="params">(<span class="keyword">char</span> *strBuffer,<span class="keyword">const</span> <span class="keyword">int</span> ReadSize)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 关闭文件指针</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现文件</span></span><br><span class="line"></span><br><span class="line">CFile::<span class="built_in">CFile</span>()   <span class="comment">// 类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">  m_fp=<span class="number">0</span>;</span><br><span class="line">  m_bEnBuffer=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFile::<span class="built_in">CFile</span>(<span class="keyword">bool</span> bEnBuffer)   <span class="comment">// 类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">  m_fp=<span class="number">0</span>;</span><br><span class="line">  m_bEnBuffer=bEnBuffer; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFile::~<span class="built_in">CFile</span>()   <span class="comment">// 类的析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">Close</span>();  <span class="comment">// 调用Close释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h2><p>引用就是变量的别名，对引用的操作与对变量直接操作完全一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据类型 &amp;引用名=目标变量名；</span></span><br><span class="line"><span class="keyword">int</span> ii;</span><br><span class="line"><span class="keyword">int</span> &amp;rii=ii;  <span class="comment">// 定义引用rii，它是变量ii的引用，即别名。</span></span><br><span class="line">rii=<span class="number">1</span>;  等价于  ii=<span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>&amp;在此不是求地址运算，而是声明引用。</li><li>数据类型可以是C语言的基本数据类型，也可以是结构体和类等构造类型。</li><li>引用在声明的时候必须对其进行初始化（指向目标变量名），否则编译器会报错。</li><li>引用初始化之后，不能再用作其他变量名的别名。</li><li>引用声明后，相当于目标变量名有两个名称。</li><li>不能建立数组的引用，因为数组是多个变量的集合。</li><li>引用可以用const修饰，表示只读，用这种方式声明的引用，不能通过引用名对目标变量的值进行修改。</li></ol><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>   </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGirl</span>    // 定义类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> CGirl &amp;Girl);  <span class="comment">// 重载==运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CGirl Girl1,Girl2;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">strcpy</span>(Girl1.m_name,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(Girl2.m_name,<span class="string">&quot;东施&quot;</span>);</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span> (Girl1 == Girl2) <span class="built_in">printf</span>(<span class="string">&quot;Girl1和Girl2是同一个人。\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Girl1和Girl2不是同一个人。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> CGirl::<span class="keyword">operator</span>==(<span class="keyword">const</span> CGirl &amp;Girl)  <span class="comment">// 重载==运算符</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果两个类的姓名相同，就相等</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(m_name,Girl.m_name)== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string是一个模板类，位于std命名空间内，为方便使用还需要在程序中增加：</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  <span class="comment">// 指定缺省的使名空间。</span></span><br><span class="line"><span class="built_in">string</span> str;       <span class="comment">// 创建string对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不指定命名空间</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span></span>;<span class="comment">//c_str函数返回这个字符串的地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;             <span class="comment">// 返回当前字符串的大小。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;           <span class="comment">// 返回当前字符串的长度，注意和size的区别。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;           <span class="comment">// 清空字符串。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="vector类"><a href="#vector类" class="headerlink" title="vector类"></a>vector类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span>：返回容器头的指针，指向容器第一个元素的位置。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span>：返回容器尾的指针，指向容器最后一个元素的下一个位置。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span>：向容器的尾部增加一个元素x。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="keyword">const</span> T&amp; x)</span>：向容器中指定位置（it）前插入一个元素x。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span>：删除容器中指定位置（it）的元素。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span>：判断容器是否为空。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>：返回容器中元素的个数。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">sort</span><span class="params">(begin,end,cmp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">sort函数包含在头文件为#include &lt;algorithm&gt;的c++标准库中，调用排序方法不必知道其内部是如何实现的，只要出现我们想要的结果就行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sort函数有三个参数：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">（1）第一个是要排序的数组的起始地址。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">（2）第二个是结束的地址。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时缺省的排序方法是从小到大排序。如果vector容器中元素的数据类型不是基本数据类型，sort函数必须指定排序方法函数。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C-动态内存"><a href="#C-动态内存" class="headerlink" title="C++动态内存"></a>C++动态内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">datatype *pointer = <span class="keyword">new</span> datatype;</span><br><span class="line">  <span class="comment">//  其它代码</span></span><br><span class="line"><span class="keyword">delete</span> pointer;</span><br><span class="line"><span class="comment">//datatype可以是C语言的基本数据类型，也可以是结构体，还可以是类。</span></span><br><span class="line"><span class="comment">//pointer是一个指针，指向new返回的地址。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi= <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">// 动态分配一个整数大小的内存</span></span><br><span class="line">(*pi)=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> pi;  <span class="comment">// 释放pi指向的内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="继承和派生"><a href="#继承和派生" class="headerlink" title="继承和派生"></a>继承和派生</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;</span>派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 派生类类体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGirl</span>    // 定义超女类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CKCon</span>:</span><span class="keyword">public</span> CGirl   <span class="comment">// 定义王妃类，从超女类继承</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种方式，当使用不同类型的继承时，遵循以下几个规则：</p><ol><li>公有继承（public）：当类派生以public方式继承时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</li><li>保护继承（protected）： 当类派生以protected方式继承时，基类的公有和保护成员将成为派生类的保护成员。</li><li>私有继承（private）：当类派生以private方式继承时，基类的公有和保护成员将成为派生类的私有成员。</li></ol><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGirl</span>    // 定义超女类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> m_age;       <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">int</span> m_height;    <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">    <span class="keyword">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">    <span class="keyword">char</span> m_yz[<span class="number">30</span>];    <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Show</span><span class="params">()</span>       <span class="comment">// 显示超女基本信息的成员函数体</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;CGirl 姓名：%s，年龄：%d，身高：%d，身材：%s，颜值：%s\n&quot;</span>, m_name, m_age, m_height, m_sc, m_yz); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CKCon</span> :</span> <span class="keyword">public</span> CGirl   <span class="comment">// 定义王妃类，从超女类继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> m_ch[<span class="number">50</span>];      <span class="comment">// 称号</span></span><br><span class="line">    <span class="keyword">char</span> m_palace[<span class="number">50</span>];  <span class="comment">// 居住的宫殿</span></span><br><span class="line">    <span class="keyword">int</span> m_sal;         <span class="comment">// 奉禄</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Show</span><span class="params">()</span>     <span class="comment">// 显示王妃的称号、宫殿和奉禄</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;CKCon 姓名：%s，称号：%s，栖：%s，奉禄：%d两银子。\n&quot;</span>, m_name, m_ch, m_palace, m_sal); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CKCon KCon;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(KCon.m_name, <span class="string">&quot;杨玉环&quot;</span>);</span><br><span class="line">    KCon.m_age = <span class="number">28</span>;</span><br><span class="line">    KCon.m_height = <span class="number">168</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(KCon.m_sc, <span class="string">&quot;火辣&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(KCon.m_yz, <span class="string">&quot;漂亮&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(KCon.m_ch, <span class="string">&quot;杨贵妃&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(KCon.m_palace, <span class="string">&quot;华清宫&quot;</span>);</span><br><span class="line">    KCon.m_sal = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    CGirl *pGirl;   <span class="comment">// 基类的指针</span></span><br><span class="line">    CKCon *pCon;   <span class="comment">// 派生类的指针</span></span><br><span class="line"></span><br><span class="line">    pGirl = pCon = &amp;KCon;  <span class="comment">// 都指向派生类</span></span><br><span class="line"></span><br><span class="line">    pGirl-&gt;Show();   <span class="comment">// 将调用的是基类的Show方法</span></span><br><span class="line">    pCon-&gt;Show();    <span class="comment">// 将调用的是派生类的Show方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>动态多态</strong></p><p>动态多态是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。在CGirl类中，Show方法的声明前放置关键字 virtual，则pGirl-&gt;Show()会打印出CKCon中的show方法内容。</p><p><strong>虚函数</strong></p><p>虚函数是在基类中使用关键字 virtual 声明的函数，在派生类中重新定义虚函数。我们想要的是在程序中可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。</p><p><strong>纯虚函数</strong></p><p>只声明，具体实现在派生类中实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGirl</span>    // 定义超女类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">char</span> m_name[<span class="number">50</span>];  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">int</span>  m_age;       <span class="comment">// 年龄</span></span><br><span class="line">  <span class="keyword">int</span>  m_height;    <span class="comment">// 身高，单位：厘米cm</span></span><br><span class="line">  <span class="keyword">char</span> m_sc[<span class="number">30</span>];    <span class="comment">// 身材，火辣；普通；飞机场。</span></span><br><span class="line">  <span class="keyword">char</span> m_yz[<span class="number">30</span>];    <span class="comment">// 颜值，漂亮；一般；歪瓜裂枣。</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Show</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">// 申明一个纯虚函数。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数重载（Function-Overloading）&quot;&gt;&lt;a href=&quot;#函数重载（Function-Overloading）&quot; class=&quot;headerlink&quot; title=&quot;函数重载（Function Overloading）&quot;&gt;&lt;/a&gt;函数重载（Fun</summary>
      
    
    
    
    <category term="程序语言" scheme="http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="http://shjlone.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="http://shjlone.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（树）</title>
    <link href="http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    <id>http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</id>
    <published>2021-06-07T01:45:07.564Z</published>
    <updated>2021-06-07T01:45:07.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><br/><p>树是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><ul><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li></ul><h3 id="树的术语"><a href="#树的术语" class="headerlink" title="树的术语"></a>树的术语</h3><br/><ul><li><strong>节点的度：</strong>一个节点含有的子树的个数称为该节点的度；</li><li><strong>树的度：</strong>一棵树中，最大的节点的度称为树的度；</li><li><strong>叶节点或终端节点：</strong>度为零的节点；</li><li><strong>父亲节点或父节点：</strong>若一个节点含有子节点，则这个节点称为其子节点的父节点；</li><li><strong>孩子节点或子节点：</strong>一个节点含有的子树的根节点称为该节点的子节点；</li><li><strong>兄弟节点：</strong>具有相同父节点的节点互称为兄弟节点；</li><li><strong>节点的层次：</strong>从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li><li><strong>树的高度或深度：</strong>树中节点的最大层次；</li><li><strong>堂兄弟节点：</strong>父节点在同一层的节点互为堂兄弟；</li><li><strong>节点的祖先：</strong>从根到该节点所经分支上的所有节点；</li><li><strong>子孙：</strong>以某节点为根的子树中任一节点都称为该节点的子孙。</li><li><strong>森林：</strong>由m（m ≥ 0）棵互不相交的树的集合称为森林；</li></ul><h3 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h3><br/><ul><li><p><strong>无序树：</strong></p><p>  树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树</p></li><li><p><strong>有序树</strong></p><p>  树中任意节点的子节点之间有顺序关系，这种树称为有序树</p></li><li><p><strong>二叉树：</strong>每个节点最多含有两个子树的树称为二叉树</p><ul><li><strong>完全二叉树：</strong>对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;</li><li><strong>平衡二叉树：</strong>当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li><li><strong>排序二叉树：</strong></li></ul></li><li><p><strong>霍夫曼树（用于信息编码）：</strong>带权路径最短的二叉树称为哈夫曼树或最优二叉树；</p></li><li><p><strong>B树：</strong>一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。</p></li></ul><h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><ol><li>树中的节点数等于所有节点的度数加1。</li><li>度为k的树中第i层上至多有k<sup>i-1</sup>个节点（i ≥ 1）。</li><li>深度为h的k叉树至多有个节点 $\frac{k^{h}-1}{h-1}$ 个节点。</li><li>具有n个节点的k叉树的最小深度为 ⌈$\log_{k} (n(k-1)+1)$⌉</li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><br/><p>二叉树（Binary Tree）是指树的度为2的有序树。每个节点的左子树的根节点称为左孩子（left child），右子树的根节点称为右孩子（right child）。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><br/><ol><li>二叉树上终端节点数等于双分支节点数加1。</li><li>二叉树上第i层至多有2<sup>i-1</sup>个节点（i ≥ 1）。</li><li>深度为h的二叉树至多有2<sup>h-1</sup>个节点。</li><li>对<strong>完全二叉树</strong>中编号为i的节点（1 ≤ i ≤ n， n ≥ 1，n为节点数 ）有：<ol><li>若i ≤ ⌊n/2⌋，即2i ≤ n，则编号为i的节点为分支节点，否则为叶子节点。</li><li>若n为奇数，则每个分支节点都既有左孩子，又有右孩子；若n为偶数，则编号最大的分支节点（编号为n/2）只有左孩子，没有右孩子，其余分支节点左、右孩子都有。</li><li>若编号为i的节点右左孩子，则左孩子节点的编号为2i；若编号为i的节点有右孩子，则右孩子节点的编号为2i+1。</li><li>除树根节点外，若一个节点的编号为i，则他的双亲节点的编号为 ⌊i/2⌋，也就是说，当i为偶数时，其双亲节点的编号为i/2，它时双亲节点的左孩子，<br>当i为奇数时，其双亲节点的编号为(i-1)/2，它是双亲节点的右孩子。</li></ol></li><li>具有n个（n &gt; 0）节点的完全二叉树的深度为⌈$\log_{2} (n+1)$⌉或⌊$\log_{2} n$⌋+1。</li></ol><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><br/><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><br/><p>遍历二叉树的问题可以分为：</p><ul><li>访问根节点</li><li>遍历左子树</li><li>遍历右子树</li></ul><p>遍历方式分为：DLR、LDR、LRD、DRL、RDL、RLD。</p><p>前序遍历算法</p><p>中序遍历算法</p><p>后续遍历算法</p><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h4 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h4><p>对二叉树进行某种遍历得到的节点序列，可以看做一个线性表，在该线性表中，除第一个节点外，每个节点有且仅有一个前驱，除最后一个节点外，每个节点<br>有且仅有一个后继。为了同节点在二叉树中具有的前驱（即双亲）和后继（即孩子）区别开来，在容易混淆的地方，我们通常把序列中节点的前驱或后继冠以<br>某种遍历的名称，如把中序序列中节点的前驱称做中序前驱，节点的后继称做中序后继。</p><p>对于一颗具有n个节点的二叉树，对应的二叉链表中共有2n个指针域，其中n-1个用于指向除树根节点的其余n-1个节点，另有n+1个指针域空着。若把每个节点<br>中空着的左指针域和右指针域用于分别指向某种遍历次序的前驱节点和后继节点，则在遍历这种二叉树时，可由此信息直接找到在该遍历次序下的前驱节点或<br>后继节点，从而比递归遍历提高了遍历速度和节省了建立系统栈所使用的存储空间。这种在节点的空指针域中存放的该节点在某次遍历次序下的前驱节点或后继<br>节点的指针叫做线索，其中在空的左指针域中存放的指向其前驱节点的指针叫做<strong>左线索</strong>或<strong>前驱线索</strong>，在空的右指针域中存放的指向其后继节点的指针叫<br>做<strong>右线索</strong>或<strong>后继线索</strong>。对一颗二叉树中的所有节点的空指针域按照某种遍历次序加线索的过程叫做<strong>线索化</strong>，被线索化了的二叉树叫做<strong>线索二叉树</strong>。</p><p><img src="./tree_1.png"></p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>二叉排序树（Binary Sort Tree）又称为二叉查找树（Binary Search Tree），它或者是一颗空树，或者是一颗具有如下特征的非空二叉树：</p><ol><li>若它的左子树非空，则左子树上所有节点的关键字小于根节点的关键字；</li><li>若它的右子树非空，则右子树上所有节点的关键字均大于（若允许具有相同的关键字的节点存在，则大于等于）根节点的关键字；</li><li>左、右子树本身又是二叉排序树。</li></ol><h4 id="查找和插入"><a href="#查找和插入" class="headerlink" title="查找和插入"></a>查找和插入</h4><p>当二叉查找树不为空时：</p><ul><li>首先将给定值与根节点的关键字比较，若相等，则查找成功</li><li>若小于根节点的关键字值，递归查左子树</li><li>若大于根节点的关键字值，递归查右子树</li><li>若子树为空，查找不成功</li></ul><p>二叉排序树是一种动态树表。其特点是：树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的节点时再进行插入。新插入的节点一定是一个新添加的叶子节点，并且是查找不成功时查找路径上访问的最后一个节点的左孩子或右孩子节点。如下图所示： </p><p><img src="./tree_2.png"></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>二叉查找树的删除操作分为三种情况：</p><ol><li>如果待删除的节点是叶子节点，那么可以立即被删除，如下图所示： </li></ol><p><img src="./tree_3.png"></p><ol start="2"><li>如果节点只有一个儿子，则将此节点parent的指针指向此节点的儿子，然后删除节点，如下图所示：</li></ol><p><img src="./tree_4.png"></p><ol start="3"><li>如果节点有两个儿子，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除，如下图所示：</li></ol><p><img src="./tree_5.png"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://pegasuswang.github.io/python_data_structures_and_algorithms/17_%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/binary_search_tree/">https://pegasuswang.github.io/python_data_structures_and_algorithms/17_%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/binary_search_tree/</a></li></ul><br/><h3 id="哈夫曼树（最优二叉树）"><a href="#哈夫曼树（最优二叉树）" class="headerlink" title="哈夫曼树（最优二叉树）"></a>哈夫曼树（最优二叉树）</h3><ol><li>路径和路径长度</li></ol><p>若在一颗树中存在着一个节点序列k<sub>1</sub>，k<sub>2</sub>，….k<sub>j</sub>，使得k<sub>j</sub>是k<sub>j+1</sub>的双亲（1 ≤ i &lt; j），<br>则称此节点序列是从k<sub>1</sub>～k<sub>j</sub>的<strong>路径</strong>，因树中每个节点只有一个双亲节点，所以它也是这两个节点之间的唯一路径。从k<sub>1</sub>～k<sub>j</sub><br>所经过的分支数称为这两点之间的<strong>路径长度</strong>，它等于路径上的节点数减1。</p><p><img src="./tree_6.png"></p><ol start="2"><li>节点的权和带权路径长度</li></ol><p>在许多应用中，常常将树中的节点赋上一个有着某种意义的实数，我们称此实数为该<strong>节点的权</strong>。节点的<strong>带权路径长度</strong>规定为从树根节点到该节点之间的路径长度<br>于该节点上权的乘积。</p><p><img src="./tree_7.png"></p><ol start="3"><li>树的带权路径长度</li></ol><p>树的<strong>带权路径长度</strong>定义为树中所有叶子节点的带权路径长度之和，通常记为：</p><p>$\sum_{i=1}^n {w_{i}}l_{i}$</p><p>其中n表示叶子节点的数目，w<sub>i</sub>和l<sub>i</sub>分别表示叶子节点k<sub>i</sub>的权值和根到k<sub>i</sub>之间的路径长度。</p><ol start="4"><li>哈夫曼树</li></ol><p>哈夫曼树（Huffman）树又称最优二叉树。它是n个带权叶子节点构成的所有二叉树中，带权路径长度WPL最小的二叉树。</p><h4 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h4><ol><li>根据给定的n个权值{w1,w2,…,wn}构成二叉树集合F={T1,T2,…,Tn},其中每棵二叉树Ti中只有一个带权为wi的根节点,其左右子树为空。</li><li>在F中选取两棵根节点权值最小的树作为左右子树构造一棵新的二叉树,且置新的二叉树的根节点的权值为左右子树根节点的权值之和。</li><li>在F中删除这两棵树,同时将新的二叉树加入F中。</li><li>重复2、3,直到F只含有一棵树为止.(得到哈夫曼树)。</li></ol><h3 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h3><p>二叉搜索树中，每一个节点的左右子树深度差的绝对值不大于1。</p><p><img src="./tree_8.png"></p><p>(a）所示为 AVL 树，而（b）所示则不是 AVL 树。</p><p>那么，如何判断一棵树是否符合 AVL 树的性质？答案就是维护每个节点的平衡因子。每个节点的平衡因子即为节点左子树的深度减去右子树的深度得到的差。在符合 AVL 性质的情况下，平衡因子只能取 -1、0、1。</p><p>正因为这样，在插入或删除一个节点之后，要从插入或删除的位置沿通向根的路径回溯，更新这些经过的节点的平衡因子。在检测到当前节点的平衡因子的绝对值大于1时，停止回溯，根据回溯路径中当前节点以及当前节点深度+1 和深度+2 两层节点的位置，选择旋转方法对二叉树的结构进行调整。</p><p>如果一棵平衡二叉树中的节点发生了变化，使二叉树不再平衡，此时需要采用平衡化旋转来调整树的结构，使得在不破坏二叉搜索树性质的情况下，让二叉树重新达到平衡。</p><p>平衡化旋转分为两种：单向旋转和双向旋转。如果回溯路径中当前节点以及下两层节点处于一条直线上，就可以采用单向旋转。如果在下两层的节点中，每一个节点都是父亲节点的右孩子，那么如图 3 所示，此时采用单向左旋。</p><p><img src="./tree_9.png"></p><p>由于此处 A&lt;B&lt;C，所以左旋后并不破坏二叉搜索树的性质，而刚好使得平衡因子恢复到符合 AVL 树性质的大小。</p><p>这样的过程同样可以用图来展示。举例来说，在图 4 这样一棵平衡二叉树中插入节点后，整棵树就变得不平衡了。每个节点上方的数字就是该节点的平衡因子，而长方形代表子树，长方形里面的式子等于它的深度。 </p><p><img src="./tree_10.png"></p><p>要想调整二叉树的结构，这里就要用到平衡左旋了。我们取每一棵子树的根节点来代表这一整棵子树，用一共 5 个节点来演示单向左旋的过程。图 5 所示就是单向左旋的效果。</p><p><img src="./tree_11.png"></p><p>平衡树的结构最后被调整成了图 6 所示这样，而平衡因子也重新变得符合 AVL 树性质了。 </p><p><img src="./tree_12.png"></p><p>同样的道理，如果需要进行平衡旋转时，当前节点的下两层节点都是父节点的左孩子，那么就需要采用单向右旋。单向右旋的道理和单向左旋非常相似，下面就主要用图来演示，不多做讲解了。单向右旋的过程如图 7～图 9 所示。</p><p><img src="./tree_13.png"></p><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.cxyxiaowu.com/1663.html">https://www.cxyxiaowu.com/1663.html</a></li></ul><br/>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;br/&gt;

&lt;p&gt;树是由n（n&amp;gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上</summary>
      
    
    
    
    <category term="数据结构" scheme="http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法 数据结构" scheme="http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（稀疏矩阵和广义表）</title>
    <link href="http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
    <id>http://shjlone.github.io/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</id>
    <published>2021-06-07T01:45:07.564Z</published>
    <updated>2021-06-07T01:45:07.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>矩阵是一个具有m行 x n列的数表，共包含m x n个数（元素），每个元素处在确定行和列的交点位置上，都与一对行号和列号唯一对应。<br>当一个矩阵中的行数和列数相同时，即m = n时则称为n阶矩阵或方阵。</p><p><img src="./matrix_1.png"></p><p><strong>稀疏矩阵（SparseMatrix）</strong>是矩阵中的一种特殊情况，其非零元素的个数小于零元素的个数。</p><p>对于稀疏矩阵中的每个非零元素，可用它所在的行号、列号以及元素这三元组（i，j，a<sub>ij</sub>）来表示。若把所有的三元组按照行号为主序（即主关键字）、<br>列号为辅序（次关键字）进行排序，就构成一个表示稀疏矩阵的三元组线性表。</p><p>((1,1,3),(1,4,5),(2,3,-2),(3,1,1),(3,3,4),(3,5,6),(5,3,-1))</p><h3 id="稀疏矩阵的存储结构"><a href="#稀疏矩阵的存储结构" class="headerlink" title="稀疏矩阵的存储结构"></a>稀疏矩阵的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><ol><li><p>带行指针向量的链接存储</p><p> 在这种链接存储中，需要把具有相同行号的三元组结点按照列号从小到大的顺序链接成一个单链表，每个三元组结点的类型可定义为：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TripleNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.row = <span class="number">0</span></span><br><span class="line">        self.col = <span class="number">0</span></span><br><span class="line">        self.val = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 指向同一行的下一个结点</span></span><br></pre></td></tr></table></figure><p>稀疏矩阵中的每一行对应一个单链表，每一个单链表都有一个表头指针，为了把它们保存起来，便于访问每一个单链表，需要一个行指针向量，该向量中的第i<br>个分量用来存储稀疏矩阵中的第i行所对应的单链表的表头指针。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LMatrix</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.m = <span class="number">0</span></span><br><span class="line">        self.n = <span class="number">0</span></span><br><span class="line">        self.t = <span class="number">0</span>  <span class="comment"># 非零元素的个数</span></span><br><span class="line">        self.vector = []</span><br></pre></td></tr></table></figure><p><img src="./matrix_2.png"></p><ol start="2"><li>十字链接存储</li></ol><p>既带行指针向量又带列指针向量的链接存储。在这种链接存储中，每个三元组结点既处于同一行的单链表中，又处于同一列的单链表中，即处于所在的行单链表<br>和列单链表的交点处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrossNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.row = <span class="number">0</span></span><br><span class="line">        self.col = <span class="number">0</span></span><br><span class="line">        self.val = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span>  <span class="comment"># 存储指向同一行下一个结点的指针</span></span><br><span class="line">        self.down = <span class="literal">None</span>  <span class="comment"># 存储同一列下一个结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLMatrix</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.m = <span class="number">0</span></span><br><span class="line">        self.n = <span class="number">0</span></span><br><span class="line">        self.t = <span class="number">0</span></span><br><span class="line">        self.rv = []  <span class="comment"># 行向量指针，存储行单链表的表头指针</span></span><br><span class="line">        self.cv = []  <span class="comment"># 列向量指针，存储列单链表的表头指针</span></span><br></pre></td></tr></table></figure><p><img src="./matrix_3.png"></p><br/><h3 id="广义表-Generalized-List"><a href="#广义表-Generalized-List" class="headerlink" title="广义表(Generalized List)"></a>广义表(Generalized List)</h3><p>一个广义表是n（n ≥ 0）个元素的一个序列，当n = 0时则称为空表。在一个非空的广义表中，其元素可以是某一确定类型的对象（这种元素被称为单元素），<br>也可以是由单元素构成的表（这种元素可相对的被称为子表或表元素）。显然，广义表的定义是递归的。</p><p>设a<sub>i</sub>为广义表的第i个元素，则广义表的一般表示与线性表相同：</p><p>(a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>i</sub>,…,a<sub>n</sub>)</p><p>其中n表示广义表的<strong>长度</strong>，即广义表中所含元素的个数，n ≥ 0。</p><p><strong>深度</strong>：表中括号的最大层数</p><p><strong>表示方式</strong></p><p>用小写字母表示单元素，用大写字母表示表</p><p>A = ()<br>A是空表，长度为0，深度为1。</p><p>B = (e)<br>B是长度为1的广义表，深度为1。线性表。</p><p>C = (a, (b,c,d))<br>C是长度为2的广义表，深度为2。</p><p>D = (A, B, C) = ((), (e), (a, (b, c, d)))<br>D是长度为3的广义表，深度为3。A、B、C为子表。</p><p>E = ((a, (a,b), ((a,b), c)))</p><p>用圆圈和方框分别表示表和单元素，并用线段把表和它的元素连接起来，则可得到一个广义表的图形表示。</p><p><img src="./matrix_4.png"></p><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">ADT GList&#123;</span><br><span class="line"></span><br><span class="line">数据对象： D=&#123;ei | i=1,2,...,n; n&gt;0; ei∈AtomSet 或ei∈GList,</span><br><span class="line">          AtomSet为某个数据对象 &#125;</span><br><span class="line"></span><br><span class="line">数据关系： R1=&#123;&lt;ei-1,ei&gt; | ei-1,ei∈D, 2&lt;=i&lt;=n&#125;</span><br><span class="line"></span><br><span class="line">基本操作：</span><br><span class="line"></span><br><span class="line">InitGList(&amp;L);</span><br><span class="line">  操作结果： 创建空的广义表L。</span><br><span class="line"></span><br><span class="line">CreateGList(&amp;L, S);</span><br><span class="line">  初始条件： S是广义表的书写形式串。</span><br><span class="line">  操作结果： 由S创建广义表L。</span><br><span class="line"></span><br><span class="line">DestroyGList(&amp;L);</span><br><span class="line">  初始条件： 广义表L存在</span><br><span class="line">  操作结果： 销毁广义表L。</span><br><span class="line"></span><br><span class="line">CopyGList(&amp;T, L);</span><br><span class="line">  初始条件： 广义表L存在</span><br><span class="line">  操作结果： 由广义表L复制得到广义表T。</span><br><span class="line"></span><br><span class="line">GListLength(L);</span><br><span class="line">  初始条件： 广义表L存在</span><br><span class="line">  操作结果： 求广义表L的长度</span><br><span class="line"></span><br><span class="line">GListenDepth(L);</span><br><span class="line">  初始条件： 广义表L存在</span><br><span class="line">  操作结果： 求广义表L的深度</span><br><span class="line"></span><br><span class="line">GListEmpty(L);</span><br><span class="line">  初始条件： 广义表L存在</span><br><span class="line">  操作结果： 判定广义表L是否为空</span><br><span class="line"></span><br><span class="line">GetHead(L);</span><br><span class="line">  初始条件： 广义表L存在</span><br><span class="line">  操作结果： 取广义表L的头</span><br><span class="line"></span><br><span class="line">GetTail(L);</span><br><span class="line">  初始条件： 广义表L存在</span><br><span class="line">  操作结果： 取广义表L的尾</span><br><span class="line"></span><br><span class="line">InsertFirst_GL(&amp;L, e);</span><br><span class="line">  初始条件： 广义表L存在</span><br><span class="line">  操作结果： 插入元素e作为广义表L的第一元素</span><br><span class="line"></span><br><span class="line">DeleteFirst_GL(&amp;L, &amp;e);</span><br><span class="line">  初始条件： 广义表L存在</span><br><span class="line">  操作结果： 删除广义表L的第一元素，并用e返回其值</span><br><span class="line"></span><br><span class="line">Traverse_GL(L, Visit());</span><br><span class="line">  初始条件： 广义表L存在</span><br><span class="line">  操作结果： 遍历广义表L，用函数Visit处理每个元素</span><br><span class="line">&#125;ADT GList;</span><br></pre></td></tr></table></figure><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>在一个广义表中，其数据元素有单元素和子表之分，所以在对应的存储结构中，其存储结点也有单元素结点和子表结点之分。对于单元素结点，应包括值域<br>和指向其后继结点的指针域；对于子表结点，应包括指向子表中第一个结点的表头指针域和指向其后继结点的指针域。为了把广义表中的单元素结点和子表<br>结点区别开，还必须在每个结点中增设一个标志域，让标志域取不同的值，从而区别不同的结点。</p><p>由于列表中的数据元素可能为原子或列表， 由此需要两种结构的结点： 一种是表结点，用于表示列表；一种是原子结点，用以表示原子。若列表不空，则可分解成表头和表尾；反之，一对确定的表头和表尾可唯一确定列表。由此，一个表结点可由3个域组成： 标志域、指示表头的指针域和指示表尾的指针域； 而原子结点只需两个域： 标志域和值域。</p><p><img src="./matrix_5.png"></p><h5 id="头尾链表存储结构"><a href="#头尾链表存储结构" class="headerlink" title="头尾链表存储结构"></a>头尾链表存储结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------ 广义表的头尾链表存储表示 -------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">ATOM,          <span class="comment">//ATOM == 0: 原子</span></span><br><span class="line">LIST           <span class="comment">//LIST == 1: 子表</span></span><br><span class="line">&#125;ElemTag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> GLNode&#123;</span><br><span class="line">ElemTag tag;                     <span class="comment">//公共部分，用于区分原子结点和表结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span>                           <span class="comment">//原子结点和表结点的联合部分</span></span><br><span class="line">AtomType atom;               <span class="comment">//atom是原子结点的值域，AtomType由用户定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">tp</span>;</span></span><br><span class="line">&#125;ptr;                        <span class="comment">//ptr是表节点的指针域，ptr.hp和ptr.tp分别指向表头和表尾</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;*GList;                             <span class="comment">//广义表类型</span></span><br></pre></td></tr></table></figure><h5 id="扩展线性链表存储结构"><a href="#扩展线性链表存储结构" class="headerlink" title="扩展线性链表存储结构"></a>扩展线性链表存储结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------ 广义表的扩展线性链表存储表示 -------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">ATOM,          <span class="comment">//ATOM == 0: 原子</span></span><br><span class="line">LIST           <span class="comment">//LIST == 1: 子表</span></span><br><span class="line">&#125;ElemTag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> GLNode&#123;</span><br><span class="line">ElemTag tag;                     <span class="comment">//公共部分，用于区分原子结点和表结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span>                           <span class="comment">//原子结点和表结点的联合部分</span></span><br><span class="line">AtomType atom;               <span class="comment">//atom是原子结点的值域，AtomType由用户定义</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>;</span>           <span class="comment">//表结点的表头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">tp</span>;</span>               <span class="comment">//相当于线性链表的next，指向下一个元素结点</span></span><br><span class="line">&#125;*GList;    </span><br></pre></td></tr></table></figure><br/><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.scipy.org/">https://www.scipy.org/</a></li></ul><p>SciPy使用多个数据结构为创建稀疏矩阵提供了工具，以及将稠密矩阵转化为稀疏矩阵的工具。</p><ul><li>csc_matrix: Compressed Sparse Column format</li><li>csr_matrix: Compressed Sparse Row format</li><li>bsr_matrix: Block Sparse Row format</li><li>lil_matrix: List of Lists format</li><li>dok_matrix: Dictionary of Keys format</li><li>coo_matrix: COOrdinate format (aka IJV, triplet format)</li><li>dia_matrix: DIAgonal format</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;h3 id=&quot;矩阵&quot;&gt;&lt;a href=&quot;#矩阵&quot; class=&quot;headerlink&quot; title=&quot;矩阵&quot;&gt;&lt;/a&gt;矩阵&lt;/h3&gt;&lt;p&gt;矩阵是</summary>
      
    
    
    
    <category term="数据结构" scheme="http://shjlone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法 数据结构" scheme="http://shjlone.github.io/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
